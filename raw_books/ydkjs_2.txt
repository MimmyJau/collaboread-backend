[{"data": {"uuid": "0d02bedb-6390-438a-8863-f4049a7d78c2", "user": 1, "title": "You Don't Know JS Yet: Scope & Closures - 2nd Edition", "author": "Kyle Simpson", "created_on": "2023-06-09 00:12:43.341165+00:00", "updated_on": "2023-06-09 00:24:55.870225+00:00", "article_html": "<h1>You Don't Know JS Yet: Scope &amp; Closures - 2nd Edition</h1><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/cover.png\"><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://leanpub.com/ydkjsy-scope-closures\"><strong>Purchase ebook/PDF from Leanpub</strong></a></p><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/toc.md\">Table of Contents</a></p><ul><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/foreword.md\">Foreword</a> (by <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://sarah.dev/\">Sarah Drasner</a>)</p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/preface.md\">Preface</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch1.md\">Chapter 1: What's the Scope?</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch2.md\">Chapter 2: Illustrating Lexical Scope</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md\">Chapter 3: The Scope Chain</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch4.md\">Chapter 4: Around the Global Scope</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch5.md\">Chapter 5: The (Not So) Secret Lifecycle of Variables</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md\">Chapter 6: Limiting Scope Exposure</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md\">Chapter 7: Using Closures</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch8.md\">Chapter 8: The Module Pattern</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md\">Appendix A: Exploring Further</a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apB.md\">Appendix B: Practice</a></p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "You Don't Know JS Yet: Scope & Closures - 2nd Edition", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/cover.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Purchase ebook/PDF from Leanpub", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://leanpub.com/ydkjsy-scope-closures", "class": null, "target": "_blank"}}, {"type": "bold"}]}]}, {"type": "paragraph", "content": [{"text": "Table of Contents", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/toc.md", "class": null, "target": "_blank"}}]}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Foreword", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/foreword.md", "class": null, "target": "_blank"}}]}, {"text": " (by ", "type": "text"}, {"text": "Sarah Drasner", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://sarah.dev/", "class": null, "target": "_blank"}}]}, {"text": ")", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Preface", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/preface.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 1: What's the Scope?", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch1.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 2: Illustrating Lexical Scope", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch2.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 3: The Scope Chain", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 4: Around the Global Scope", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch4.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 5: The (Not So) Secret Lifecycle of Variables", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch5.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 6: Limiting Scope Exposure", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 7: Using Closures", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 8: The Module Pattern", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch8.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix A: Exploring Further", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md", "class": null, "target": "_blank"}}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix B: Practice", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apB.md", "class": null, "target": "_blank"}}]}]}]}]}]}, "article_text": "You Don't Know JS Yet: Scope & Closures - 2nd Edition\n\nPurchase ebook/PDF from Leanpub\n\nTable of Contents\n\nForeword (by Sarah Drasner)\n\nPreface\n\nChapter 1: What's the Scope?\n\nChapter 2: Illustrating Lexical Scope\n\nChapter 3: The Scope Chain\n\nChapter 4: Around the Global Scope\n\nChapter 5: The (Not So) Secret Lifecycle of Variables\n\nChapter 6: Limiting Scope Exposure\n\nChapter 7: Using Closures\n\nChapter 8: The Module Pattern\n\nAppendix A: Exploring Further\n\nAppendix B: Practice"}, "id": 161, "children": [{"data": {"uuid": "2521317a-2e2c-4ef1-afd7-4776ebf7286b", "user": 1, "title": "Table of Contents", "author": "Kyle Simpson", "created_on": "2023-06-09 00:39:54.392695+00:00", "updated_on": "2023-06-09 00:40:07.058602+00:00", "article_html": "<h2>Table of Contents</h2><ul><li><p>Foreword</p></li><li><p>Preface</p></li><li><p>Chapter 1: What's the Scope?</p><ul><li><p>About This Book</p></li><li><p>Compiled vs. Interpreted</p></li><li><p>Compiling Code</p></li><li><p>Compiler Speak</p></li><li><p>Cheating: Run-Time Scope Modifications</p></li><li><p>Lexical Scope</p></li></ul></li><li><p>Chapter 2: Illustrating Lexical Scope</p><ul><li><p>Marbles, and Buckets, and Bubbles... Oh My!</p></li><li><p>A Conversation Among Friends</p></li><li><p>Nested Scope</p></li><li><p>Continue the Conversation</p></li></ul></li><li><p>Chapter 3: The Scope Chain</p><ul><li><p>\"Lookup\" Is (Mostly) Conceptual</p></li><li><p>Shadowing</p></li><li><p>Function Name Scope</p></li><li><p>Arrow Functions</p></li><li><p>Backing Out</p></li></ul></li><li><p>Chapter 4: Around the Global Scope</p><ul><li><p>Why Global Scope?</p></li><li><p>Where Exactly is this Global Scope?</p></li><li><p>Global This</p></li><li><p>Globally Aware</p></li></ul></li><li><p>Chapter 5: The (Not So) Secret Lifecycle of Variables</p><ul><li><p>When Can I Use a Variable?</p></li><li><p>Hoisting: Yet Another Metaphor</p></li><li><p>Re-declaration?</p></li><li><p>Uninitialized Variables (aka, TDZ)</p></li><li><p>Finally Initialized</p></li></ul></li><li><p>Chapter 6: Limiting Scope Exposure</p><ul><li><p>Least Exposure</p></li><li><p>Hiding in Plain (Function) Scope</p></li><li><p>Scoping with Blocks</p></li><li><p>Function Declarations in Blocks</p></li><li><p>Blocked Over</p></li></ul></li><li><p>Chapter 7: Using Closures</p><ul><li><p>See the Closure</p></li><li><p>The Closure Lifecycle and Garbage Collection (GC)</p></li><li><p>Why Closure?</p></li><li><p>An Alternative Perspective</p></li><li><p>Closer to Closure</p></li></ul></li><li><p>Chapter 8: The Module Pattern</p><ul><li><p>Encapsulation and Least Exposure (POLE)</p></li><li><p>What is a Module?</p></li><li><p>Node CommonJS Modules</p></li><li><p>Modern ES Modules (ESM)</p></li><li><p>Exit Scope</p></li></ul></li><li><p>Appendix A: Exploring Further</p><ul><li><p>Implied Scopes</p></li><li><p>Anonymous vs. Named Functions</p></li><li><p>Hoisting: Functions and Variables</p></li><li><p>The Case for <code>var</code></p></li><li><p>What's the Deal with TDZ?</p></li><li><p>Are Synchronous Callbacks Still Closures?</p></li><li><p>Classic Module Variations</p></li></ul></li><li><p>Appendix B: Practice</p><ul><li><p>Buckets of Marbles</p></li><li><p>Closure (PART 1)</p></li><li><p>Closure (PART 2)</p></li><li><p>Closure (PART 3)</p></li><li><p>Modules</p></li><li><p>Suggested Solutions</p></li></ul></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Table of Contents", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Foreword", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Preface", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 1: What's the Scope?", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "About This Book", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Compiled vs. Interpreted", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Compiling Code", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Compiler Speak", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Cheating: Run-Time Scope Modifications", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Lexical Scope", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 2: Illustrating Lexical Scope", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Marbles, and Buckets, and Bubbles... Oh My!", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "A Conversation Among Friends", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Nested Scope", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Continue the Conversation", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 3: The Scope Chain", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "\"Lookup\" Is (Mostly) Conceptual", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Shadowing", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Function Name Scope", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Arrow Functions", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Backing Out", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 4: Around the Global Scope", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Why Global Scope?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Where Exactly is this Global Scope?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Global This", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Globally Aware", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 5: The (Not So) Secret Lifecycle of Variables", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "When Can I Use a Variable?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Hoisting: Yet Another Metaphor", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Re-declaration?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Uninitialized Variables (aka, TDZ)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Finally Initialized", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 6: Limiting Scope Exposure", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Least Exposure", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Hiding in Plain (Function) Scope", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Scoping with Blocks", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Function Declarations in Blocks", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Blocked Over", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 7: Using Closures", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "See the Closure", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The Closure Lifecycle and Garbage Collection (GC)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Why Closure?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "An Alternative Perspective", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closer to Closure", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 8: The Module Pattern", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Encapsulation and Least Exposure (POLE)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "What is a Module?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Node CommonJS Modules", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Modern ES Modules (ESM)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Exit Scope", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix A: Exploring Further", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Implied Scopes", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Anonymous vs. Named Functions", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Hoisting: Functions and Variables", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The Case for ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "What's the Deal with TDZ?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Are Synchronous Callbacks Still Closures?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Classic Module Variations", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix B: Practice", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Buckets of Marbles", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure (PART 1)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure (PART 2)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure (PART 3)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Modules", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Suggested Solutions", "type": "text"}]}]}]}]}]}]}, "article_text": "Table of Contents\n\nForeword\n\nPreface\n\nChapter 1: What's the Scope?\n\nAbout This Book\n\nCompiled vs. Interpreted\n\nCompiling Code\n\nCompiler Speak\n\nCheating: Run-Time Scope Modifications\n\nLexical Scope\n\nChapter 2: Illustrating Lexical Scope\n\nMarbles, and Buckets, and Bubbles... Oh My!\n\nA Conversation Among Friends\n\nNested Scope\n\nContinue the Conversation\n\nChapter 3: The Scope Chain\n\n\"Lookup\" Is (Mostly) Conceptual\n\nShadowing\n\nFunction Name Scope\n\nArrow Functions\n\nBacking Out\n\nChapter 4: Around the Global Scope\n\nWhy Global Scope?\n\nWhere Exactly is this Global Scope?\n\nGlobal This\n\nGlobally Aware\n\nChapter 5: The (Not So) Secret Lifecycle of Variables\n\nWhen Can I Use a Variable?\n\nHoisting: Yet Another Metaphor\n\nRe-declaration?\n\nUninitialized Variables (aka, TDZ)\n\nFinally Initialized\n\nChapter 6: Limiting Scope Exposure\n\nLeast Exposure\n\nHiding in Plain (Function) Scope\n\nScoping with Blocks\n\nFunction Declarations in Blocks\n\nBlocked Over\n\nChapter 7: Using Closures\n\nSee the Closure\n\nThe Closure Lifecycle and Garbage Collection (GC)\n\nWhy Closure?\n\nAn Alternative Perspective\n\nCloser to Closure\n\nChapter 8: The Module Pattern\n\nEncapsulation and Least Exposure (POLE)\n\nWhat is a Module?\n\nNode CommonJS Modules\n\nModern ES Modules (ESM)\n\nExit Scope\n\nAppendix A: Exploring Further\n\nImplied Scopes\n\nAnonymous vs. Named Functions\n\nHoisting: Functions and Variables\n\nThe Case for var\n\nWhat's the Deal with TDZ?\n\nAre Synchronous Callbacks Still Closures?\n\nClassic Module Variations\n\nAppendix B: Practice\n\nBuckets of Marbles\n\nClosure (PART 1)\n\nClosure (PART 2)\n\nClosure (PART 3)\n\nModules\n\nSuggested Solutions"}, "id": 173}, {"data": {"uuid": "79bdf1a3-3cb3-4d7c-8050-e3d88320395d", "user": 1, "title": "Foreward", "author": "Kyle Simpson", "created_on": "2023-06-09 00:38:53.739789+00:00", "updated_on": "2023-06-09 00:39:11.761289+00:00", "article_html": "<h1>Foreword</h1><p>If I look over the books on my bookshelf, I can clearly see which of these titles are well loved. Well loved in this sense meaning they are a little worn. Their binding is broken, their pages are tattered, there might even be a spilled drink smear or two. What\u2019s ironic to me is that the most loved of my books often <strong><em>look</em></strong> the least cared for, though honestly the opposite is true.</p><p><em>Scope and Closures</em> (1st ed.) is one of my most loved books. It\u2019s small, but the binding is coming undone. The pages are worn and dog-eared. It\u2019s a bit rumpled. It\u2019s not a book I\u2019ve read once. I\u2019ve picked it up again and again in the many years since it was originally published.</p><p>For me, it\u2019s also been a benchmark for my own personal progression through JavaScript. When I first read it in 2014, I was familiar with the concepts but the depth of my understanding was admittedly not as deep as the thin volume.</p><p>Over the years, even though I wasn\u2019t necessarily feeling my own improvement on a day-to-day basis, each one of the concepts became more approachable. I\u2019d smile to myself, realizing how far I\u2019d come with the help of these guides. It became apparent there was an inverse correlation between how well I treated the book and how much I loved it.</p><p>When Kyle asked me to write the Foreword for the 2nd edition, I was floored. It\u2019s not often you\u2019re asked to write about a book that\u2019s been so formative for your own understanding and career, <em>Scope and Closures</em> in particular. I remember the day I first understood closures, the first time I used one well. The satisfaction was great, in part because the symmetry of the idea was compelling to me. Before I even picked this book up, I was already enamoured with closures. And yet, there\u2019s a difference between being able to execute code successfully and fully explore the concepts with any depth. This book took my base understanding and drew it out, helped me master it.</p><p>This book is deceptively short. It\u2019s helpful that it\u2019s small because it\u2019s dense with useful knowledge. Since it is compact, I\u2019d suggest you give yourself time to absorb each page. Take your time with it. Treat the book with care, and by that I mean, wear it down.</p><p>Sarah Drasner<br>Head of Developer Experience<br>Netlify</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Foreword", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If I look over the books on my bookshelf, I can clearly see which of these titles are well loved. Well loved in this sense meaning they are a little worn. Their binding is broken, their pages are tattered, there might even be a spilled drink smear or two. What\u2019s ironic to me is that the most loved of my books often ", "type": "text"}, {"text": "look", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": " the least cared for, though honestly the opposite is true.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Scope and Closures", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (1st ed.) is one of my most loved books. It\u2019s small, but the binding is coming undone. The pages are worn and dog-eared. It\u2019s a bit rumpled. It\u2019s not a book I\u2019ve read once. I\u2019ve picked it up again and again in the many years since it was originally published.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For me, it\u2019s also been a benchmark for my own personal progression through JavaScript. When I first read it in 2014, I was familiar with the concepts but the depth of my understanding was admittedly not as deep as the thin volume.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Over the years, even though I wasn\u2019t necessarily feeling my own improvement on a day-to-day basis, each one of the concepts became more approachable. I\u2019d smile to myself, realizing how far I\u2019d come with the help of these guides. It became apparent there was an inverse correlation between how well I treated the book and how much I loved it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When Kyle asked me to write the Foreword for the 2nd edition, I was floored. It\u2019s not often you\u2019re asked to write about a book that\u2019s been so formative for your own understanding and career, ", "type": "text"}, {"text": "Scope and Closures", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in particular. I remember the day I first understood closures, the first time I used one well. The satisfaction was great, in part because the symmetry of the idea was compelling to me. Before I even picked this book up, I was already enamoured with closures. And yet, there\u2019s a difference between being able to execute code successfully and fully explore the concepts with any depth. This book took my base understanding and drew it out, helped me master it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This book is deceptively short. It\u2019s helpful that it\u2019s small because it\u2019s dense with useful knowledge. Since it is compact, I\u2019d suggest you give yourself time to absorb each page. Take your time with it. Treat the book with care, and by that I mean, wear it down.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Sarah Drasner", "type": "text"}, {"type": "hardBreak"}, {"text": "Head of Developer Experience", "type": "text"}, {"type": "hardBreak"}, {"text": "Netlify", "type": "text"}]}]}, "article_text": "Foreword\n\nIf I look over the books on my bookshelf, I can clearly see which of these titles are well loved. Well loved in this sense meaning they are a little worn. Their binding is broken, their pages are tattered, there might even be a spilled drink smear or two. What\u2019s ironic to me is that the most loved of my books often look the least cared for, though honestly the opposite is true.\n\nScope and Closures (1st ed.) is one of my most loved books. It\u2019s small, but the binding is coming undone. The pages are worn and dog-eared. It\u2019s a bit rumpled. It\u2019s not a book I\u2019ve read once. I\u2019ve picked it up again and again in the many years since it was originally published.\n\nFor me, it\u2019s also been a benchmark for my own personal progression through JavaScript. When I first read it in 2014, I was familiar with the concepts but the depth of my understanding was admittedly not as deep as the thin volume.\n\nOver the years, even though I wasn\u2019t necessarily feeling my own improvement on a day-to-day basis, each one of the concepts became more approachable. I\u2019d smile to myself, realizing how far I\u2019d come with the help of these guides. It became apparent there was an inverse correlation between how well I treated the book and how much I loved it.\n\nWhen Kyle asked me to write the Foreword for the 2nd edition, I was floored. It\u2019s not often you\u2019re asked to write about a book that\u2019s been so formative for your own understanding and career, Scope and Closures in particular. I remember the day I first understood closures, the first time I used one well. The satisfaction was great, in part because the symmetry of the idea was compelling to me. Before I even picked this book up, I was already enamoured with closures. And yet, there\u2019s a difference between being able to execute code successfully and fully explore the concepts with any depth. This book took my base understanding and drew it out, helped me master it.\n\nThis book is deceptively short. It\u2019s helpful that it\u2019s small because it\u2019s dense with useful knowledge. Since it is compact, I\u2019d suggest you give yourself time to absorb each page. Take your time with it. Treat the book with care, and by that I mean, wear it down.\n\nSarah Drasner\nHead of Developer Experience\nNetlify"}, "id": 172}, {"data": {"uuid": "37d97342-4f0c-4b12-94e0-0f992f2c345d", "user": 1, "title": "Preface", "author": "Kyle Simpson", "created_on": "2023-06-09 00:41:01.000612+00:00", "updated_on": "2023-06-09 00:41:23.658388+00:00", "article_html": "<h1>Preface</h1><p>Welcome to the 2nd edition of the widely acclaimed <em>You Don't Know JS</em> (<strong>YDKJS</strong>) book series: <em>You Don't Know JS </em><strong><em>Yet</em></strong> (<strong>YDKJSY</strong>).</p><p>If you've read any of the 1st edition books, you can expect a refreshed approach in these new ones, with plenty of updated coverage of what's changed in JS over the last five years. But what I hope and believe you'll still <em>get</em> is the same commitment to respecting JS and digging into what really makes it tick.</p><p>If this is your first time reading these books, I'm glad you're here. Prepare for a deep and extensive journey into all the corners of JavaScript.</p><p>If you are new to programming or JS, be aware that these books are not intended as a gentle \"intro to JavaScript.\" This material is, at times, complex and challenging, and goes much deeper than is typical for a first-time learner. You're welcome here no matter what your background is, but these books are written assuming you're already comfortable with JS and have at least 6\u20139 months experience with it.</p><h2>The Parts</h2><p>These books approach JavaScript intentionally opposite of how <em>The Good Parts</em> treats the language. No, that doesn't mean we're looking at <em>the bad parts</em>, but rather, exploring <strong>all the parts</strong>.</p><p>You may have been told, or felt yourself, that JS is a deeply flawed language that was poorly designed and inconsistently implemented. Many have asserted that it's the worst most popular language in the world; that nobody writes JS because they want to, only because they have to given its place at the center of the web. That's a ridiculous, unhealthy, and wholly condescending claim.</p><p>Millions of developers write JavaScript every day, and many of them appreciate and respect the language.</p><p>Like any great language, it has its brilliant parts as well as its scars. Even the creator of JavaScript himself, Brendan Eich, laments some of those parts as mistakes. But he's wrong: they weren't mistakes at all. JS is what it is today\u2014the world's most ubiquitous and thus most influential programming language\u2014precisely because of <em>all those parts</em>.</p><p>Don't buy the lie that you should only learn and use a small collection of <em>good parts</em> while avoiding all the bad stuff. Don't buy the \"X is the new Y\" snake oil, that some new feature of the language instantly relegates all usage of a previous feature as obsolete and ignorant. Don't listen when someone says your code isn't \"modern\" because it isn't yet using a stage-0 feature that was only proposed a few weeks ago!</p><p>Every part of JS is useful. Some parts are more useful than others. Some parts require you to be more careful and intentional.</p><p>I find it absurd to try to be a truly effective JavaScript developer while only using a small sliver of what the language has to offer. Can you imagine a construction worker with a toolbox full of tools, who only uses their hammer and scoffs at the screwdriver or tape measure as inferior? That's just silly.</p><p>My unreserved claim is that you should go about learning all parts of JavaScript, and where appropriate, use them! And if I may be so bold as to suggest: it's time to discard any JS books that tell you otherwise.</p><h2>The Title?</h2><p>So what's the title of the series all about?</p><p>I'm not trying to insult you with criticism about your current lack of knowledge or understanding of JavaScript. I'm not suggesting you can't or won't be able to learn JavaScript. I'm not boasting about secret advanced insider wisdom that I and only a select few possess.</p><p>Seriously, all those were real reactions to the original series title before folks even read the books. And they're baseless.</p><p>The primary point of the title \"You Don't Know JS Yet\" is to point out that most JS developers don't take the time to really understand how the code that they write works. They know <em>that</em> it works\u2014that it produces a desired outcome. But they either don't understand exactly <em>how</em>, or worse, they have an inaccurate mental model for the <em>how</em> that falters on closer scrutiny.</p><p>I'm presenting a gentle but earnest challenge to you the reader, to set aside the assumptions you have about JS, and approach it with fresh eyes and an invigorated curiosity that leads you to ask <em>why</em> for every line of code you write. Why does it do what it does? Why is one way better or more appropriate than the other half-dozen ways you could have accomplished it? Why do all the \"popular kids\" say to do X with your code, but it turns out that Y might be a better choice?</p><p>I added \"Yet\" to the title, not only because it's the second edition, but because ultimately I want these books to challenge you in a hopeful rather than discouraging way.</p><p>But let me be clear: I don't think it's possible to ever fully <em>know</em> JS. That's not an achievement to be obtained, but a goal to strive after. You don't finish knowing everything about JS, you just keep learning more and more as you spend more time with the language. And the deeper you go, the more you revisit what you <em>knew</em> before, and you re-learn it from that more experienced perspective.</p><p>I encourage you to adopt a mindset around JavaScript, and indeed all of software development, that you will never fully have mastered it, but that you can and should keep working to get closer to that end, a journey that will stretch for the entirety of your software development career, and beyond.</p><p>You can always know JS better than you currently do. That's what I hope these YDKJSY books represent.</p><h2>The Mission</h2><p>The case doesn't really need to be made for why developers should take JS seriously\u2014I think it's already more than proven worthy of first-class status among the world's programming languages.</p><p>But a different, more important case still needs to be made, and these books rise to that challenge.</p><p>I've taught more than 5,000 developers from teams and companies all over the world, in more than 25 countries on six continents. And what I've seen is that far too often, what <em>counts</em> is generally just the result of the program, not how the program is written or how/why it works.</p><p>My experience not only as a developer but in teaching many other developers tells me: you will always be more effective in your development work if you more completely understand how your code works than you are solely <em>just</em> getting it to produce a desired outcome.</p><p>In other words, <em>good enough to work</em> is not, and should not be, <em>good enough</em>.</p><p>All developers regularly struggle with some piece of code not working correctly, and they can't figure out why. But far too often, JS developers will blame this on the language rather than admitting it's their own understanding that is falling short. These books serve as both the question and answer: why did it do <em>this</em>, and here's how to get it to do <em>that</em> instead.</p><p>My mission with YDKJSY is to empower every single JS developer to fully own the code they write, to understand it and to write with intention and clarity.</p><h2>The Path</h2><p>Some of you have started reading this book with the goal of completing all six books, back to back.</p><p>I would like to caution you to consider changing that plan.</p><p>It is not my intention that YDKJSY be read straight through. The material in these books is dense, because JavaScript is powerful, sophisticated, and in parts rather complex. Nobody can really hope to <em>download</em> all this information to their brains in a single pass and retain any significant amount of it. That's unreasonable, and it's foolish to try.</p><p>My suggestion is you take your time going through YDKJSY. Take one chapter, read it completely through start to finish, and then go back and re-read it section by section. Stop in between each section, and practice the code or ideas from that section. For larger concepts, it probably is a good idea to expect to spend several days digesting, re-reading, practicing, then digesting some more.</p><p>You could spend a week or two on each chapter, and a month or two on each book, and a year or more on the whole series, and you would still not be squeezing every ounce of YDKJSY out.</p><p>Don't binge these books; be patient and spread out your reading. Interleave reading with lots of practice on real code in your job or on projects you participate in. Wrestle with the opinions I've presented along the way, debate with others, and most of all, disagree with me! Run a study group or book club. Teach mini-workshops at your office. Write blog posts on what you've learned. Speak about these topics at local JS meetups.</p><p>It's never my goal to convince you to agree with my opinion, but to encourage you to own and be able to defend your opinions. You can't get <em>there</em> with an expedient read-through of these books. That's something that takes a long while to emerge, little by little, as you study and ponder and re-visit.</p><p>These books are meant to be a field-guide on your wanderings through JavaScript, from wherever you currently are with the language, to a place of deeper understanding. And the deeper you understand JS, the more questions you will ask and the more you will have to explore! That's what I find so exciting!</p><p>I'm so glad you're embarking on this journey, and I am so honored you would consider and consult these books along the way. It's time to start <em>getting to know JS</em>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Preface", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Welcome to the 2nd edition of the widely acclaimed ", "type": "text"}, {"text": "You Don't Know JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (", "type": "text"}, {"text": "YDKJS", "type": "text", "marks": [{"type": "bold"}]}, {"text": ") book series: ", "type": "text"}, {"text": "You Don't Know JS ", "type": "text", "marks": [{"type": "italic"}]}, {"text": "Yet", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": " (", "type": "text"}, {"text": "YDKJSY", "type": "text", "marks": [{"type": "bold"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you've read any of the 1st edition books, you can expect a refreshed approach in these new ones, with plenty of updated coverage of what's changed in JS over the last five years. But what I hope and believe you'll still ", "type": "text"}, {"text": "get", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is the same commitment to respecting JS and digging into what really makes it tick.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If this is your first time reading these books, I'm glad you're here. Prepare for a deep and extensive journey into all the corners of JavaScript.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you are new to programming or JS, be aware that these books are not intended as a gentle \"intro to JavaScript.\" This material is, at times, complex and challenging, and goes much deeper than is typical for a first-time learner. You're welcome here no matter what your background is, but these books are written assuming you're already comfortable with JS and have at least 6\u20139 months experience with it.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Parts", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These books approach JavaScript intentionally opposite of how ", "type": "text"}, {"text": "The Good Parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": " treats the language. No, that doesn't mean we're looking at ", "type": "text"}, {"text": "the bad parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", but rather, exploring ", "type": "text"}, {"text": "all the parts", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You may have been told, or felt yourself, that JS is a deeply flawed language that was poorly designed and inconsistently implemented. Many have asserted that it's the worst most popular language in the world; that nobody writes JS because they want to, only because they have to given its place at the center of the web. That's a ridiculous, unhealthy, and wholly condescending claim.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Millions of developers write JavaScript every day, and many of them appreciate and respect the language.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Like any great language, it has its brilliant parts as well as its scars. Even the creator of JavaScript himself, Brendan Eich, laments some of those parts as mistakes. But he's wrong: they weren't mistakes at all. JS is what it is today\u2014the world's most ubiquitous and thus most influential programming language\u2014precisely because of ", "type": "text"}, {"text": "all those parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't buy the lie that you should only learn and use a small collection of ", "type": "text"}, {"text": "good parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": " while avoiding all the bad stuff. Don't buy the \"X is the new Y\" snake oil, that some new feature of the language instantly relegates all usage of a previous feature as obsolete and ignorant. Don't listen when someone says your code isn't \"modern\" because it isn't yet using a stage-0 feature that was only proposed a few weeks ago!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Every part of JS is useful. Some parts are more useful than others. Some parts require you to be more careful and intentional.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I find it absurd to try to be a truly effective JavaScript developer while only using a small sliver of what the language has to offer. Can you imagine a construction worker with a toolbox full of tools, who only uses their hammer and scoffs at the screwdriver or tape measure as inferior? That's just silly.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My unreserved claim is that you should go about learning all parts of JavaScript, and where appropriate, use them! And if I may be so bold as to suggest: it's time to discard any JS books that tell you otherwise.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Title?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So what's the title of the series all about?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm not trying to insult you with criticism about your current lack of knowledge or understanding of JavaScript. I'm not suggesting you can't or won't be able to learn JavaScript. I'm not boasting about secret advanced insider wisdom that I and only a select few possess.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Seriously, all those were real reactions to the original series title before folks even read the books. And they're baseless.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The primary point of the title \"You Don't Know JS Yet\" is to point out that most JS developers don't take the time to really understand how the code that they write works. They know ", "type": "text"}, {"text": "that", "type": "text", "marks": [{"type": "italic"}]}, {"text": " it works\u2014that it produces a desired outcome. But they either don't understand exactly ", "type": "text"}, {"text": "how", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", or worse, they have an inaccurate mental model for the ", "type": "text"}, {"text": "how", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that falters on closer scrutiny.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm presenting a gentle but earnest challenge to you the reader, to set aside the assumptions you have about JS, and approach it with fresh eyes and an invigorated curiosity that leads you to ask ", "type": "text"}, {"text": "why", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for every line of code you write. Why does it do what it does? Why is one way better or more appropriate than the other half-dozen ways you could have accomplished it? Why do all the \"popular kids\" say to do X with your code, but it turns out that Y might be a better choice?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I added \"Yet\" to the title, not only because it's the second edition, but because ultimately I want these books to challenge you in a hopeful rather than discouraging way.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But let me be clear: I don't think it's possible to ever fully ", "type": "text"}, {"text": "know", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JS. That's not an achievement to be obtained, but a goal to strive after. You don't finish knowing everything about JS, you just keep learning more and more as you spend more time with the language. And the deeper you go, the more you revisit what you ", "type": "text"}, {"text": "knew", "type": "text", "marks": [{"type": "italic"}]}, {"text": " before, and you re-learn it from that more experienced perspective.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I encourage you to adopt a mindset around JavaScript, and indeed all of software development, that you will never fully have mastered it, but that you can and should keep working to get closer to that end, a journey that will stretch for the entirety of your software development career, and beyond.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You can always know JS better than you currently do. That's what I hope these YDKJSY books represent.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Mission", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The case doesn't really need to be made for why developers should take JS seriously\u2014I think it's already more than proven worthy of first-class status among the world's programming languages.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But a different, more important case still needs to be made, and these books rise to that challenge.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I've taught more than 5,000 developers from teams and companies all over the world, in more than 25 countries on six continents. And what I've seen is that far too often, what ", "type": "text"}, {"text": "counts", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is generally just the result of the program, not how the program is written or how/why it works.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My experience not only as a developer but in teaching many other developers tells me: you will always be more effective in your development work if you more completely understand how your code works than you are solely ", "type": "text"}, {"text": "just", "type": "text", "marks": [{"type": "italic"}]}, {"text": " getting it to produce a desired outcome.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, ", "type": "text"}, {"text": "good enough to work", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is not, and should not be, ", "type": "text"}, {"text": "good enough", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All developers regularly struggle with some piece of code not working correctly, and they can't figure out why. But far too often, JS developers will blame this on the language rather than admitting it's their own understanding that is falling short. These books serve as both the question and answer: why did it do ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and here's how to get it to do ", "type": "text"}, {"text": "that", "type": "text", "marks": [{"type": "italic"}]}, {"text": " instead.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My mission with YDKJSY is to empower every single JS developer to fully own the code they write, to understand it and to write with intention and clarity.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Path", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some of you have started reading this book with the goal of completing all six books, back to back.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I would like to caution you to consider changing that plan.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It is not my intention that YDKJSY be read straight through. The material in these books is dense, because JavaScript is powerful, sophisticated, and in parts rather complex. Nobody can really hope to ", "type": "text"}, {"text": "download", "type": "text", "marks": [{"type": "italic"}]}, {"text": " all this information to their brains in a single pass and retain any significant amount of it. That's unreasonable, and it's foolish to try.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My suggestion is you take your time going through YDKJSY. Take one chapter, read it completely through start to finish, and then go back and re-read it section by section. Stop in between each section, and practice the code or ideas from that section. For larger concepts, it probably is a good idea to expect to spend several days digesting, re-reading, practicing, then digesting some more.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You could spend a week or two on each chapter, and a month or two on each book, and a year or more on the whole series, and you would still not be squeezing every ounce of YDKJSY out.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't binge these books; be patient and spread out your reading. Interleave reading with lots of practice on real code in your job or on projects you participate in. Wrestle with the opinions I've presented along the way, debate with others, and most of all, disagree with me! Run a study group or book club. Teach mini-workshops at your office. Write blog posts on what you've learned. Speak about these topics at local JS meetups.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's never my goal to convince you to agree with my opinion, but to encourage you to own and be able to defend your opinions. You can't get ", "type": "text"}, {"text": "there", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with an expedient read-through of these books. That's something that takes a long while to emerge, little by little, as you study and ponder and re-visit.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These books are meant to be a field-guide on your wanderings through JavaScript, from wherever you currently are with the language, to a place of deeper understanding. And the deeper you understand JS, the more questions you will ask and the more you will have to explore! That's what I find so exciting!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm so glad you're embarking on this journey, and I am so honored you would consider and consult these books along the way. It's time to start ", "type": "text"}, {"text": "getting to know JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Preface\n\nWelcome to the 2nd edition of the widely acclaimed You Don't Know JS (YDKJS) book series: You Don't Know JS Yet (YDKJSY).\n\nIf you've read any of the 1st edition books, you can expect a refreshed approach in these new ones, with plenty of updated coverage of what's changed in JS over the last five years. But what I hope and believe you'll still get is the same commitment to respecting JS and digging into what really makes it tick.\n\nIf this is your first time reading these books, I'm glad you're here. Prepare for a deep and extensive journey into all the corners of JavaScript.\n\nIf you are new to programming or JS, be aware that these books are not intended as a gentle \"intro to JavaScript.\" This material is, at times, complex and challenging, and goes much deeper than is typical for a first-time learner. You're welcome here no matter what your background is, but these books are written assuming you're already comfortable with JS and have at least 6\u20139 months experience with it.\n\nThe Parts\n\nThese books approach JavaScript intentionally opposite of how The Good Parts treats the language. No, that doesn't mean we're looking at the bad parts, but rather, exploring all the parts.\n\nYou may have been told, or felt yourself, that JS is a deeply flawed language that was poorly designed and inconsistently implemented. Many have asserted that it's the worst most popular language in the world; that nobody writes JS because they want to, only because they have to given its place at the center of the web. That's a ridiculous, unhealthy, and wholly condescending claim.\n\nMillions of developers write JavaScript every day, and many of them appreciate and respect the language.\n\nLike any great language, it has its brilliant parts as well as its scars. Even the creator of JavaScript himself, Brendan Eich, laments some of those parts as mistakes. But he's wrong: they weren't mistakes at all. JS is what it is today\u2014the world's most ubiquitous and thus most influential programming language\u2014precisely because of all those parts.\n\nDon't buy the lie that you should only learn and use a small collection of good parts while avoiding all the bad stuff. Don't buy the \"X is the new Y\" snake oil, that some new feature of the language instantly relegates all usage of a previous feature as obsolete and ignorant. Don't listen when someone says your code isn't \"modern\" because it isn't yet using a stage-0 feature that was only proposed a few weeks ago!\n\nEvery part of JS is useful. Some parts are more useful than others. Some parts require you to be more careful and intentional.\n\nI find it absurd to try to be a truly effective JavaScript developer while only using a small sliver of what the language has to offer. Can you imagine a construction worker with a toolbox full of tools, who only uses their hammer and scoffs at the screwdriver or tape measure as inferior? That's just silly.\n\nMy unreserved claim is that you should go about learning all parts of JavaScript, and where appropriate, use them! And if I may be so bold as to suggest: it's time to discard any JS books that tell you otherwise.\n\nThe Title?\n\nSo what's the title of the series all about?\n\nI'm not trying to insult you with criticism about your current lack of knowledge or understanding of JavaScript. I'm not suggesting you can't or won't be able to learn JavaScript. I'm not boasting about secret advanced insider wisdom that I and only a select few possess.\n\nSeriously, all those were real reactions to the original series title before folks even read the books. And they're baseless.\n\nThe primary point of the title \"You Don't Know JS Yet\" is to point out that most JS developers don't take the time to really understand how the code that they write works. They know that it works\u2014that it produces a desired outcome. But they either don't understand exactly how, or worse, they have an inaccurate mental model for the how that falters on closer scrutiny.\n\nI'm presenting a gentle but earnest challenge to you the reader, to set aside the assumptions you have about JS, and approach it with fresh eyes and an invigorated curiosity that leads you to ask why for every line of code you write. Why does it do what it does? Why is one way better or more appropriate than the other half-dozen ways you could have accomplished it? Why do all the \"popular kids\" say to do X with your code, but it turns out that Y might be a better choice?\n\nI added \"Yet\" to the title, not only because it's the second edition, but because ultimately I want these books to challenge you in a hopeful rather than discouraging way.\n\nBut let me be clear: I don't think it's possible to ever fully know JS. That's not an achievement to be obtained, but a goal to strive after. You don't finish knowing everything about JS, you just keep learning more and more as you spend more time with the language. And the deeper you go, the more you revisit what you knew before, and you re-learn it from that more experienced perspective.\n\nI encourage you to adopt a mindset around JavaScript, and indeed all of software development, that you will never fully have mastered it, but that you can and should keep working to get closer to that end, a journey that will stretch for the entirety of your software development career, and beyond.\n\nYou can always know JS better than you currently do. That's what I hope these YDKJSY books represent.\n\nThe Mission\n\nThe case doesn't really need to be made for why developers should take JS seriously\u2014I think it's already more than proven worthy of first-class status among the world's programming languages.\n\nBut a different, more important case still needs to be made, and these books rise to that challenge.\n\nI've taught more than 5,000 developers from teams and companies all over the world, in more than 25 countries on six continents. And what I've seen is that far too often, what counts is generally just the result of the program, not how the program is written or how/why it works.\n\nMy experience not only as a developer but in teaching many other developers tells me: you will always be more effective in your development work if you more completely understand how your code works than you are solely just getting it to produce a desired outcome.\n\nIn other words, good enough to work is not, and should not be, good enough.\n\nAll developers regularly struggle with some piece of code not working correctly, and they can't figure out why. But far too often, JS developers will blame this on the language rather than admitting it's their own understanding that is falling short. These books serve as both the question and answer: why did it do this, and here's how to get it to do that instead.\n\nMy mission with YDKJSY is to empower every single JS developer to fully own the code they write, to understand it and to write with intention and clarity.\n\nThe Path\n\nSome of you have started reading this book with the goal of completing all six books, back to back.\n\nI would like to caution you to consider changing that plan.\n\nIt is not my intention that YDKJSY be read straight through. The material in these books is dense, because JavaScript is powerful, sophisticated, and in parts rather complex. Nobody can really hope to download all this information to their brains in a single pass and retain any significant amount of it. That's unreasonable, and it's foolish to try.\n\nMy suggestion is you take your time going through YDKJSY. Take one chapter, read it completely through start to finish, and then go back and re-read it section by section. Stop in between each section, and practice the code or ideas from that section. For larger concepts, it probably is a good idea to expect to spend several days digesting, re-reading, practicing, then digesting some more.\n\nYou could spend a week or two on each chapter, and a month or two on each book, and a year or more on the whole series, and you would still not be squeezing every ounce of YDKJSY out.\n\nDon't binge these books; be patient and spread out your reading. Interleave reading with lots of practice on real code in your job or on projects you participate in. Wrestle with the opinions I've presented along the way, debate with others, and most of all, disagree with me! Run a study group or book club. Teach mini-workshops at your office. Write blog posts on what you've learned. Speak about these topics at local JS meetups.\n\nIt's never my goal to convince you to agree with my opinion, but to encourage you to own and be able to defend your opinions. You can't get there with an expedient read-through of these books. That's something that takes a long while to emerge, little by little, as you study and ponder and re-visit.\n\nThese books are meant to be a field-guide on your wanderings through JavaScript, from wherever you currently are with the language, to a place of deeper understanding. And the deeper you understand JS, the more questions you will ask and the more you will have to explore! That's what I find so exciting!\n\nI'm so glad you're embarking on this journey, and I am so honored you would consider and consult these books along the way. It's time to start getting to know JS."}, "id": 174}, {"data": {"uuid": "27cdb14a-a84c-4a7a-8cbf-7ba4618be53f", "user": 1, "title": "Chapter 1: What's the Scope?", "author": "Kyle Simpson", "created_on": "2023-06-09 00:25:22.386007+00:00", "updated_on": "2023-06-09 00:28:41.745487+00:00", "article_html": "<h1>Chapter 1: What's the Scope?</h1><p>By the time you've written your first few programs, you're likely getting somewhat comfortable with creating variables and storing values in them. Working with variables is one of the most foundational things we do in programming!</p><p>But you may not have considered very closely the underlying mechanisms used by the engine to organize and manage these variables. I don't mean how the memory is allocated on the computer, but rather: how does JS know which variables are accessible by any given statement, and how does it handle two variables of the same name?</p><p>The answers to questions like these take the form of well-defined rules called scope. This book will dig through all aspects of scope\u2014how it works, what it's useful for, gotchas to avoid\u2014and then point toward common scope patterns that guide the structure of programs.</p><p>Our first step is to uncover how the JS engine processes our program <strong>before</strong> it runs.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 1: What's the Scope?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By the time you've written your first few programs, you're likely getting somewhat comfortable with creating variables and storing values in them. Working with variables is one of the most foundational things we do in programming!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But you may not have considered very closely the underlying mechanisms used by the engine to organize and manage these variables. I don't mean how the memory is allocated on the computer, but rather: how does JS know which variables are accessible by any given statement, and how does it handle two variables of the same name?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The answers to questions like these take the form of well-defined rules called scope. This book will dig through all aspects of scope\u2014how it works, what it's useful for, gotchas to avoid\u2014and then point toward common scope patterns that guide the structure of programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Our first step is to uncover how the JS engine processes our program ", "type": "text"}, {"text": "before", "type": "text", "marks": [{"type": "bold"}]}, {"text": " it runs.", "type": "text"}]}]}, "article_text": "Chapter 1: What's the Scope?\n\nBy the time you've written your first few programs, you're likely getting somewhat comfortable with creating variables and storing values in them. Working with variables is one of the most foundational things we do in programming!\n\nBut you may not have considered very closely the underlying mechanisms used by the engine to organize and manage these variables. I don't mean how the memory is allocated on the computer, but rather: how does JS know which variables are accessible by any given statement, and how does it handle two variables of the same name?\n\nThe answers to questions like these take the form of well-defined rules called scope. This book will dig through all aspects of scope\u2014how it works, what it's useful for, gotchas to avoid\u2014and then point toward common scope patterns that guide the structure of programs.\n\nOur first step is to uncover how the JS engine processes our program before it runs."}, "id": 162, "children": [{"data": {"uuid": "0f19eea5-d2b0-4513-812e-a5f738fc2256", "user": 1, "title": "About This Book", "author": "Kyle Simpson", "created_on": "2023-06-09 00:29:06.281100+00:00", "updated_on": "2023-06-09 00:29:28.402557+00:00", "article_html": "<h2>About This Book</h2><p>Welcome to book 2 in the <em>You Don't Know JS Yet</em> series! If you already finished <em>Get Started</em> (the first book), you're in the right spot! If not, before you proceed I encourage you to <em>start there</em> for the best foundation.</p><p>Our focus will be the first of three pillars in the JS language: the scope system and its function closures, as well as the power of the module design pattern.</p><p>JS is typically classified as an interpreted scripting language, so it's assumed by most that JS programs are processed in a single, top-down pass. But JS is in fact parsed/compiled in a separate phase <strong>before execution begins</strong>. The code author's decisions on where to place variables, functions, and blocks with respect to each other are analyzed according to the rules of scope, during the initial parsing/compilation phase. The resulting scope structure is generally unaffected by runtime conditions.</p><p>JS functions are themselves first-class values; they can be assigned and passed around just like numbers or strings. But since these functions hold and access variables, they maintain their original scope no matter where in the program the functions are eventually executed. This is called closure.</p><p>Modules are a code organization pattern characterized by public methods that have privileged access (via closure) to hidden variables and functions in the internal scope of the module.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "About This Book", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Welcome to book 2 in the ", "type": "text"}, {"text": "You Don't Know JS Yet", "type": "text", "marks": [{"type": "italic"}]}, {"text": " series! If you already finished ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (the first book), you're in the right spot! If not, before you proceed I encourage you to ", "type": "text"}, {"text": "start there", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for the best foundation.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Our focus will be the first of three pillars in the JS language: the scope system and its function closures, as well as the power of the module design pattern.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS is typically classified as an interpreted scripting language, so it's assumed by most that JS programs are processed in a single, top-down pass. But JS is in fact parsed/compiled in a separate phase ", "type": "text"}, {"text": "before execution begins", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". The code author's decisions on where to place variables, functions, and blocks with respect to each other are analyzed according to the rules of scope, during the initial parsing/compilation phase. The resulting scope structure is generally unaffected by runtime conditions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS functions are themselves first-class values; they can be assigned and passed around just like numbers or strings. But since these functions hold and access variables, they maintain their original scope no matter where in the program the functions are eventually executed. This is called closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Modules are a code organization pattern characterized by public methods that have privileged access (via closure) to hidden variables and functions in the internal scope of the module.", "type": "text"}]}]}, "article_text": "About This Book\n\nWelcome to book 2 in the You Don't Know JS Yet series! If you already finished Get Started (the first book), you're in the right spot! If not, before you proceed I encourage you to start there for the best foundation.\n\nOur focus will be the first of three pillars in the JS language: the scope system and its function closures, as well as the power of the module design pattern.\n\nJS is typically classified as an interpreted scripting language, so it's assumed by most that JS programs are processed in a single, top-down pass. But JS is in fact parsed/compiled in a separate phase before execution begins. The code author's decisions on where to place variables, functions, and blocks with respect to each other are analyzed according to the rules of scope, during the initial parsing/compilation phase. The resulting scope structure is generally unaffected by runtime conditions.\n\nJS functions are themselves first-class values; they can be assigned and passed around just like numbers or strings. But since these functions hold and access variables, they maintain their original scope no matter where in the program the functions are eventually executed. This is called closure.\n\nModules are a code organization pattern characterized by public methods that have privileged access (via closure) to hidden variables and functions in the internal scope of the module."}, "id": 163}, {"data": {"uuid": "e3f5d057-23fd-4c17-b681-0bd5022367e8", "user": 1, "title": "Compiled vs. Interpreted", "author": "Kyle Simpson", "created_on": "2023-06-09 00:30:34.366015+00:00", "updated_on": "2023-06-09 00:31:54.235317+00:00", "article_html": "<h2>Compiled vs. Interpreted</h2><p>You may have heard of <em>code compilation</em> before, but perhaps it seems like a mysterious black box where source code slides in one end and executable programs pop out the other.</p><p>It's not mysterious or magical, though. Code compilation is a set of steps that process the text of your code and turn it into a list of instructions the computer can understand. Typically, the whole source code is transformed at once, and those resulting instructions are saved as output (usually in a file) that can later be executed.</p><p>You also may have heard that code can be <em>interpreted</em>, so how is that different from being <em>compiled</em>?</p><p>Interpretation performs a similar task to compilation, in that it transforms your program into machine-understandable instructions. But the processing model is different. Unlike a program being compiled all at once, with interpretation the source code is transformed line by line; each line or statement is executed before immediately proceeding to processing the next line of the source code.</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig1.png\"><p><em>Fig. 1: Compiled vs. Interpreted Code</em> <br><br>Figure 1 illustrates compilation vs. interpretation of programs.</p><p> Are these two processing models mutually exclusive? Generally, yes. However, the issue is more nuanced, because interpretation can actually take other forms than just operating line by line on source code text. Modern JS engines actually employ numerous variations of both compilation and interpretation in the handling of JS programs.</p><p> Recall that we surveyed this topic in Chapter 1 of the <em>Get Started</em> book. Our conclusion there is that JS is most accurately portrayed as a <strong>compiled language</strong>. For the benefit of readers here, the following sections will revisit and expand on that assertion.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Compiled vs. Interpreted", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You may have heard of ", "type": "text"}, {"text": "code compilation", "type": "text", "marks": [{"type": "italic"}]}, {"text": " before, but perhaps it seems like a mysterious black box where source code slides in one end and executable programs pop out the other.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's not mysterious or magical, though. Code compilation is a set of steps that process the text of your code and turn it into a list of instructions the computer can understand. Typically, the whole source code is transformed at once, and those resulting instructions are saved as output (usually in a file) that can later be executed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You also may have heard that code can be ", "type": "text"}, {"text": "interpreted", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", so how is that different from being ", "type": "text"}, {"text": "compiled", "type": "text", "marks": [{"type": "italic"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Interpretation performs a similar task to compilation, in that it transforms your program into machine-understandable instructions. But the processing model is different. Unlike a program being compiled all at once, with interpretation the source code is transformed line by line; each line or statement is executed before immediately proceeding to processing the next line of the source code.", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig1.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 1: Compiled vs. Interpreted Code", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"type": "hardBreak"}, {"type": "hardBreak"}, {"text": "Figure 1 illustrates compilation vs. interpretation of programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": " Are these two processing models mutually exclusive? Generally, yes. However, the issue is more nuanced, because interpretation can actually take other forms than just operating line by line on source code text. Modern JS engines actually employ numerous variations of both compilation and interpretation in the handling of JS programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": " Recall that we surveyed this topic in Chapter 1 of the ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " book. Our conclusion there is that JS is most accurately portrayed as a ", "type": "text"}, {"text": "compiled language", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". For the benefit of readers here, the following sections will revisit and expand on that assertion.", "type": "text"}]}]}, "article_text": "Compiled vs. Interpreted\n\nYou may have heard of code compilation before, but perhaps it seems like a mysterious black box where source code slides in one end and executable programs pop out the other.\n\nIt's not mysterious or magical, though. Code compilation is a set of steps that process the text of your code and turn it into a list of instructions the computer can understand. Typically, the whole source code is transformed at once, and those resulting instructions are saved as output (usually in a file) that can later be executed.\n\nYou also may have heard that code can be interpreted, so how is that different from being compiled?\n\nInterpretation performs a similar task to compilation, in that it transforms your program into machine-understandable instructions. But the processing model is different. Unlike a program being compiled all at once, with interpretation the source code is transformed line by line; each line or statement is executed before immediately proceeding to processing the next line of the source code.\n\nFig. 1: Compiled vs. Interpreted Code \n\nFigure 1 illustrates compilation vs. interpretation of programs.\n\n Are these two processing models mutually exclusive? Generally, yes. However, the issue is more nuanced, because interpretation can actually take other forms than just operating line by line on source code text. Modern JS engines actually employ numerous variations of both compilation and interpretation in the handling of JS programs.\n\n Recall that we surveyed this topic in Chapter 1 of the Get Started book. Our conclusion there is that JS is most accurately portrayed as a compiled language. For the benefit of readers here, the following sections will revisit and expand on that assertion."}, "id": 164}, {"data": {"uuid": "5bd77a3e-d303-4162-9f4b-53a71dc8e85e", "user": 1, "title": "Compiling Code", "author": "Kyle Simpson", "created_on": "2023-06-09 00:32:22.204287+00:00", "updated_on": "2023-06-09 00:32:50.318848+00:00", "article_html": "<h2>Compiling Code</h2><p>But first, why does it even matter whether JS is compiled or not?</p><p>Scope is primarily determined during compilation, so understanding how compilation and execution relate is key in mastering scope.</p><p>In classic compiler theory, a program is processed by a compiler in three basic stages:</p><ol><li><p><strong>Tokenizing/Lexing:</strong> breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: <code>var a = 2;</code>. This program would likely be broken up into the following tokens: <code>var</code>, <code>a</code>, <code>=</code>, <code>2</code>, and <code>;</code>. Whitespace may or may not be persisted as a token, depending on whether it's meaningful or not.</p><p>(The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a <em>stateless</em> or <em>stateful</em> way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether <code>a</code> should be considered a distinct token or just part of another token, <em>that</em> would be <strong>lexing</strong>.)</p></li><li><p><strong>Parsing:</strong> taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This is called an Abstract Syntax Tree (AST).</p><p>For example, the tree for <code>var a = 2;</code> might start with a top-level node called <code>VariableDeclaration</code>, with a child node called <code>Identifier</code> (whose value is <code>a</code>), and another child called <code>AssignmentExpression</code> which itself has a child called <code>NumericLiteral</code> (whose value is <code>2</code>).</p></li><li><p><strong>Code Generation:</strong> taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it's targeting, and other factors.</p><p>The JS engine takes the just described AST for <code>var a = 2;</code> and turns it into a set of machine instructions to actually <em>create</em> a variable called <code>a</code> (including reserving memory, etc.), and then store a value into <code>a</code>.</p></li></ol><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The implementation details of a JS engine (utilizing system memory resources, etc.) is much deeper than we will dig here. We'll keep our focus on the observable behavior of our programs and let the JS engine manage those deeper system-level abstractions.</p></td></tr></tbody></table><p>The JS engine is vastly more complex than <em>just</em> these three stages. In the process of parsing and code generation, there are steps to optimize the performance of the execution (i.e., collapsing redundant elements). In fact, code can even be re-compiled and re-optimized during the progression of execution.</p><p>So, I'm painting only with broad strokes here. But you'll see shortly why <em>these</em> details we <em>do</em> cover, even at a high level, are relevant.</p><p>JS engines don't have the luxury of an abundance of time to perform their work and optimizations, because JS compilation doesn't happen in a build step ahead of time, as with other languages. It usually must happen in mere microseconds (or less!) right before the code is executed. To ensure the fastest performance under these constraints, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile); these are well beyond the \"scope\" of our discussion here.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Compiling Code", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But first, why does it even matter whether JS is compiled or not?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Scope is primarily determined during compilation, so understanding how compilation and execution relate is key in mastering scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In classic compiler theory, a program is processed by a compiler in three basic stages:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Tokenizing/Lexing:", "type": "text", "marks": [{"type": "bold"}]}, {"text": " breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: ", "type": "text"}, {"text": "var a = 2;", "type": "text", "marks": [{"type": "code"}]}, {"text": ". This program would likely be broken up into the following tokens: ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "a", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "2", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": ";", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Whitespace may or may not be persisted as a token, depending on whether it's meaningful or not.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "(The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a ", "type": "text"}, {"text": "stateless", "type": "text", "marks": [{"type": "italic"}]}, {"text": " or ", "type": "text"}, {"text": "stateful", "type": "text", "marks": [{"type": "italic"}]}, {"text": " way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether ", "type": "text"}, {"text": "a", "type": "text", "marks": [{"type": "code"}]}, {"text": " should be considered a distinct token or just part of another token, ", "type": "text"}, {"text": "that", "type": "text", "marks": [{"type": "italic"}]}, {"text": " would be ", "type": "text"}, {"text": "lexing", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Parsing:", "type": "text", "marks": [{"type": "bold"}]}, {"text": " taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This is called an Abstract Syntax Tree (AST).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, the tree for ", "type": "text"}, {"text": "var a = 2;", "type": "text", "marks": [{"type": "code"}]}, {"text": " might start with a top-level node called ", "type": "text"}, {"text": "VariableDeclaration", "type": "text", "marks": [{"type": "code"}]}, {"text": ", with a child node called ", "type": "text"}, {"text": "Identifier", "type": "text", "marks": [{"type": "code"}]}, {"text": " (whose value is ", "type": "text"}, {"text": "a", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and another child called ", "type": "text"}, {"text": "AssignmentExpression", "type": "text", "marks": [{"type": "code"}]}, {"text": " which itself has a child called ", "type": "text"}, {"text": "NumericLiteral", "type": "text", "marks": [{"type": "code"}]}, {"text": " (whose value is ", "type": "text"}, {"text": "2", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Code Generation:", "type": "text", "marks": [{"type": "bold"}]}, {"text": " taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it's targeting, and other factors.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The JS engine takes the just described AST for ", "type": "text"}, {"text": "var a = 2;", "type": "text", "marks": [{"type": "code"}]}, {"text": " and turns it into a set of machine instructions to actually ", "type": "text"}, {"text": "create", "type": "text", "marks": [{"type": "italic"}]}, {"text": " a variable called ", "type": "text"}, {"text": "a", "type": "text", "marks": [{"type": "code"}]}, {"text": " (including reserving memory, etc.), and then store a value into ", "type": "text"}, {"text": "a", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The implementation details of a JS engine (utilizing system memory resources, etc.) is much deeper than we will dig here. We'll keep our focus on the observable behavior of our programs and let the JS engine manage those deeper system-level abstractions.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "The JS engine is vastly more complex than ", "type": "text"}, {"text": "just", "type": "text", "marks": [{"type": "italic"}]}, {"text": " these three stages. In the process of parsing and code generation, there are steps to optimize the performance of the execution (i.e., collapsing redundant elements). In fact, code can even be re-compiled and re-optimized during the progression of execution.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So, I'm painting only with broad strokes here. But you'll see shortly why ", "type": "text"}, {"text": "these", "type": "text", "marks": [{"type": "italic"}]}, {"text": " details we ", "type": "text"}, {"text": "do", "type": "text", "marks": [{"type": "italic"}]}, {"text": " cover, even at a high level, are relevant.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS engines don't have the luxury of an abundance of time to perform their work and optimizations, because JS compilation doesn't happen in a build step ahead of time, as with other languages. It usually must happen in mere microseconds (or less!) right before the code is executed. To ensure the fastest performance under these constraints, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile); these are well beyond the \"scope\" of our discussion here.", "type": "text"}]}]}, "article_text": "Compiling Code\n\nBut first, why does it even matter whether JS is compiled or not?\n\nScope is primarily determined during compilation, so understanding how compilation and execution relate is key in mastering scope.\n\nIn classic compiler theory, a program is processed by a compiler in three basic stages:\n\nTokenizing/Lexing: breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: var a = 2;. This program would likely be broken up into the following tokens: var, a, =, 2, and ;. Whitespace may or may not be persisted as a token, depending on whether it's meaningful or not.\n\n(The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a stateless or stateful way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether a should be considered a distinct token or just part of another token, that would be lexing.)\n\nParsing: taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This is called an Abstract Syntax Tree (AST).\n\nFor example, the tree for var a = 2; might start with a top-level node called VariableDeclaration, with a child node called Identifier (whose value is a), and another child called AssignmentExpression which itself has a child called NumericLiteral (whose value is 2).\n\nCode Generation: taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it's targeting, and other factors.\n\nThe JS engine takes the just described AST for var a = 2; and turns it into a set of machine instructions to actually create a variable called a (including reserving memory, etc.), and then store a value into a.\n\nNOTE:\n\nThe implementation details of a JS engine (utilizing system memory resources, etc.) is much deeper than we will dig here. We'll keep our focus on the observable behavior of our programs and let the JS engine manage those deeper system-level abstractions.\n\nThe JS engine is vastly more complex than just these three stages. In the process of parsing and code generation, there are steps to optimize the performance of the execution (i.e., collapsing redundant elements). In fact, code can even be re-compiled and re-optimized during the progression of execution.\n\nSo, I'm painting only with broad strokes here. But you'll see shortly why these details we do cover, even at a high level, are relevant.\n\nJS engines don't have the luxury of an abundance of time to perform their work and optimizations, because JS compilation doesn't happen in a build step ahead of time, as with other languages. It usually must happen in mere microseconds (or less!) right before the code is executed. To ensure the fastest performance under these constraints, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile); these are well beyond the \"scope\" of our discussion here."}, "id": 165, "children": [{"data": {"uuid": "51795147-6027-4c5f-a6ab-ff1bb9541e40", "user": 1, "title": "Required: Two Phases", "author": "Kyle Simpson", "created_on": "2023-06-09 00:33:06.793427+00:00", "updated_on": "2023-06-09 00:34:14.003959+00:00", "article_html": "<h3>Required: Two Phases</h3><p>To state it as simply as possible, the most important observation we can make about processing of JS programs is that it occurs in (at least) two phases: parsing/compilation first, then execution.</p><p>The separation of a parsing/compilation phase from the subsequent execution phase is observable fact, not theory or opinion. While the JS specification does not require \"compilation\" explicitly, it requires behavior that is essentially only practical with a compile-then-execute approach.</p><p>There are three program characteristics you can observe to prove this to yourself: syntax errors, early errors, and hoisting.</p><h4>Syntax Errors from the Start</h4><p>Consider this program:</p><pre><code>var greeting = \"Hello\";\n\nconsole.log(greeting);\n\ngreeting = .\"Hi\";\n// SyntaxError: unexpected token .</code></pre><p>This program produces no output (<code>\"Hello\"</code> is not printed), but instead throws a <code>SyntaxError</code> about the unexpected <code>.</code> token right before the <code>\"Hi\"</code> string. Since the syntax error happens after the well-formed <code>console.log(..)</code> statement, if JS was executing top-down line by line, one would expect the <code>\"Hello\"</code> message being printed before the syntax error being thrown. That doesn't happen.</p><p>In fact, the only way the JS engine could know about the syntax error on the third line, before executing the first and second lines, is by the JS engine first parsing the entire program before any of it is executed.</p><h4>Early Errors</h4><p>Next, consider:</p><pre><code>console.log(\"Howdy\");\n\nsaySomething(\"Hello\",\"Hi\");\n// Uncaught SyntaxError: Duplicate parameter name not\n// allowed in this context\n\nfunction saySomething(greeting,greeting) {\n    \"use strict\";\n    console.log(greeting);\n}</code></pre><p>The <code>\"Howdy\"</code> message is not printed, despite being a well-formed statement.</p><p>Instead, just like the snippet in the previous section, the <code>SyntaxError</code> here is thrown before the program is executed. In this case, it's because strict-mode (opted in for only the <code>saySomething(..)</code> function here) forbids, among many other things, functions to have duplicate parameter names; this has always been allowed in non-strict-mode.</p><p>The error thrown is not a syntax error in the sense of being a malformed string of tokens (like <code>.\"Hi\"</code> prior), but in strict-mode is nonetheless required by the specification to be thrown as an \"early error\" before any execution begins.</p><p>But how does the JS engine know that the <code>greeting</code> parameter has been duplicated? How does it know that the <code>saySomething(..)</code> function is even in strict-mode while processing the parameter list (the <code>\"use strict\"</code> pragma appears only later, in the function body)?</p><p>Again, the only reasonable explanation is that the code must first be <em>fully</em> parsed before any execution occurs.</p><h4>Hoisting</h4><p>Finally, consider:</p><pre><code>function saySomething() {\n    var greeting = \"Hello\";\n    {\n        greeting = \"Howdy\";  // error comes from here\n        let greeting = \"Hi\";\n        console.log(greeting);\n    }\n}\n\nsaySomething();\n// ReferenceError: Cannot access 'greeting' before\n// initialization</code></pre><p>The noted <code>ReferenceError</code> occurs from the line with the statement <code>greeting = \"Howdy\"</code>. What's happening is that the <code>greeting</code> variable for that statement belongs to the declaration on the next line, <code>let greeting = \"Hi\"</code>, rather than to the previous <code>var greeting = \"Hello\"</code> statement.</p><p>The only way the JS engine could know, at the line where the error is thrown, that the <em>next statement</em> would declare a block-scoped variable of the same name (<code>greeting</code>) is if the JS engine had already processed this code in an earlier pass, and already set up all the scopes and their variable associations. This processing of scopes and declarations can only accurately be accomplished by parsing the program before execution.</p><p>The <code>ReferenceError</code> here technically comes from <code>greeting = \"Howdy\"</code> accessing the <code>greeting</code> variable <strong>too early</strong>, a conflict referred to as the Temporal Dead Zone (TDZ). Chapter 5 will cover this in more detail.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>It's often asserted that <code>let</code> and <code>const</code> declarations are not hoisted, as an explanation of the TDZ behavior just illustrated. But this is not accurate. We'll come back and explain both the hoisting and TDZ of <code>let</code>/<code>const</code> in Chapter 5.</p></td></tr></tbody></table><p>Hopefully you're now convinced that JS programs are parsed before any execution begins. But does it prove they are compiled?</p><p>This is an interesting question to ponder. Could JS parse a program, but then execute that program by <em>interpreting</em> operations represented in the AST <strong>without</strong> first compiling the program? Yes, that is <em>possible</em>. But it's extremely unlikely, mostly because it would be extremely inefficient performance wise.</p><p>It's hard to imagine a production-quality JS engine going to all the trouble of parsing a program into an AST, but not then converting (aka, \"compiling\") that AST into the most efficient (binary) representation for the engine to then execute.</p><p>Many have endeavored to split hairs with this terminology, as there's plenty of nuance and \"well, actually...\" interjections floating around. But in spirit and in practice, what the engine is doing in processing JS programs is <strong>much more alike compilation</strong> than not.</p><p>Classifying JS as a compiled language is not concerned with the distribution model for its binary (or byte-code) executable representations, but rather in keeping a clear distinction in our minds about the phase where JS code is processed and analyzed; this phase observably and indisputedly happens <em>before</em> the code starts to be executed.</p><p>We need proper mental models of how the JS engine treats our code if we want to understand JS and scope effectively.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Required: Two Phases", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To state it as simply as possible, the most important observation we can make about processing of JS programs is that it occurs in (at least) two phases: parsing/compilation first, then execution.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The separation of a parsing/compilation phase from the subsequent execution phase is observable fact, not theory or opinion. While the JS specification does not require \"compilation\" explicitly, it requires behavior that is essentially only practical with a compile-then-execute approach.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are three program characteristics you can observe to prove this to yourself: syntax errors, early errors, and hoisting.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Syntax Errors from the Start", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider this program:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var greeting = \"Hello\";\n\nconsole.log(greeting);\n\ngreeting = .\"Hi\";\n// SyntaxError: unexpected token .", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This program produces no output (", "type": "text"}, {"text": "\"Hello\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not printed), but instead throws a ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": " about the unexpected ", "type": "text"}, {"text": ".", "type": "text", "marks": [{"type": "code"}]}, {"text": " token right before the ", "type": "text"}, {"text": "\"Hi\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " string. Since the syntax error happens after the well-formed ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement, if JS was executing top-down line by line, one would expect the ", "type": "text"}, {"text": "\"Hello\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " message being printed before the syntax error being thrown. That doesn't happen.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In fact, the only way the JS engine could know about the syntax error on the third line, before executing the first and second lines, is by the JS engine first parsing the entire program before any of it is executed.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Early Errors", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Next, consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "console.log(\"Howdy\");\n\nsaySomething(\"Hello\",\"Hi\");\n// Uncaught SyntaxError: Duplicate parameter name not\n// allowed in this context\n\nfunction saySomething(greeting,greeting) {\n    \"use strict\";\n    console.log(greeting);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "\"Howdy\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " message is not printed, despite being a well-formed statement.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Instead, just like the snippet in the previous section, the ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": " here is thrown before the program is executed. In this case, it's because strict-mode (opted in for only the ", "type": "text"}, {"text": "saySomething(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function here) forbids, among many other things, functions to have duplicate parameter names; this has always been allowed in non-strict-mode.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The error thrown is not a syntax error in the sense of being a malformed string of tokens (like ", "type": "text"}, {"text": ".\"Hi\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " prior), but in strict-mode is nonetheless required by the specification to be thrown as an \"early error\" before any execution begins.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But how does the JS engine know that the ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter has been duplicated? How does it know that the ", "type": "text"}, {"text": "saySomething(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is even in strict-mode while processing the parameter list (the ", "type": "text"}, {"text": "\"use strict\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " pragma appears only later, in the function body)?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Again, the only reasonable explanation is that the code must first be ", "type": "text"}, {"text": "fully", "type": "text", "marks": [{"type": "italic"}]}, {"text": " parsed before any execution occurs.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Hoisting", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Finally, consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function saySomething() {\n    var greeting = \"Hello\";\n    {\n        greeting = \"Howdy\";  // error comes from here\n        let greeting = \"Hi\";\n        console.log(greeting);\n    }\n}\n\nsaySomething();\n// ReferenceError: Cannot access 'greeting' before\n// initialization", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The noted ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " occurs from the line with the statement ", "type": "text"}, {"text": "greeting = \"Howdy\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ". What's happening is that the ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable for that statement belongs to the declaration on the next line, ", "type": "text"}, {"text": "let greeting = \"Hi\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", rather than to the previous ", "type": "text"}, {"text": "var greeting = \"Hello\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The only way the JS engine could know, at the line where the error is thrown, that the ", "type": "text"}, {"text": "next statement", "type": "text", "marks": [{"type": "italic"}]}, {"text": " would declare a block-scoped variable of the same name (", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": ") is if the JS engine had already processed this code in an earlier pass, and already set up all the scopes and their variable associations. This processing of scopes and declarations can only accurately be accomplished by parsing the program before execution.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " here technically comes from ", "type": "text"}, {"text": "greeting = \"Howdy\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " accessing the ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable ", "type": "text"}, {"text": "too early", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", a conflict referred to as the Temporal Dead Zone (TDZ). Chapter 5 will cover this in more detail.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "It's often asserted that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations are not hoisted, as an explanation of the TDZ behavior just illustrated. But this is not accurate. We'll come back and explain both the hoisting and TDZ of ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " in Chapter 5.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Hopefully you're now convinced that JS programs are parsed before any execution begins. But does it prove they are compiled?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is an interesting question to ponder. Could JS parse a program, but then execute that program by ", "type": "text"}, {"text": "interpreting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " operations represented in the AST ", "type": "text"}, {"text": "without", "type": "text", "marks": [{"type": "bold"}]}, {"text": " first compiling the program? Yes, that is ", "type": "text"}, {"text": "possible", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". But it's extremely unlikely, mostly because it would be extremely inefficient performance wise.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's hard to imagine a production-quality JS engine going to all the trouble of parsing a program into an AST, but not then converting (aka, \"compiling\") that AST into the most efficient (binary) representation for the engine to then execute.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Many have endeavored to split hairs with this terminology, as there's plenty of nuance and \"well, actually...\" interjections floating around. But in spirit and in practice, what the engine is doing in processing JS programs is ", "type": "text"}, {"text": "much more alike compilation", "type": "text", "marks": [{"type": "bold"}]}, {"text": " than not.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Classifying JS as a compiled language is not concerned with the distribution model for its binary (or byte-code) executable representations, but rather in keeping a clear distinction in our minds about the phase where JS code is processed and analyzed; this phase observably and indisputedly happens ", "type": "text"}, {"text": "before", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the code starts to be executed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We need proper mental models of how the JS engine treats our code if we want to understand JS and scope effectively.", "type": "text"}]}]}, "article_text": "Required: Two Phases\n\nTo state it as simply as possible, the most important observation we can make about processing of JS programs is that it occurs in (at least) two phases: parsing/compilation first, then execution.\n\nThe separation of a parsing/compilation phase from the subsequent execution phase is observable fact, not theory or opinion. While the JS specification does not require \"compilation\" explicitly, it requires behavior that is essentially only practical with a compile-then-execute approach.\n\nThere are three program characteristics you can observe to prove this to yourself: syntax errors, early errors, and hoisting.\n\nSyntax Errors from the Start\n\nConsider this program:\n\nvar greeting = \"Hello\";\n\nconsole.log(greeting);\n\ngreeting = .\"Hi\";\n// SyntaxError: unexpected token .\n\nThis program produces no output (\"Hello\" is not printed), but instead throws a SyntaxError about the unexpected . token right before the \"Hi\" string. Since the syntax error happens after the well-formed console.log(..) statement, if JS was executing top-down line by line, one would expect the \"Hello\" message being printed before the syntax error being thrown. That doesn't happen.\n\nIn fact, the only way the JS engine could know about the syntax error on the third line, before executing the first and second lines, is by the JS engine first parsing the entire program before any of it is executed.\n\nEarly Errors\n\nNext, consider:\n\nconsole.log(\"Howdy\");\n\nsaySomething(\"Hello\",\"Hi\");\n// Uncaught SyntaxError: Duplicate parameter name not\n// allowed in this context\n\nfunction saySomething(greeting,greeting) {\n    \"use strict\";\n    console.log(greeting);\n}\n\nThe \"Howdy\" message is not printed, despite being a well-formed statement.\n\nInstead, just like the snippet in the previous section, the SyntaxError here is thrown before the program is executed. In this case, it's because strict-mode (opted in for only the saySomething(..) function here) forbids, among many other things, functions to have duplicate parameter names; this has always been allowed in non-strict-mode.\n\nThe error thrown is not a syntax error in the sense of being a malformed string of tokens (like .\"Hi\" prior), but in strict-mode is nonetheless required by the specification to be thrown as an \"early error\" before any execution begins.\n\nBut how does the JS engine know that the greeting parameter has been duplicated? How does it know that the saySomething(..) function is even in strict-mode while processing the parameter list (the \"use strict\" pragma appears only later, in the function body)?\n\nAgain, the only reasonable explanation is that the code must first be fully parsed before any execution occurs.\n\nHoisting\n\nFinally, consider:\n\nfunction saySomething() {\n    var greeting = \"Hello\";\n    {\n        greeting = \"Howdy\";  // error comes from here\n        let greeting = \"Hi\";\n        console.log(greeting);\n    }\n}\n\nsaySomething();\n// ReferenceError: Cannot access 'greeting' before\n// initialization\n\nThe noted ReferenceError occurs from the line with the statement greeting = \"Howdy\". What's happening is that the greeting variable for that statement belongs to the declaration on the next line, let greeting = \"Hi\", rather than to the previous var greeting = \"Hello\" statement.\n\nThe only way the JS engine could know, at the line where the error is thrown, that the next statement would declare a block-scoped variable of the same name (greeting) is if the JS engine had already processed this code in an earlier pass, and already set up all the scopes and their variable associations. This processing of scopes and declarations can only accurately be accomplished by parsing the program before execution.\n\nThe ReferenceError here technically comes from greeting = \"Howdy\" accessing the greeting variable too early, a conflict referred to as the Temporal Dead Zone (TDZ). Chapter 5 will cover this in more detail.\n\nWARNING:\n\nIt's often asserted that let and const declarations are not hoisted, as an explanation of the TDZ behavior just illustrated. But this is not accurate. We'll come back and explain both the hoisting and TDZ of let/const in Chapter 5.\n\nHopefully you're now convinced that JS programs are parsed before any execution begins. But does it prove they are compiled?\n\nThis is an interesting question to ponder. Could JS parse a program, but then execute that program by interpreting operations represented in the AST without first compiling the program? Yes, that is possible. But it's extremely unlikely, mostly because it would be extremely inefficient performance wise.\n\nIt's hard to imagine a production-quality JS engine going to all the trouble of parsing a program into an AST, but not then converting (aka, \"compiling\") that AST into the most efficient (binary) representation for the engine to then execute.\n\nMany have endeavored to split hairs with this terminology, as there's plenty of nuance and \"well, actually...\" interjections floating around. But in spirit and in practice, what the engine is doing in processing JS programs is much more alike compilation than not.\n\nClassifying JS as a compiled language is not concerned with the distribution model for its binary (or byte-code) executable representations, but rather in keeping a clear distinction in our minds about the phase where JS code is processed and analyzed; this phase observably and indisputedly happens before the code starts to be executed.\n\nWe need proper mental models of how the JS engine treats our code if we want to understand JS and scope effectively."}, "id": 166}]}, {"data": {"uuid": "f97bd709-e392-493f-a106-4f860a999910", "user": 1, "title": "Compiler Speak", "author": "Kyle Simpson", "created_on": "2023-06-09 00:34:39.488375+00:00", "updated_on": "2023-06-09 00:35:19.133927+00:00", "article_html": "<h2>Compiler Speak</h2><p>With awareness of the two-phase processing of a JS program (compile, then execute), let's turn our attention to how the JS engine identifies variables and determines the scopes of a program as it is compiled.</p><p>First, let's examine a simple JS program to use for analysis over the next several chapters:</p><pre><code>var students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    for (let student of students) {\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\n\nconsole.log(nextStudent);\n// Suzy</code></pre><p>Other than declarations, all occurrences of variables/identifiers in a program serve in one of two \"roles\": either they're the <em>target</em> of an assignment or they're the <em>source</em> of a value.</p><p>(When I first learned compiler theory while earning my computer science degree, we were taught the terms \"LHS\" (aka, <em>target</em>) and \"RHS\" (aka, <em>source</em>) for these roles, respectively. As you might guess from the \"L\" and the \"R\", the acronyms mean \"Left-Hand Side\" and \"Right-Hand Side\", as in left and right sides of an <code>=</code> assignment operator. However, assignment targets and sources don't always literally appear on the left or right of an <code>=</code>, so it's probably clearer to think in terms of <em>target</em> / <em>source</em> rather than <em>left</em> / <em>right</em>.)</p><p>How do you know if a variable is a <em>target</em>? Check if there is a value that is being assigned to it; if so, it's a <em>target</em>. If not, then the variable is a <em>source</em>.</p><p>For the JS engine to properly handle a program's variables, it must first label each occurrence of a variable as <em>target</em> or <em>source</em>. We'll dig in now to how each role is determined.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Compiler Speak", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With awareness of the two-phase processing of a JS program (compile, then execute), let's turn our attention to how the JS engine identifies variables and determines the scopes of a program as it is compiled.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First, let's examine a simple JS program to use for analysis over the next several chapters:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    for (let student of students) {\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\n\nconsole.log(nextStudent);\n// Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Other than declarations, all occurrences of variables/identifiers in a program serve in one of two \"roles\": either they're the ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of an assignment or they're the ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of a value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "(When I first learned compiler theory while earning my computer science degree, we were taught the terms \"LHS\" (aka, ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": ") and \"RHS\" (aka, ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": ") for these roles, respectively. As you might guess from the \"L\" and the \"R\", the acronyms mean \"Left-Hand Side\" and \"Right-Hand Side\", as in left and right sides of an ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": " assignment operator. However, assignment targets and sources don't always literally appear on the left or right of an ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so it's probably clearer to think in terms of ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " / ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " rather than ", "type": "text"}, {"text": "left", "type": "text", "marks": [{"type": "italic"}]}, {"text": " / ", "type": "text"}, {"text": "right", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "How do you know if a variable is a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? Check if there is a value that is being assigned to it; if so, it's a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". If not, then the variable is a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For the JS engine to properly handle a program's variables, it must first label each occurrence of a variable as ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " or ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". We'll dig in now to how each role is determined.", "type": "text"}]}]}, "article_text": "Compiler Speak\n\nWith awareness of the two-phase processing of a JS program (compile, then execute), let's turn our attention to how the JS engine identifies variables and determines the scopes of a program as it is compiled.\n\nFirst, let's examine a simple JS program to use for analysis over the next several chapters:\n\nvar students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    for (let student of students) {\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\n\nconsole.log(nextStudent);\n// Suzy\n\nOther than declarations, all occurrences of variables/identifiers in a program serve in one of two \"roles\": either they're the target of an assignment or they're the source of a value.\n\n(When I first learned compiler theory while earning my computer science degree, we were taught the terms \"LHS\" (aka, target) and \"RHS\" (aka, source) for these roles, respectively. As you might guess from the \"L\" and the \"R\", the acronyms mean \"Left-Hand Side\" and \"Right-Hand Side\", as in left and right sides of an = assignment operator. However, assignment targets and sources don't always literally appear on the left or right of an =, so it's probably clearer to think in terms of target / source rather than left / right.)\n\nHow do you know if a variable is a target? Check if there is a value that is being assigned to it; if so, it's a target. If not, then the variable is a source.\n\nFor the JS engine to properly handle a program's variables, it must first label each occurrence of a variable as target or source. We'll dig in now to how each role is determined."}, "id": 167, "children": [{"data": {"uuid": "dd6125ee-2ac7-412b-a711-e48ffd029d42", "user": 1, "title": "Targets", "author": "Kyle Simpson", "created_on": "2023-06-09 00:35:40.034109+00:00", "updated_on": "2023-06-09 00:36:15.151806+00:00", "article_html": "<h3>Targets</h3><p>What makes a variable a <em>target</em>? Consider:</p><pre><code>students = [ // ..</code></pre><p>This statement is clearly an assignment operation; remember, the <code>var students</code> part is handled entirely as a declaration at compile time, and is thus irrelevant during execution; we left it out for clarity and focus. Same with the <code>nextStudent = getStudentName(73)</code> statement.</p><p>But there are three other <em>target</em> assignment operations in the code that are perhaps less obvious. One of them:</p><pre><code>for (let student of students) {</code></pre><p>That statement assigns a value to <code>student</code> for each iteration of the loop. Another <em>target</em> reference:</p><pre><code>getStudentName(73)</code></pre><p>But how is that an assignment to a <em>target</em>? Look closely: the argument <code>73</code> is assigned to the parameter <code>studentID</code>.</p><p>And there's one last (subtle) <em>target</em> reference in our program. Can you spot it?</p><p>..</p><p>..</p><p>..</p><p>Did you identify this one?</p><pre><code>function getStudentName(studentID) {</code></pre><p>A <code>function</code> declaration is a special case of a <em>target</em> reference. You can think of it sort of like <code>var getStudentName = function(studentID)</code>, but that's not exactly accurate. An identifier <code>getStudentName</code> is declared (at compile time), but the <code>= function(studentID)</code> part is also handled at compilation; the association between <code>getStudentName</code> and the function is automatically set up at the beginning of the scope rather than waiting for an <code>=</code> assignment statement to be executed.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>This automatic association of function and variable is referred to as \"function hoisting\", and is covered in detail in Chapter 5.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Targets", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What makes a variable a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "students = [ // ..", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This statement is clearly an assignment operation; remember, the ", "type": "text"}, {"text": "var students", "type": "text", "marks": [{"type": "code"}]}, {"text": " part is handled entirely as a declaration at compile time, and is thus irrelevant during execution; we left it out for clarity and focus. Same with the ", "type": "text"}, {"text": "nextStudent = getStudentName(73)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But there are three other ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " assignment operations in the code that are perhaps less obvious. One of them:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (let student of students) {", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That statement assigns a value to ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " for each iteration of the loop. Another ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "getStudentName(73)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But how is that an assignment to a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? Look closely: the argument ", "type": "text"}, {"text": "73", "type": "text", "marks": [{"type": "code"}]}, {"text": " is assigned to the parameter ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And there's one last (subtle) ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference in our program. Can you spot it?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "..", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "..", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "..", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Did you identify this one?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudentName(studentID) {", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration is a special case of a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference. You can think of it sort of like ", "type": "text"}, {"text": "var getStudentName = function(studentID)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but that's not exactly accurate. An identifier ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is declared (at compile time), but the ", "type": "text"}, {"text": "= function(studentID)", "type": "text", "marks": [{"type": "code"}]}, {"text": " part is also handled at compilation; the association between ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " and the function is automatically set up at the beginning of the scope rather than waiting for an ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": " assignment statement to be executed.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "This automatic association of function and variable is referred to as \"function hoisting\", and is covered in detail in Chapter 5.", "type": "text"}]}]}]}]}]}, "article_text": "Targets\n\nWhat makes a variable a target? Consider:\n\nstudents = [ // ..\n\nThis statement is clearly an assignment operation; remember, the var students part is handled entirely as a declaration at compile time, and is thus irrelevant during execution; we left it out for clarity and focus. Same with the nextStudent = getStudentName(73) statement.\n\nBut there are three other target assignment operations in the code that are perhaps less obvious. One of them:\n\nfor (let student of students) {\n\nThat statement assigns a value to student for each iteration of the loop. Another target reference:\n\ngetStudentName(73)\n\nBut how is that an assignment to a target? Look closely: the argument 73 is assigned to the parameter studentID.\n\nAnd there's one last (subtle) target reference in our program. Can you spot it?\n\n..\n\n..\n\n..\n\nDid you identify this one?\n\nfunction getStudentName(studentID) {\n\nA function declaration is a special case of a target reference. You can think of it sort of like var getStudentName = function(studentID), but that's not exactly accurate. An identifier getStudentName is declared (at compile time), but the = function(studentID) part is also handled at compilation; the association between getStudentName and the function is automatically set up at the beginning of the scope rather than waiting for an = assignment statement to be executed.\n\nNOTE:\n\nThis automatic association of function and variable is referred to as \"function hoisting\", and is covered in detail in Chapter 5."}, "id": 168}, {"data": {"uuid": "ebc83421-25b9-4597-80cd-2d365eeef085", "user": 1, "title": "Sources", "author": "Kyle Simpson", "created_on": "2023-06-09 00:36:35.832997+00:00", "updated_on": "2023-06-09 00:36:53.787247+00:00", "article_html": "<h3>Sources</h3><p>So we've identified all five <em>target</em> references in the program. The other variable references must then be <em>source</em> references (because that's the only other option!).</p><p>In <code>for (let student of students)</code>, we said that <code>student</code> is a <em>target</em>, but <code>students</code> is a <em>source</em> reference. In the statement <code>if (student.id == studentID)</code>, both <code>student</code> and <code>studentID</code> are <em>source</em> references. <code>student</code> is also a <em>source</em> reference in <code>return student.name</code>.</p><p>In <code>getStudentName(73)</code>, <code>getStudentName</code> is a <em>source</em> reference (which we hope resolves to a function reference value). In <code>console.log(nextStudent)</code>, <code>console</code> is a <em>source</em> reference, as is <code>nextStudent</code>.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>In case you were wondering, <code>id</code>, <code>name</code>, and <code>log</code> are all properties, not variable references.</p></td></tr></tbody></table><p>What's the practical importance of understanding <em>targets</em> vs. <em>sources</em>? In Chapter 2, we'll revisit this topic and cover how a variable's role impacts its lookup (specifically, if the lookup fails).</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Sources", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So we've identified all five ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " references in the program. The other variable references must then be ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " references (because that's the only other option!).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In ", "type": "text"}, {"text": "for (let student of students)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we said that ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", but ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference. In the statement ", "type": "text"}, {"text": "if (student.id == studentID)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", both ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " are ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " references. ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " is also a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference in ", "type": "text"}, {"text": "return student.name", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In ", "type": "text"}, {"text": "getStudentName(73)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference (which we hope resolves to a function reference value). In ", "type": "text"}, {"text": "console.log(nextStudent)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "console", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference, as is ", "type": "text"}, {"text": "nextStudent", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "In case you were wondering, ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "log", "type": "text", "marks": [{"type": "code"}]}, {"text": " are all properties, not variable references.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "What's the practical importance of understanding ", "type": "text"}, {"text": "targets", "type": "text", "marks": [{"type": "italic"}]}, {"text": " vs. ", "type": "text"}, {"text": "sources", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? In Chapter 2, we'll revisit this topic and cover how a variable's role impacts its lookup (specifically, if the lookup fails).", "type": "text"}]}]}, "article_text": "Sources\n\nSo we've identified all five target references in the program. The other variable references must then be source references (because that's the only other option!).\n\nIn for (let student of students), we said that student is a target, but students is a source reference. In the statement if (student.id == studentID), both student and studentID are source references. student is also a source reference in return student.name.\n\nIn getStudentName(73), getStudentName is a source reference (which we hope resolves to a function reference value). In console.log(nextStudent), console is a source reference, as is nextStudent.\n\nNOTE:\n\nIn case you were wondering, id, name, and log are all properties, not variable references.\n\nWhat's the practical importance of understanding targets vs. sources? In Chapter 2, we'll revisit this topic and cover how a variable's role impacts its lookup (specifically, if the lookup fails)."}, "id": 169}]}, {"data": {"uuid": "2741c400-67f8-40f7-8bb7-fd7ef66e5ab5", "user": 1, "title": "Cheating: Runtime Scope Modifications", "author": "Kyle Simpson", "created_on": "2023-06-09 00:37:27.019783+00:00", "updated_on": "2023-06-09 00:37:43.700174+00:00", "article_html": "<h2>Cheating: Runtime Scope Modifications</h2><p>It should be clear by now that scope is determined as the program is compiled, and should not generally be affected by runtime conditions. However, in non-strict-mode, there are technically still two ways to cheat this rule, modifying a program's scopes during runtime.</p><p>Neither of these techniques <em>should</em> be used\u2014they're both dangerous and confusing, and you should be using strict-mode (where they're disallowed) anyway. But it's important to be aware of them in case you run across them in some programs.</p><p>The <code>eval(..)</code> function receives a string of code to compile and execute on the fly during the program runtime. If that string of code has a <code>var</code> or <code>function</code> declaration in it, those declarations will modify the current scope that the <code>eval(..)</code> is currently executing in:</p><pre><code>function badIdea() {\n    eval(\"var oops = 'Ugh!';\");\n    console.log(oops);\n}\nbadIdea();   // Ugh!</code></pre><p>If the <code>eval(..)</code> had not been present, the <code>oops</code> variable in <code>console.log(oops)</code> would not exist, and would throw a <code>ReferenceError</code>. But <code>eval(..)</code> modifies the scope of the <code>badIdea()</code> function at runtime. This is bad for many reasons, including the performance hit of modifying the already compiled and optimized scope, every time <code>badIdea()</code> runs.</p><p>The second cheat is the <code>with</code> keyword, which essentially dynamically turns an object into a local scope\u2014its properties are treated as identifiers in that new scope's block:</p><pre><code>var badIdea = { oops: \"Ugh!\" };\n\nwith (badIdea) {\n    console.log(oops);   // Ugh!\n}</code></pre><p>The global scope was not modified here, but <code>badIdea</code> was turned into a scope at runtime rather than compile time, and its property <code>oops</code> becomes a variable in that scope. Again, this is a terrible idea, for performance and readability reasons.</p><p>At all costs, avoid <code>eval(..)</code> (at least, <code>eval(..)</code> creating declarations) and <code>with</code>. Again, neither of these cheats is available in strict-mode, so if you just use strict-mode (you should!) then the temptation goes away!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Cheating: Runtime Scope Modifications", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It should be clear by now that scope is determined as the program is compiled, and should not generally be affected by runtime conditions. However, in non-strict-mode, there are technically still two ways to cheat this rule, modifying a program's scopes during runtime.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Neither of these techniques ", "type": "text"}, {"text": "should", "type": "text", "marks": [{"type": "italic"}]}, {"text": " be used\u2014they're both dangerous and confusing, and you should be using strict-mode (where they're disallowed) anyway. But it's important to be aware of them in case you run across them in some programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function receives a string of code to compile and execute on the fly during the program runtime. If that string of code has a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration in it, those declarations will modify the current scope that the ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is currently executing in:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function badIdea() {\n    eval(\"var oops = 'Ugh!';\");\n    console.log(oops);\n}\nbadIdea();   // Ugh!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If the ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " had not been present, the ", "type": "text"}, {"text": "oops", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable in ", "type": "text"}, {"text": "console.log(oops)", "type": "text", "marks": [{"type": "code"}]}, {"text": " would not exist, and would throw a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " modifies the scope of the ", "type": "text"}, {"text": "badIdea()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function at runtime. This is bad for many reasons, including the performance hit of modifying the already compiled and optimized scope, every time ", "type": "text"}, {"text": "badIdea()", "type": "text", "marks": [{"type": "code"}]}, {"text": " runs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The second cheat is the ", "type": "text"}, {"text": "with", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword, which essentially dynamically turns an object into a local scope\u2014its properties are treated as identifiers in that new scope's block:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var badIdea = { oops: \"Ugh!\" };\n\nwith (badIdea) {\n    console.log(oops);   // Ugh!\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The global scope was not modified here, but ", "type": "text"}, {"text": "badIdea", "type": "text", "marks": [{"type": "code"}]}, {"text": " was turned into a scope at runtime rather than compile time, and its property ", "type": "text"}, {"text": "oops", "type": "text", "marks": [{"type": "code"}]}, {"text": " becomes a variable in that scope. Again, this is a terrible idea, for performance and readability reasons.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "At all costs, avoid ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (at least, ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " creating declarations) and ", "type": "text"}, {"text": "with", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Again, neither of these cheats is available in strict-mode, so if you just use strict-mode (you should!) then the temptation goes away!", "type": "text"}]}]}, "article_text": "Cheating: Runtime Scope Modifications\n\nIt should be clear by now that scope is determined as the program is compiled, and should not generally be affected by runtime conditions. However, in non-strict-mode, there are technically still two ways to cheat this rule, modifying a program's scopes during runtime.\n\nNeither of these techniques should be used\u2014they're both dangerous and confusing, and you should be using strict-mode (where they're disallowed) anyway. But it's important to be aware of them in case you run across them in some programs.\n\nThe eval(..) function receives a string of code to compile and execute on the fly during the program runtime. If that string of code has a var or function declaration in it, those declarations will modify the current scope that the eval(..) is currently executing in:\n\nfunction badIdea() {\n    eval(\"var oops = 'Ugh!';\");\n    console.log(oops);\n}\nbadIdea();   // Ugh!\n\nIf the eval(..) had not been present, the oops variable in console.log(oops) would not exist, and would throw a ReferenceError. But eval(..) modifies the scope of the badIdea() function at runtime. This is bad for many reasons, including the performance hit of modifying the already compiled and optimized scope, every time badIdea() runs.\n\nThe second cheat is the with keyword, which essentially dynamically turns an object into a local scope\u2014its properties are treated as identifiers in that new scope's block:\n\nvar badIdea = { oops: \"Ugh!\" };\n\nwith (badIdea) {\n    console.log(oops);   // Ugh!\n}\n\nThe global scope was not modified here, but badIdea was turned into a scope at runtime rather than compile time, and its property oops becomes a variable in that scope. Again, this is a terrible idea, for performance and readability reasons.\n\nAt all costs, avoid eval(..) (at least, eval(..) creating declarations) and with. Again, neither of these cheats is available in strict-mode, so if you just use strict-mode (you should!) then the temptation goes away!"}, "id": 170}, {"data": {"uuid": "106e45b1-6cdc-41fd-9fdf-52d0ceb8f6b8", "user": 1, "title": "Lexical Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 00:37:58.205278+00:00", "updated_on": "2023-06-09 00:38:18.008692+00:00", "article_html": "<h2>Lexical Scope</h2><p>We've demonstrated that JS's scope is determined at compile time; the term for this kind of scope is \"lexical scope\". \"Lexical\" is associated with the \"lexing\" stage of compilation, as discussed earlier in this chapter.</p><p>To narrow this chapter down to a useful conclusion, the key idea of \"lexical scope\" is that it's controlled entirely by the placement of functions, blocks, and variable declarations, in relation to one another.</p><p>If you place a variable declaration inside a function, the compiler handles this declaration as it's parsing the function, and associates that declaration with the function's scope. If a variable is block-scope declared (<code>let</code> / <code>const</code>), then it's associated with the nearest enclosing <code>{ .. }</code> block, rather than its enclosing function (as with <code>var</code>).</p><p>Furthermore, a reference (<em>target</em> or <em>source</em> role) for a variable must be resolved as coming from one of the scopes that are <em>lexically available</em> to it; otherwise the variable is said to be \"undeclared\" (which usually results in an error!). If the variable is not declared in the current scope, the next outer/enclosing scope will be consulted. This process of stepping out one level of scope nesting continues until either a matching variable declaration can be found, or the global scope is reached and there's nowhere else to go.</p><p>It's important to note that compilation doesn't actually <em>do anything</em> in terms of reserving memory for scopes and variables. None of the program has been executed yet.</p><p>Instead, compilation creates a map of all the lexical scopes that lays out what the program will need while it executes. You can think of this plan as inserted code for use at runtime, which defines all the scopes (aka, \"lexical environments\") and registers all the identifiers (variables) for each scope.</p><p>In other words, while scopes are identified during compilation, they're not actually created until runtime, each time a scope needs to run. In the next chapter, we'll sketch out the conceptual foundations for lexical scope.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Lexical Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We've demonstrated that JS's scope is determined at compile time; the term for this kind of scope is \"lexical scope\". \"Lexical\" is associated with the \"lexing\" stage of compilation, as discussed earlier in this chapter.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To narrow this chapter down to a useful conclusion, the key idea of \"lexical scope\" is that it's controlled entirely by the placement of functions, blocks, and variable declarations, in relation to one another.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you place a variable declaration inside a function, the compiler handles this declaration as it's parsing the function, and associates that declaration with the function's scope. If a variable is block-scope declared (", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "), then it's associated with the nearest enclosing ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " block, rather than its enclosing function (as with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Furthermore, a reference (", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " or ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " role) for a variable must be resolved as coming from one of the scopes that are ", "type": "text"}, {"text": "lexically available", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to it; otherwise the variable is said to be \"undeclared\" (which usually results in an error!). If the variable is not declared in the current scope, the next outer/enclosing scope will be consulted. This process of stepping out one level of scope nesting continues until either a matching variable declaration can be found, or the global scope is reached and there's nowhere else to go.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's important to note that compilation doesn't actually ", "type": "text"}, {"text": "do anything", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in terms of reserving memory for scopes and variables. None of the program has been executed yet.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Instead, compilation creates a map of all the lexical scopes that lays out what the program will need while it executes. You can think of this plan as inserted code for use at runtime, which defines all the scopes (aka, \"lexical environments\") and registers all the identifiers (variables) for each scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, while scopes are identified during compilation, they're not actually created until runtime, each time a scope needs to run. In the next chapter, we'll sketch out the conceptual foundations for lexical scope.", "type": "text"}]}]}, "article_text": "Lexical Scope\n\nWe've demonstrated that JS's scope is determined at compile time; the term for this kind of scope is \"lexical scope\". \"Lexical\" is associated with the \"lexing\" stage of compilation, as discussed earlier in this chapter.\n\nTo narrow this chapter down to a useful conclusion, the key idea of \"lexical scope\" is that it's controlled entirely by the placement of functions, blocks, and variable declarations, in relation to one another.\n\nIf you place a variable declaration inside a function, the compiler handles this declaration as it's parsing the function, and associates that declaration with the function's scope. If a variable is block-scope declared (let / const), then it's associated with the nearest enclosing { .. } block, rather than its enclosing function (as with var).\n\nFurthermore, a reference (target or source role) for a variable must be resolved as coming from one of the scopes that are lexically available to it; otherwise the variable is said to be \"undeclared\" (which usually results in an error!). If the variable is not declared in the current scope, the next outer/enclosing scope will be consulted. This process of stepping out one level of scope nesting continues until either a matching variable declaration can be found, or the global scope is reached and there's nowhere else to go.\n\nIt's important to note that compilation doesn't actually do anything in terms of reserving memory for scopes and variables. None of the program has been executed yet.\n\nInstead, compilation creates a map of all the lexical scopes that lays out what the program will need while it executes. You can think of this plan as inserted code for use at runtime, which defines all the scopes (aka, \"lexical environments\") and registers all the identifiers (variables) for each scope.\n\nIn other words, while scopes are identified during compilation, they're not actually created until runtime, each time a scope needs to run. In the next chapter, we'll sketch out the conceptual foundations for lexical scope."}, "id": 171}]}, {"data": {"uuid": "7d91bab1-f8ea-4431-9aa1-f00f5f669280", "user": 1, "title": "Chapter 2: Illustrating Lexical Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 00:44:08.368859+00:00", "updated_on": "2023-06-09 00:45:05.175345+00:00", "article_html": "<h1>Chapter 2: Illustrating Lexical Scope</h1><p>In Chapter 1, we explored how scope is determined during code compilation, a model called \"lexical scope.\" The term \"lexical\" refers to the first stage of compilation (lexing/parsing).</p><p>To properly <em>reason</em> about our programs, it's important to have a solid conceptual foundation of how scope works. If we rely on guesses and intuition, we may accidentally get the right answers some of the time, but many other times we're far off. This isn't a recipe for success.</p><p>Like way back in grade school math class, getting the right answer isn't enough if we don't show the correct steps to get there! We need to build accurate and helpful mental models as foundation moving forward.</p><p>This chapter will illustrate <em>scope</em> with several metaphors. The goal here is to <em>think</em> about how your program is handled by the JS engine in ways that more closely align with how the JS engine actually works.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 2: Illustrating Lexical Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Chapter 1, we explored how scope is determined during code compilation, a model called \"lexical scope.\" The term \"lexical\" refers to the first stage of compilation (lexing/parsing).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To properly ", "type": "text"}, {"text": "reason", "type": "text", "marks": [{"type": "italic"}]}, {"text": " about our programs, it's important to have a solid conceptual foundation of how scope works. If we rely on guesses and intuition, we may accidentally get the right answers some of the time, but many other times we're far off. This isn't a recipe for success.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Like way back in grade school math class, getting the right answer isn't enough if we don't show the correct steps to get there! We need to build accurate and helpful mental models as foundation moving forward.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This chapter will illustrate ", "type": "text"}, {"text": "scope", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with several metaphors. The goal here is to ", "type": "text"}, {"text": "think", "type": "text", "marks": [{"type": "italic"}]}, {"text": " about how your program is handled by the JS engine in ways that more closely align with how the JS engine actually works.", "type": "text"}]}]}, "article_text": "Chapter 2: Illustrating Lexical Scope\n\nIn Chapter 1, we explored how scope is determined during code compilation, a model called \"lexical scope.\" The term \"lexical\" refers to the first stage of compilation (lexing/parsing).\n\nTo properly reason about our programs, it's important to have a solid conceptual foundation of how scope works. If we rely on guesses and intuition, we may accidentally get the right answers some of the time, but many other times we're far off. This isn't a recipe for success.\n\nLike way back in grade school math class, getting the right answer isn't enough if we don't show the correct steps to get there! We need to build accurate and helpful mental models as foundation moving forward.\n\nThis chapter will illustrate scope with several metaphors. The goal here is to think about how your program is handled by the JS engine in ways that more closely align with how the JS engine actually works."}, "id": 175, "children": [{"data": {"uuid": "4bc2247a-046f-4478-a386-e81913c7eab4", "user": 1, "title": "Marbles, and Buckets, and Bubbles... Oh My!", "author": "Kyle Simpson", "created_on": "2023-06-09 00:45:23.874162+00:00", "updated_on": "2023-06-09 00:47:25.844490+00:00", "article_html": "<h2>Marbles, and Buckets, and Bubbles... Oh My!</h2><p>One metaphor I've found effective in understanding scope is sorting colored marbles into buckets of their matching color.</p><p>Imagine you come across a pile of marbles, and notice that all the marbles are colored red, blue, or green. Let's sort all the marbles, dropping the red ones into a red bucket, green into a green bucket, and blue into a blue bucket. After sorting, when you later need a green marble, you already know the green bucket is where to go to get it.</p><p>In this metaphor, the marbles are the variables in our program. The buckets are scopes (functions and blocks), which we just conceptually assign individual colors for our discussion purposes. The color of each marble is thus determined by which <em>color</em> scope we find the marble originally created in.</p><p>Let's annotate the running program example from Chapter 1 with scope color labels:</p><pre><code>// outer/global scope: RED\n\nvar students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    // function scope: BLUE\n\n    for (let student of students) {\n        // loop scope: GREEN\n\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\nconsole.log(nextStudent);   // Suzy</code></pre><p>We've designated three scope colors with code comments: RED (outermost global scope), BLUE (scope of function <code>getStudentName(..)</code>), and GREEN (scope of/inside the <code>for</code> loop). But it still may be difficult to recognize the boundaries of these scope buckets when looking at a code listing.</p><p>Figure 2 helps visualize the boundaries of the scopes by drawing colored bubbles (aka, buckets) around each:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig2.png\"><p><em>Fig. 2: Colored Scope Bubbles</em></p><ol><li><p><strong>Bubble 1</strong> (RED) encompasses the global scope, which holds three identifiers/variables: <code>students</code> (line 1), <code>getStudentName</code> (line 8), and <code>nextStudent</code> (line 16).</p></li><li><p><strong>Bubble 2</strong> (BLUE) encompasses the scope of the function <code>getStudentName(..)</code> (line 8), which holds just one identifier/variable: the parameter <code>studentID</code> (line 8).</p></li><li><p><strong>Bubble 3</strong> (GREEN) encompasses the scope of the <code>for</code>-loop (line 9), which holds just one identifier/variable: <code>student</code> (line 9).</p></li></ol><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Technically, the parameter <code>studentID</code> is not exactly in the BLUE(2) scope. We'll unwind that confusion in \"Implied Scopes\" in Appendix A. For now, it's close enough to label <code>studentID</code> a BLUE(2) marble.</p></td></tr></tbody></table><p>Scope bubbles are determined during compilation based on where the functions/blocks of scope are written, the nesting inside each other, and so on. Each scope bubble is entirely contained within its parent scope bubble\u2014a scope is never partially in two different outer scopes.</p><p>Each marble (variable/identifier) is colored based on which bubble (bucket) it's declared in, not the color of the scope it may be accessed from (e.g., <code>students</code> on line 9 and <code>studentID</code> on line 10).</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Remember we asserted in Chapter 1 that <code>id</code>, <code>name</code>, and <code>log</code> are all properties, not variables; in other words, they're not marbles in buckets, so they don't get colored based on any the rules we're discussing in this book. To understand how such property accesses are handled, see the third book in the series, <em>Objects &amp; Classes</em>.</p></td></tr></tbody></table><p>As the JS engine processes a program (during compilation), and finds a declaration for a variable, it essentially asks, \"Which <em>color</em> scope (bubble or bucket) am I currently in?\" The variable is designated as that same <em>color</em>, meaning it belongs to that bucket/bubble.</p><p>The GREEN(3) bucket is wholly nested inside of the BLUE(2) bucket, and similarly the BLUE(2) bucket is wholly nested inside the RED(1) bucket. Scopes can nest inside each other as shown, to any depth of nesting as your program needs.</p><p>References (non-declarations) to variables/identifiers are allowed if there's a matching declaration either in the current scope, or any scope above/outside the current scope, but not with declarations from lower/nested scopes.</p><p>An expression in the RED(1) bucket only has access to RED(1) marbles, <strong>not</strong> BLUE(2) or GREEN(3). An expression in the BLUE(2) bucket can reference either BLUE(2) or RED(1) marbles, <strong>not</strong> GREEN(3). And an expression in the GREEN(3) bucket has access to RED(1), BLUE(2), and GREEN(3) marbles.</p><p>We can conceptualize the process of determining these non-declaration marble colors during runtime as a lookup. Since the <code>students</code> variable reference in the <code>for</code>-loop statement on line 9 is not a declaration, it has no color. So we ask the current BLUE(2) scope bucket if it has a marble matching that name. Since it doesn't, the lookup continues with the next outer/containing scope: RED(1). The RED(1) bucket has a marble of the name <code>students</code>, so the loop-statement's <code>students</code> variable reference is determined to be a RED(1) marble.</p><p>The <code>if (student.id == studentID)</code> statement on line 10 is similarly determined to reference a GREEN(3) marble named <code>student</code> and a BLUE(2) marble <code>studentID</code>.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The JS engine doesn't generally determine these marble colors during runtime; the \"lookup\" here is a rhetorical device to help you understand the concepts. During compilation, most or all variable references will match already-known scope buckets, so their color is already determined, and stored with each marble reference to avoid unnecessary lookups as the program runs. More on this nuance in Chapter 3.</p></td></tr></tbody></table><p>The key take-aways from marbles &amp; buckets (and bubbles!):</p><ul><li><p>Variables are declared in specific scopes, which can be thought of as colored marbles from matching-color buckets.</p></li><li><p>Any variable reference that appears in the scope where it was declared, or appears in any deeper nested scopes, will be labeled a marble of that same color\u2014unless an intervening scope \"shadows\" the variable declaration; see \"Shadowing\" in Chapter 3.</p></li><li><p>The determination of colored buckets, and the marbles they contain, happens during compilation. This information is used for variable (marble color) \"lookups\" during code execution.</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Marbles, and Buckets, and Bubbles... Oh My!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One metaphor I've found effective in understanding scope is sorting colored marbles into buckets of their matching color.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Imagine you come across a pile of marbles, and notice that all the marbles are colored red, blue, or green. Let's sort all the marbles, dropping the red ones into a red bucket, green into a green bucket, and blue into a blue bucket. After sorting, when you later need a green marble, you already know the green bucket is where to go to get it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this metaphor, the marbles are the variables in our program. The buckets are scopes (functions and blocks), which we just conceptually assign individual colors for our discussion purposes. The color of each marble is thus determined by which ", "type": "text"}, {"text": "color", "type": "text", "marks": [{"type": "italic"}]}, {"text": " scope we find the marble originally created in.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's annotate the running program example from Chapter 1 with scope color labels:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer/global scope: RED\n\nvar students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    // function scope: BLUE\n\n    for (let student of students) {\n        // loop scope: GREEN\n\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\nconsole.log(nextStudent);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We've designated three scope colors with code comments: RED (outermost global scope), BLUE (scope of function ", "type": "text"}, {"text": "getStudentName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and GREEN (scope of/inside the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop). But it still may be difficult to recognize the boundaries of these scope buckets when looking at a code listing.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Figure 2 helps visualize the boundaries of the scopes by drawing colored bubbles (aka, buckets) around each:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig2.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 2: Colored Scope Bubbles", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Bubble 1", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (RED) encompasses the global scope, which holds three identifiers/variables: ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " (line 1), ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " (line 8), and ", "type": "text"}, {"text": "nextStudent", "type": "text", "marks": [{"type": "code"}]}, {"text": " (line 16).", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Bubble 2", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (BLUE) encompasses the scope of the function ", "type": "text"}, {"text": "getStudentName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (line 8), which holds just one identifier/variable: the parameter ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " (line 8).", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Bubble 3", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (GREEN) encompasses the scope of the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop (line 9), which holds just one identifier/variable: ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " (line 9).", "type": "text"}]}]}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Technically, the parameter ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not exactly in the BLUE(2) scope. We'll unwind that confusion in \"Implied Scopes\" in Appendix A. For now, it's close enough to label ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " a BLUE(2) marble.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Scope bubbles are determined during compilation based on where the functions/blocks of scope are written, the nesting inside each other, and so on. Each scope bubble is entirely contained within its parent scope bubble\u2014a scope is never partially in two different outer scopes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each marble (variable/identifier) is colored based on which bubble (bucket) it's declared in, not the color of the scope it may be accessed from (e.g., ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " on line 9 and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " on line 10).", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Remember we asserted in Chapter 1 that ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "log", "type": "text", "marks": [{"type": "code"}]}, {"text": " are all properties, not variables; in other words, they're not marbles in buckets, so they don't get colored based on any the rules we're discussing in this book. To understand how such property accesses are handled, see the third book in the series, ", "type": "text"}, {"text": "Objects & Classes", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "As the JS engine processes a program (during compilation), and finds a declaration for a variable, it essentially asks, \"Which ", "type": "text"}, {"text": "color", "type": "text", "marks": [{"type": "italic"}]}, {"text": " scope (bubble or bucket) am I currently in?\" The variable is designated as that same ", "type": "text"}, {"text": "color", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", meaning it belongs to that bucket/bubble.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The GREEN(3) bucket is wholly nested inside of the BLUE(2) bucket, and similarly the BLUE(2) bucket is wholly nested inside the RED(1) bucket. Scopes can nest inside each other as shown, to any depth of nesting as your program needs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "References (non-declarations) to variables/identifiers are allowed if there's a matching declaration either in the current scope, or any scope above/outside the current scope, but not with declarations from lower/nested scopes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An expression in the RED(1) bucket only has access to RED(1) marbles, ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " BLUE(2) or GREEN(3). An expression in the BLUE(2) bucket can reference either BLUE(2) or RED(1) marbles, ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " GREEN(3). And an expression in the GREEN(3) bucket has access to RED(1), BLUE(2), and GREEN(3) marbles.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We can conceptualize the process of determining these non-declaration marble colors during runtime as a lookup. Since the ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable reference in the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop statement on line 9 is not a declaration, it has no color. So we ask the current BLUE(2) scope bucket if it has a marble matching that name. Since it doesn't, the lookup continues with the next outer/containing scope: RED(1). The RED(1) bucket has a marble of the name ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so the loop-statement's ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable reference is determined to be a RED(1) marble.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "if (student.id == studentID)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement on line 10 is similarly determined to reference a GREEN(3) marble named ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " and a BLUE(2) marble ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The JS engine doesn't generally determine these marble colors during runtime; the \"lookup\" here is a rhetorical device to help you understand the concepts. During compilation, most or all variable references will match already-known scope buckets, so their color is already determined, and stored with each marble reference to avoid unnecessary lookups as the program runs. More on this nuance in Chapter 3.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "The key take-aways from marbles & buckets (and bubbles!):", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Variables are declared in specific scopes, which can be thought of as colored marbles from matching-color buckets.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Any variable reference that appears in the scope where it was declared, or appears in any deeper nested scopes, will be labeled a marble of that same color\u2014unless an intervening scope \"shadows\" the variable declaration; see \"Shadowing\" in Chapter 3.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The determination of colored buckets, and the marbles they contain, happens during compilation. This information is used for variable (marble color) \"lookups\" during code execution.", "type": "text"}]}]}]}]}, "article_text": "Marbles, and Buckets, and Bubbles... Oh My!\n\nOne metaphor I've found effective in understanding scope is sorting colored marbles into buckets of their matching color.\n\nImagine you come across a pile of marbles, and notice that all the marbles are colored red, blue, or green. Let's sort all the marbles, dropping the red ones into a red bucket, green into a green bucket, and blue into a blue bucket. After sorting, when you later need a green marble, you already know the green bucket is where to go to get it.\n\nIn this metaphor, the marbles are the variables in our program. The buckets are scopes (functions and blocks), which we just conceptually assign individual colors for our discussion purposes. The color of each marble is thus determined by which color scope we find the marble originally created in.\n\nLet's annotate the running program example from Chapter 1 with scope color labels:\n\n// outer/global scope: RED\n\nvar students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    // function scope: BLUE\n\n    for (let student of students) {\n        // loop scope: GREEN\n\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\nconsole.log(nextStudent);   // Suzy\n\nWe've designated three scope colors with code comments: RED (outermost global scope), BLUE (scope of function getStudentName(..)), and GREEN (scope of/inside the for loop). But it still may be difficult to recognize the boundaries of these scope buckets when looking at a code listing.\n\nFigure 2 helps visualize the boundaries of the scopes by drawing colored bubbles (aka, buckets) around each:\n\nFig. 2: Colored Scope Bubbles\n\nBubble 1 (RED) encompasses the global scope, which holds three identifiers/variables: students (line 1), getStudentName (line 8), and nextStudent (line 16).\n\nBubble 2 (BLUE) encompasses the scope of the function getStudentName(..) (line 8), which holds just one identifier/variable: the parameter studentID (line 8).\n\nBubble 3 (GREEN) encompasses the scope of the for-loop (line 9), which holds just one identifier/variable: student (line 9).\n\nNOTE:\n\nTechnically, the parameter studentID is not exactly in the BLUE(2) scope. We'll unwind that confusion in \"Implied Scopes\" in Appendix A. For now, it's close enough to label studentID a BLUE(2) marble.\n\nScope bubbles are determined during compilation based on where the functions/blocks of scope are written, the nesting inside each other, and so on. Each scope bubble is entirely contained within its parent scope bubble\u2014a scope is never partially in two different outer scopes.\n\nEach marble (variable/identifier) is colored based on which bubble (bucket) it's declared in, not the color of the scope it may be accessed from (e.g., students on line 9 and studentID on line 10).\n\nNOTE:\n\nRemember we asserted in Chapter 1 that id, name, and log are all properties, not variables; in other words, they're not marbles in buckets, so they don't get colored based on any the rules we're discussing in this book. To understand how such property accesses are handled, see the third book in the series, Objects & Classes.\n\nAs the JS engine processes a program (during compilation), and finds a declaration for a variable, it essentially asks, \"Which color scope (bubble or bucket) am I currently in?\" The variable is designated as that same color, meaning it belongs to that bucket/bubble.\n\nThe GREEN(3) bucket is wholly nested inside of the BLUE(2) bucket, and similarly the BLUE(2) bucket is wholly nested inside the RED(1) bucket. Scopes can nest inside each other as shown, to any depth of nesting as your program needs.\n\nReferences (non-declarations) to variables/identifiers are allowed if there's a matching declaration either in the current scope, or any scope above/outside the current scope, but not with declarations from lower/nested scopes.\n\nAn expression in the RED(1) bucket only has access to RED(1) marbles, not BLUE(2) or GREEN(3). An expression in the BLUE(2) bucket can reference either BLUE(2) or RED(1) marbles, not GREEN(3). And an expression in the GREEN(3) bucket has access to RED(1), BLUE(2), and GREEN(3) marbles.\n\nWe can conceptualize the process of determining these non-declaration marble colors during runtime as a lookup. Since the students variable reference in the for-loop statement on line 9 is not a declaration, it has no color. So we ask the current BLUE(2) scope bucket if it has a marble matching that name. Since it doesn't, the lookup continues with the next outer/containing scope: RED(1). The RED(1) bucket has a marble of the name students, so the loop-statement's students variable reference is determined to be a RED(1) marble.\n\nThe if (student.id == studentID) statement on line 10 is similarly determined to reference a GREEN(3) marble named student and a BLUE(2) marble studentID.\n\nNOTE:\n\nThe JS engine doesn't generally determine these marble colors during runtime; the \"lookup\" here is a rhetorical device to help you understand the concepts. During compilation, most or all variable references will match already-known scope buckets, so their color is already determined, and stored with each marble reference to avoid unnecessary lookups as the program runs. More on this nuance in Chapter 3.\n\nThe key take-aways from marbles & buckets (and bubbles!):\n\nVariables are declared in specific scopes, which can be thought of as colored marbles from matching-color buckets.\n\nAny variable reference that appears in the scope where it was declared, or appears in any deeper nested scopes, will be labeled a marble of that same color\u2014unless an intervening scope \"shadows\" the variable declaration; see \"Shadowing\" in Chapter 3.\n\nThe determination of colored buckets, and the marbles they contain, happens during compilation. This information is used for variable (marble color) \"lookups\" during code execution."}, "id": 176}, {"data": {"uuid": "43b5c20a-f738-4981-9726-3952e9f1734f", "user": 1, "title": "A Conversation Among Friends", "author": "Kyle Simpson", "created_on": "2023-06-09 00:53:10.376627+00:00", "updated_on": "2023-06-09 00:53:39.139651+00:00", "article_html": "<h2>A Conversation Among Friends</h2><p>Another useful metaphor for the process of analyzing variables and the scopes they come from is to imagine various conversations that occur inside the engine as code is processed and then executed. We can \"listen in\" on these conversations to get a better conceptual foundation for how scopes work.</p><p>Let's now meet the members of the JS engine that will have conversations as they process our program:</p><ul><li><p><em>Engine</em>: responsible for start-to-finish compilation and execution of our JavaScript program.</p></li><li><p><em>Compiler</em>: one of <em>Engine</em>'s friends; handles all the dirty work of parsing and code-generation (see previous section).</p></li><li><p><em>Scope Manager</em>: another friend of <em>Engine</em>; collects and maintains a lookup list of all the declared variables/identifiers, and enforces a set of rules as to how these are accessible to currently executing code.</p></li></ul><p>For you to <em>fully understand</em> how JavaScript works, you need to begin to <em>think</em> like <em>Engine</em> (and friends) think, ask the questions they ask, and answer their questions likewise.</p><p>To explore these conversations, recall again our running program example:</p><pre><code>var students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    for (let student of students) {\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\n\nconsole.log(nextStudent);\n// Suzy</code></pre><p>Let's examine how JS is going to process that program, specifically starting with the first statement. The array and its contents are just basic JS value literals (and thus unaffected by any scoping concerns), so our focus here will be on the <code>var students = [ .. ]</code> declaration and initialization-assignment parts.</p><p>We typically think of that as a single statement, but that's not how our friend <em>Engine</em> sees it. In fact, JS treats these as two distinct operations, one which <em>Compiler</em> will handle during compilation, and the other which <em>Engine</em> will handle during execution.</p><p>The first thing <em>Compiler</em> will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree (AST).</p><p>Once <em>Compiler</em> gets to code generation, there's more detail to consider than may be obvious. A reasonable assumption would be that <em>Compiler</em> will produce code for the first statement such as: \"Allocate memory for a variable, label it <code>students</code>, then stick a reference to the array into that variable.\" But that's not the whole story.</p><p>Here's the steps <em>Compiler</em> will follow to handle that statement:</p><ol><li><p>Encountering <code>var students</code>, <em>Compiler</em> will ask <em>Scope Manager</em> to see if a variable named <code>students</code> already exists for that particular scope bucket. If so, <em>Compiler</em> would ignore this declaration and move on. Otherwise, <em>Compiler</em> will produce code that (at execution time) asks <em>Scope Manager</em> to create a new variable called <code>students</code> in that scope bucket.</p></li><li><p><em>Compiler</em> then produces code for <em>Engine</em> to later execute, to handle the <code>students = []</code> assignment. The code <em>Engine</em> runs will first ask <em>Scope Manager</em> if there is a variable called <code>students</code> accessible in the current scope bucket. If not, <em>Engine</em> keeps looking elsewhere (see \"Nested Scope\" below). Once <em>Engine</em> finds a variable, it assigns the reference of the <code>[ .. ]</code> array to it.</p></li></ol><p>In conversational form, the first phase of compilation for the program might play out between <em>Compiler</em> and <em>Scope Manager</em> like this:</p><blockquote><p><strong><em>Compiler</em></strong>: Hey, <em>Scope Manager</em> (of the global scope), I found a formal declaration for an identifier called <code>students</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Nope, never heard of it, so I just created it for you.</p></blockquote><blockquote><p><strong><em>Compiler</em></strong>: Hey, <em>Scope Manager</em>, I found a formal declaration for an identifier called <code>getStudentName</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Nope, but I just created it for you.</p></blockquote><blockquote><p><strong><em>Compiler</em></strong>: Hey, <em>Scope Manager</em>, <code>getStudentName</code> points to a function, so we need a new scope bucket.</p></blockquote><blockquote><p><strong><em>(Function) Scope Manager</em></strong>: Got it, here's the scope bucket.</p></blockquote><blockquote><p><strong><em>Compiler</em></strong>: Hey, <em>Scope Manager</em> (of the function), I found a formal parameter declaration for <code>studentID</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Function) Scope Manager</em></strong>: Nope, but now it's created in this scope.</p></blockquote><blockquote><p><strong><em>Compiler</em></strong>: Hey, <em>Scope Manager</em> (of the function), I found a <code>for</code>-loop that will need its own scope bucket.</p></blockquote><blockquote><p>...</p></blockquote><p>The conversation is a question-and-answer exchange, where <strong>Compiler</strong> asks the current <em>Scope Manager</em> if an encountered identifier declaration has already been encountered. If \"no,\" <em>Scope Manager</em> creates that variable in that scope. If the answer is \"yes,\" then it's effectively skipped over since there's nothing more for that <em>Scope Manager</em> to do.</p><p><em>Compiler</em> also signals when it runs across functions or block scopes, so that a new scope bucket and <em>Scope Manager</em> can be instantiated.</p><p>Later, when it comes to execution of the program, the conversation will shift to <em>Engine</em> and <em>Scope Manager</em>, and might play out like this:</p><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em> (of the global scope), before we begin, can you look up the identifier <code>getStudentName</code> so I can assign this function to it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Yep, here's the variable.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em>, I found a <em>target</em> reference for <code>students</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Yes, it was formally declared for this scope, so here it is.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Thanks, I'm initializing <code>students</code> to <code>undefined</code>, so it's ready to use.</p></blockquote><blockquote><p>Hey, <em>Scope Manager</em> (of the global scope), I found a <em>target</em> reference for <code>nextStudent</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Yes, it was formally declared for this scope, so here it is.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Thanks, I'm initializing <code>nextStudent</code> to <code>undefined</code>, so it's ready to use.</p></blockquote><blockquote><p>Hey, <em>Scope Manager</em> (of the global scope), I found a <em>source</em> reference for <code>getStudentName</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Yes, it was formally declared for this scope. Here it is.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Great, the value in <code>getStudentName</code> is a function, so I'm going to execute it.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em>, now we need to instantiate the function's scope.</p></blockquote><blockquote><p>...</p></blockquote><p>This conversation is another question-and-answer exchange, where <em>Engine</em> first asks the current <em>Scope Manager</em> to look up the hoisted <code>getStudentName</code> identifier, so as to associate the function with it. <em>Engine</em> then proceeds to ask <em>Scope Manager</em> about the <em>target</em> reference for <code>students</code>, and so on.</p><p>To review and summarize how a statement like <code>var students = [ .. ]</code> is processed, in two distinct steps:</p><ol><li><p><em>Compiler</em> sets up the declaration of the scope variable (since it wasn't previously declared in the current scope).</p></li><li><p>While <em>Engine</em> is executing, to process the assignment part of the statement, <em>Engine</em> asks <em>Scope Manager</em> to look up the variable, initializes it to <code>undefined</code> so it's ready to use, and then assigns the array value to it.</p></li></ol>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "A Conversation Among Friends", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another useful metaphor for the process of analyzing variables and the scopes they come from is to imagine various conversations that occur inside the engine as code is processed and then executed. We can \"listen in\" on these conversations to get a better conceptual foundation for how scopes work.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's now meet the members of the JS engine that will have conversations as they process our program:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": ": responsible for start-to-finish compilation and execution of our JavaScript program.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": ": one of ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": "'s friends; handles all the dirty work of parsing and code-generation (see previous section).", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": ": another friend of ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": "; collects and maintains a lookup list of all the declared variables/identifiers, and enforces a set of rules as to how these are accessible to currently executing code.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "For you to ", "type": "text"}, {"text": "fully understand", "type": "text", "marks": [{"type": "italic"}]}, {"text": " how JavaScript works, you need to begin to ", "type": "text"}, {"text": "think", "type": "text", "marks": [{"type": "italic"}]}, {"text": " like ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (and friends) think, ask the questions they ask, and answer their questions likewise.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To explore these conversations, recall again our running program example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    for (let student of students) {\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\n\nconsole.log(nextStudent);\n// Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's examine how JS is going to process that program, specifically starting with the first statement. The array and its contents are just basic JS value literals (and thus unaffected by any scoping concerns), so our focus here will be on the ", "type": "text"}, {"text": "var students = [ .. ]", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration and initialization-assignment parts.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We typically think of that as a single statement, but that's not how our friend ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " sees it. In fact, JS treats these as two distinct operations, one which ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will handle during compilation, and the other which ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will handle during execution.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first thing ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree (AST).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Once ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " gets to code generation, there's more detail to consider than may be obvious. A reasonable assumption would be that ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will produce code for the first statement such as: \"Allocate memory for a variable, label it ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", then stick a reference to the array into that variable.\" But that's not the whole story.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's the steps ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will follow to handle that statement:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Encountering ", "type": "text"}, {"text": "var students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will ask ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to see if a variable named ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " already exists for that particular scope bucket. If so, ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " would ignore this declaration and move on. Otherwise, ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will produce code that (at execution time) asks ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to create a new variable called ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " in that scope bucket.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " then produces code for ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to later execute, to handle the ", "type": "text"}, {"text": "students = []", "type": "text", "marks": [{"type": "code"}]}, {"text": " assignment. The code ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " runs will first ask ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if there is a variable called ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " accessible in the current scope bucket. If not, ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " keeps looking elsewhere (see \"Nested Scope\" below). Once ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " finds a variable, it assigns the reference of the ", "type": "text"}, {"text": "[ .. ]", "type": "text", "marks": [{"type": "code"}]}, {"text": " array to it.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "In conversational form, the first phase of compilation for the program might play out between ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " like this:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (of the global scope), I found a formal declaration for an identifier called ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, never heard of it, so I just created it for you.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", I found a formal declaration for an identifier called ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, but I just created it for you.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " points to a function, so we need a new scope bucket.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Function) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Got it, here's the scope bucket.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (of the function), I found a formal parameter declaration for ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Function) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, but now it's created in this scope.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (of the function), I found a ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop that will need its own scope bucket.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "...", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "The conversation is a question-and-answer exchange, where ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "bold"}]}, {"text": " asks the current ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if an encountered identifier declaration has already been encountered. If \"no,\" ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " creates that variable in that scope. If the answer is \"yes,\" then it's effectively skipped over since there's nothing more for that ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to do.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " also signals when it runs across functions or block scopes, so that a new scope bucket and ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " can be instantiated.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Later, when it comes to execution of the program, the conversation will shift to ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and might play out like this:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (of the global scope), before we begin, can you look up the identifier ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " so I can assign this function to it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Yep, here's the variable.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", I found a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Yes, it was formally declared for this scope, so here it is.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Thanks, I'm initializing ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so it's ready to use.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (of the global scope), I found a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "nextStudent", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Yes, it was formally declared for this scope, so here it is.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Thanks, I'm initializing ", "type": "text"}, {"text": "nextStudent", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so it's ready to use.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (of the global scope), I found a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Yes, it was formally declared for this scope. Here it is.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Great, the value in ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a function, so I'm going to execute it.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", now we need to instantiate the function's scope.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "...", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "This conversation is another question-and-answer exchange, where ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " first asks the current ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to look up the hoisted ", "type": "text"}, {"text": "getStudentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier, so as to associate the function with it. ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " then proceeds to ask ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " about the ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and so on.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To review and summarize how a statement like ", "type": "text"}, {"text": "var students = [ .. ]", "type": "text", "marks": [{"type": "code"}]}, {"text": " is processed, in two distinct steps:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " sets up the declaration of the scope variable (since it wasn't previously declared in the current scope).", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "While ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is executing, to process the assignment part of the statement, ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " asks ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to look up the variable, initializes it to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " so it's ready to use, and then assigns the array value to it.", "type": "text"}]}]}]}]}, "article_text": "A Conversation Among Friends\n\nAnother useful metaphor for the process of analyzing variables and the scopes they come from is to imagine various conversations that occur inside the engine as code is processed and then executed. We can \"listen in\" on these conversations to get a better conceptual foundation for how scopes work.\n\nLet's now meet the members of the JS engine that will have conversations as they process our program:\n\nEngine: responsible for start-to-finish compilation and execution of our JavaScript program.\n\nCompiler: one of Engine's friends; handles all the dirty work of parsing and code-generation (see previous section).\n\nScope Manager: another friend of Engine; collects and maintains a lookup list of all the declared variables/identifiers, and enforces a set of rules as to how these are accessible to currently executing code.\n\nFor you to fully understand how JavaScript works, you need to begin to think like Engine (and friends) think, ask the questions they ask, and answer their questions likewise.\n\nTo explore these conversations, recall again our running program example:\n\nvar students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getStudentName(studentID) {\n    for (let student of students) {\n        if (student.id == studentID) {\n            return student.name;\n        }\n    }\n}\n\nvar nextStudent = getStudentName(73);\n\nconsole.log(nextStudent);\n// Suzy\n\nLet's examine how JS is going to process that program, specifically starting with the first statement. The array and its contents are just basic JS value literals (and thus unaffected by any scoping concerns), so our focus here will be on the var students = [ .. ] declaration and initialization-assignment parts.\n\nWe typically think of that as a single statement, but that's not how our friend Engine sees it. In fact, JS treats these as two distinct operations, one which Compiler will handle during compilation, and the other which Engine will handle during execution.\n\nThe first thing Compiler will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree (AST).\n\nOnce Compiler gets to code generation, there's more detail to consider than may be obvious. A reasonable assumption would be that Compiler will produce code for the first statement such as: \"Allocate memory for a variable, label it students, then stick a reference to the array into that variable.\" But that's not the whole story.\n\nHere's the steps Compiler will follow to handle that statement:\n\nEncountering var students, Compiler will ask Scope Manager to see if a variable named students already exists for that particular scope bucket. If so, Compiler would ignore this declaration and move on. Otherwise, Compiler will produce code that (at execution time) asks Scope Manager to create a new variable called students in that scope bucket.\n\nCompiler then produces code for Engine to later execute, to handle the students = [] assignment. The code Engine runs will first ask Scope Manager if there is a variable called students accessible in the current scope bucket. If not, Engine keeps looking elsewhere (see \"Nested Scope\" below). Once Engine finds a variable, it assigns the reference of the [ .. ] array to it.\n\nIn conversational form, the first phase of compilation for the program might play out between Compiler and Scope Manager like this:\n\nCompiler: Hey, Scope Manager (of the global scope), I found a formal declaration for an identifier called students, ever heard of it?\n\n(Global) Scope Manager: Nope, never heard of it, so I just created it for you.\n\nCompiler: Hey, Scope Manager, I found a formal declaration for an identifier called getStudentName, ever heard of it?\n\n(Global) Scope Manager: Nope, but I just created it for you.\n\nCompiler: Hey, Scope Manager, getStudentName points to a function, so we need a new scope bucket.\n\n(Function) Scope Manager: Got it, here's the scope bucket.\n\nCompiler: Hey, Scope Manager (of the function), I found a formal parameter declaration for studentID, ever heard of it?\n\n(Function) Scope Manager: Nope, but now it's created in this scope.\n\nCompiler: Hey, Scope Manager (of the function), I found a for-loop that will need its own scope bucket.\n\n...\n\nThe conversation is a question-and-answer exchange, where Compiler asks the current Scope Manager if an encountered identifier declaration has already been encountered. If \"no,\" Scope Manager creates that variable in that scope. If the answer is \"yes,\" then it's effectively skipped over since there's nothing more for that Scope Manager to do.\n\nCompiler also signals when it runs across functions or block scopes, so that a new scope bucket and Scope Manager can be instantiated.\n\nLater, when it comes to execution of the program, the conversation will shift to Engine and Scope Manager, and might play out like this:\n\nEngine: Hey, Scope Manager (of the global scope), before we begin, can you look up the identifier getStudentName so I can assign this function to it?\n\n(Global) Scope Manager: Yep, here's the variable.\n\nEngine: Hey, Scope Manager, I found a target reference for students, ever heard of it?\n\n(Global) Scope Manager: Yes, it was formally declared for this scope, so here it is.\n\nEngine: Thanks, I'm initializing students to undefined, so it's ready to use.\n\nHey, Scope Manager (of the global scope), I found a target reference for nextStudent, ever heard of it?\n\n(Global) Scope Manager: Yes, it was formally declared for this scope, so here it is.\n\nEngine: Thanks, I'm initializing nextStudent to undefined, so it's ready to use.\n\nHey, Scope Manager (of the global scope), I found a source reference for getStudentName, ever heard of it?\n\n(Global) Scope Manager: Yes, it was formally declared for this scope. Here it is.\n\nEngine: Great, the value in getStudentName is a function, so I'm going to execute it.\n\nEngine: Hey, Scope Manager, now we need to instantiate the function's scope.\n\n...\n\nThis conversation is another question-and-answer exchange, where Engine first asks the current Scope Manager to look up the hoisted getStudentName identifier, so as to associate the function with it. Engine then proceeds to ask Scope Manager about the target reference for students, and so on.\n\nTo review and summarize how a statement like var students = [ .. ] is processed, in two distinct steps:\n\nCompiler sets up the declaration of the scope variable (since it wasn't previously declared in the current scope).\n\nWhile Engine is executing, to process the assignment part of the statement, Engine asks Scope Manager to look up the variable, initializes it to undefined so it's ready to use, and then assigns the array value to it."}, "id": 177}, {"data": {"uuid": "9bb0b17a-6fff-434b-92b8-9c3e950a7ca4", "user": 1, "title": "Nested Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 00:54:06.150076+00:00", "updated_on": "2023-06-09 00:54:27.606222+00:00", "article_html": "<h2>Nested Scope</h2><p>When it comes time to execute the <code>getStudentName()</code> function, <em>Engine</em> asks for a <em>Scope Manager</em> instance for that function's scope, and it will then proceed to look up the parameter (<code>studentID</code>) to assign the <code>73</code> argument value to, and so on.</p><p>The function scope for <code>getStudentName(..)</code> is nested inside the global scope. The block scope of the <code>for</code>-loop is similarly nested inside that function scope. Scopes can be lexically nested to any arbitrary depth as the program defines.</p><p>Each scope gets its own <em>Scope Manager</em> instance each time that scope is executed (one or more times). Each scope automatically has all its identifiers registered at the start of the scope being executed (this is called \"variable hoisting\"; see Chapter 5).</p><p>At the beginning of a scope, if any identifier came from a <code>function</code> declaration, that variable is automatically initialized to its associated function reference. And if any identifier came from a <code>var</code> declaration (as opposed to <code>let</code>/<code>const</code>), that variable is automatically initialized to <code>undefined</code> so that it can be used; otherwise, the variable remains uninitialized (aka, in its \"TDZ,\" see Chapter 5) and cannot be used until its full declaration-and-initialization are executed.</p><p>In the <code>for (let student of students) {</code> statement, <code>students</code> is a <em>source</em> reference that must be looked up. But how will that lookup be handled, since the scope of the function will not find such an identifier?</p><p>To explain, let's imagine that bit of conversation playing out like this:</p><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em> (for the function), I have a <em>source</em> reference for <code>students</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Function) Scope Manager</em></strong>: Nope, never heard of it. Try the next outer scope.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em> (for the global scope), I have a <em>source</em> reference for <code>students</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Yep, it was formally declared, here it is.</p></blockquote><blockquote><p>...</p></blockquote><p>One of the key aspects of lexical scope is that any time an identifier reference cannot be found in the current scope, the next outer scope in the nesting is consulted; that process is repeated until an answer is found or there are no more scopes to consult.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Nested Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When it comes time to execute the ", "type": "text"}, {"text": "getStudentName()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " asks for a ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " instance for that function's scope, and it will then proceed to look up the parameter (", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ") to assign the ", "type": "text"}, {"text": "73", "type": "text", "marks": [{"type": "code"}]}, {"text": " argument value to, and so on.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The function scope for ", "type": "text"}, {"text": "getStudentName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is nested inside the global scope. The block scope of the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop is similarly nested inside that function scope. Scopes can be lexically nested to any arbitrary depth as the program defines.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each scope gets its own ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " instance each time that scope is executed (one or more times). Each scope automatically has all its identifiers registered at the start of the scope being executed (this is called \"variable hoisting\"; see Chapter 5).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "At the beginning of a scope, if any identifier came from a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration, that variable is automatically initialized to its associated function reference. And if any identifier came from a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration (as opposed to ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "), that variable is automatically initialized to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " so that it can be used; otherwise, the variable remains uninitialized (aka, in its \"TDZ,\" see Chapter 5) and cannot be used until its full declaration-and-initialization are executed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the ", "type": "text"}, {"text": "for (let student of students) {", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement, ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference that must be looked up. But how will that lookup be handled, since the scope of the function will not find such an identifier?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To explain, let's imagine that bit of conversation playing out like this:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (for the function), I have a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Function) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, never heard of it. Try the next outer scope.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (for the global scope), I have a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Yep, it was formally declared, here it is.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "...", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "One of the key aspects of lexical scope is that any time an identifier reference cannot be found in the current scope, the next outer scope in the nesting is consulted; that process is repeated until an answer is found or there are no more scopes to consult.", "type": "text"}]}]}, "article_text": "Nested Scope\n\nWhen it comes time to execute the getStudentName() function, Engine asks for a Scope Manager instance for that function's scope, and it will then proceed to look up the parameter (studentID) to assign the 73 argument value to, and so on.\n\nThe function scope for getStudentName(..) is nested inside the global scope. The block scope of the for-loop is similarly nested inside that function scope. Scopes can be lexically nested to any arbitrary depth as the program defines.\n\nEach scope gets its own Scope Manager instance each time that scope is executed (one or more times). Each scope automatically has all its identifiers registered at the start of the scope being executed (this is called \"variable hoisting\"; see Chapter 5).\n\nAt the beginning of a scope, if any identifier came from a function declaration, that variable is automatically initialized to its associated function reference. And if any identifier came from a var declaration (as opposed to let/const), that variable is automatically initialized to undefined so that it can be used; otherwise, the variable remains uninitialized (aka, in its \"TDZ,\" see Chapter 5) and cannot be used until its full declaration-and-initialization are executed.\n\nIn the for (let student of students) { statement, students is a source reference that must be looked up. But how will that lookup be handled, since the scope of the function will not find such an identifier?\n\nTo explain, let's imagine that bit of conversation playing out like this:\n\nEngine: Hey, Scope Manager (for the function), I have a source reference for students, ever heard of it?\n\n(Function) Scope Manager: Nope, never heard of it. Try the next outer scope.\n\nEngine: Hey, Scope Manager (for the global scope), I have a source reference for students, ever heard of it?\n\n(Global) Scope Manager: Yep, it was formally declared, here it is.\n\n...\n\nOne of the key aspects of lexical scope is that any time an identifier reference cannot be found in the current scope, the next outer scope in the nesting is consulted; that process is repeated until an answer is found or there are no more scopes to consult."}, "id": 178, "children": [{"data": {"uuid": "6b9ef6b1-c251-4d3f-8cc6-8610573fdabd", "user": 1, "title": "Lookup Failures", "author": "Kyle Simpson", "created_on": "2023-06-09 00:54:50.068515+00:00", "updated_on": "2023-06-09 00:55:35.230176+00:00", "article_html": "<h3>Lookup Failures</h3><p>When <em>Engine</em> exhausts all <em>lexically available</em> scopes (moving outward) and still cannot resolve the lookup of an identifier, an error condition then exists. However, depending on the mode of the program (strict-mode or not) and the role of the variable (i.e., <em>target</em> vs. <em>source</em>; see Chapter 1), this error condition will be handled differently.</p><h4>Undefined Mess</h4><p>If the variable is a <em>source</em>, an unresolved identifier lookup is considered an undeclared (unknown, missing) variable, which always results in a <code>ReferenceError</code> being thrown. Also, if the variable is a <em>target</em>, and the code at that moment is running in strict-mode, the variable is considered undeclared and similarly throws a <code>ReferenceError</code>.</p><p>The error message for an undeclared variable condition, in most JS environments, will look like, \"Reference Error: XYZ is not defined.\" The phrase \"not defined\" seems almost identical to the word \"undefined,\" as far as the English language goes. But these two are very different in JS, and this error message unfortunately creates a persistent confusion.</p><p>\"Not defined\" really means \"not declared\"\u2014or, rather, \"undeclared,\" as in a variable that has no matching formal declaration in any <em>lexically available</em> scope. By contrast, \"undefined\" really means a variable was found (declared), but the variable otherwise has no other value in it at the moment, so it defaults to the <code>undefined</code> value.</p><p>To perpetuate the confusion even further, JS's <code>typeof</code> operator returns the string <code>\"undefined\"</code> for variable references in either state:</p><pre><code>var studentName;\ntypeof studentName;     // \"undefined\"\n\ntypeof doesntExist;     // \"undefined\"</code></pre><p>These two variable references are in very different conditions, but JS sure does muddy the waters. The terminology mess is confusing and terribly unfortunate. Unfortunately, JS developers just have to pay close attention to not mix up <em>which kind</em> of \"undefined\" they're dealing with!</p><h4>Global... What!?</h4><p>If the variable is a <em>target</em> and strict-mode is not in effect, a confusing and surprising legacy behavior kicks in. The troublesome outcome is that the global scope's <em>Scope Manager</em> will just create an <strong>accidental global variable</strong> to fulfill that target assignment!</p><p>Consider:</p><pre><code>function getStudentName() {\n    // assignment to an undeclared variable :(\n    nextStudent = \"Suzy\";\n}\n\ngetStudentName();\n\nconsole.log(nextStudent);\n// \"Suzy\" -- oops, an accidental-global variable!</code></pre><p>Here's how that <em>conversation</em> will proceed:</p><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em> (for the function), I have a <em>target</em> reference for <code>nextStudent</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Function) Scope Manager</em></strong>: Nope, never heard of it. Try the next outer scope.</p></blockquote><blockquote><p><strong><em>Engine</em></strong>: Hey, <em>Scope Manager</em> (for the global scope), I have a <em>target</em> reference for <code>nextStudent</code>, ever heard of it?</p></blockquote><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Nope, but since we're in non-strict-mode, I helped you out and just created a global variable for you, here it is!</p></blockquote><p>Yuck.</p><p>This sort of accident (almost certain to lead to bugs eventually) is a great example of the beneficial protections offered by strict-mode, and why it's such a bad idea <em>not</em> to be using strict-mode. In strict-mode, the <strong><em>Global Scope Manager</em></strong> would instead have responded:</p><blockquote><p><strong><em>(Global) Scope Manager</em></strong>: Nope, never heard of it. Sorry, I've got to throw a <code>ReferenceError</code>.</p></blockquote><p>Assigning to a never-declared variable <em>is</em> an error, so it's right that we would receive a <code>ReferenceError</code> here.</p><p>Never rely on accidental global variables. Always use strict-mode, and always formally declare your variables. You'll then get a helpful <code>ReferenceError</code> if you ever mistakenly try to assign to a not-declared variable.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Lookup Failures", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " exhausts all ", "type": "text"}, {"text": "lexically available", "type": "text", "marks": [{"type": "italic"}]}, {"text": " scopes (moving outward) and still cannot resolve the lookup of an identifier, an error condition then exists. However, depending on the mode of the program (strict-mode or not) and the role of the variable (i.e., ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " vs. ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": "; see Chapter 1), this error condition will be handled differently.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Undefined Mess", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If the variable is a ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", an unresolved identifier lookup is considered an undeclared (unknown, missing) variable, which always results in a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " being thrown. Also, if the variable is a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and the code at that moment is running in strict-mode, the variable is considered undeclared and similarly throws a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The error message for an undeclared variable condition, in most JS environments, will look like, \"Reference Error: XYZ is not defined.\" The phrase \"not defined\" seems almost identical to the word \"undefined,\" as far as the English language goes. But these two are very different in JS, and this error message unfortunately creates a persistent confusion.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "\"Not defined\" really means \"not declared\"\u2014or, rather, \"undeclared,\" as in a variable that has no matching formal declaration in any ", "type": "text"}, {"text": "lexically available", "type": "text", "marks": [{"type": "italic"}]}, {"text": " scope. By contrast, \"undefined\" really means a variable was found (declared), but the variable otherwise has no other value in it at the moment, so it defaults to the ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To perpetuate the confusion even further, JS's ", "type": "text"}, {"text": "typeof", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator returns the string ", "type": "text"}, {"text": "\"undefined\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " for variable references in either state:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName;\ntypeof studentName;     // \"undefined\"\n\ntypeof doesntExist;     // \"undefined\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These two variable references are in very different conditions, but JS sure does muddy the waters. The terminology mess is confusing and terribly unfortunate. Unfortunately, JS developers just have to pay close attention to not mix up ", "type": "text"}, {"text": "which kind", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of \"undefined\" they're dealing with!", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Global... What!?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If the variable is a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and strict-mode is not in effect, a confusing and surprising legacy behavior kicks in. The troublesome outcome is that the global scope's ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will just create an ", "type": "text"}, {"text": "accidental global variable", "type": "text", "marks": [{"type": "bold"}]}, {"text": " to fulfill that target assignment!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudentName() {\n    // assignment to an undeclared variable :(\n    nextStudent = \"Suzy\";\n}\n\ngetStudentName();\n\nconsole.log(nextStudent);\n// \"Suzy\" -- oops, an accidental-global variable!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's how that ", "type": "text"}, {"text": "conversation", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will proceed:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (for the function), I have a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "nextStudent", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Function) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, never heard of it. Try the next outer scope.", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Engine", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Hey, ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (for the global scope), I have a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " reference for ", "type": "text"}, {"text": "nextStudent", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ever heard of it?", "type": "text"}]}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, but since we're in non-strict-mode, I helped you out and just created a global variable for you, here it is!", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "Yuck.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This sort of accident (almost certain to lead to bugs eventually) is a great example of the beneficial protections offered by strict-mode, and why it's such a bad idea ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to be using strict-mode. In strict-mode, the ", "type": "text"}, {"text": "Global Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": " would instead have responded:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "(Global) Scope Manager", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": ": Nope, never heard of it. Sorry, I've got to throw a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "Assigning to a never-declared variable ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " an error, so it's right that we would receive a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " here.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Never rely on accidental global variables. Always use strict-mode, and always formally declare your variables. You'll then get a helpful ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " if you ever mistakenly try to assign to a not-declared variable.", "type": "text"}]}]}, "article_text": "Lookup Failures\n\nWhen Engine exhausts all lexically available scopes (moving outward) and still cannot resolve the lookup of an identifier, an error condition then exists. However, depending on the mode of the program (strict-mode or not) and the role of the variable (i.e., target vs. source; see Chapter 1), this error condition will be handled differently.\n\nUndefined Mess\n\nIf the variable is a source, an unresolved identifier lookup is considered an undeclared (unknown, missing) variable, which always results in a ReferenceError being thrown. Also, if the variable is a target, and the code at that moment is running in strict-mode, the variable is considered undeclared and similarly throws a ReferenceError.\n\nThe error message for an undeclared variable condition, in most JS environments, will look like, \"Reference Error: XYZ is not defined.\" The phrase \"not defined\" seems almost identical to the word \"undefined,\" as far as the English language goes. But these two are very different in JS, and this error message unfortunately creates a persistent confusion.\n\n\"Not defined\" really means \"not declared\"\u2014or, rather, \"undeclared,\" as in a variable that has no matching formal declaration in any lexically available scope. By contrast, \"undefined\" really means a variable was found (declared), but the variable otherwise has no other value in it at the moment, so it defaults to the undefined value.\n\nTo perpetuate the confusion even further, JS's typeof operator returns the string \"undefined\" for variable references in either state:\n\nvar studentName;\ntypeof studentName;     // \"undefined\"\n\ntypeof doesntExist;     // \"undefined\"\n\nThese two variable references are in very different conditions, but JS sure does muddy the waters. The terminology mess is confusing and terribly unfortunate. Unfortunately, JS developers just have to pay close attention to not mix up which kind of \"undefined\" they're dealing with!\n\nGlobal... What!?\n\nIf the variable is a target and strict-mode is not in effect, a confusing and surprising legacy behavior kicks in. The troublesome outcome is that the global scope's Scope Manager will just create an accidental global variable to fulfill that target assignment!\n\nConsider:\n\nfunction getStudentName() {\n    // assignment to an undeclared variable :(\n    nextStudent = \"Suzy\";\n}\n\ngetStudentName();\n\nconsole.log(nextStudent);\n// \"Suzy\" -- oops, an accidental-global variable!\n\nHere's how that conversation will proceed:\n\nEngine: Hey, Scope Manager (for the function), I have a target reference for nextStudent, ever heard of it?\n\n(Function) Scope Manager: Nope, never heard of it. Try the next outer scope.\n\nEngine: Hey, Scope Manager (for the global scope), I have a target reference for nextStudent, ever heard of it?\n\n(Global) Scope Manager: Nope, but since we're in non-strict-mode, I helped you out and just created a global variable for you, here it is!\n\nYuck.\n\nThis sort of accident (almost certain to lead to bugs eventually) is a great example of the beneficial protections offered by strict-mode, and why it's such a bad idea not to be using strict-mode. In strict-mode, the Global Scope Manager would instead have responded:\n\n(Global) Scope Manager: Nope, never heard of it. Sorry, I've got to throw a ReferenceError.\n\nAssigning to a never-declared variable is an error, so it's right that we would receive a ReferenceError here.\n\nNever rely on accidental global variables. Always use strict-mode, and always formally declare your variables. You'll then get a helpful ReferenceError if you ever mistakenly try to assign to a not-declared variable."}, "id": 179}, {"data": {"uuid": "33423ce7-0eb7-4d1b-aa1a-a4f39ea72acb", "user": 1, "title": "Building On Metaphors", "author": "Kyle Simpson", "created_on": "2023-06-09 00:56:03.176694+00:00", "updated_on": "2023-06-09 00:56:38.235349+00:00", "article_html": "<h3>Building On Metaphors</h3><p>To visualize nested scope resolution, I prefer yet another metaphor, an office building, as in Figure 3:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig3.png\"><p><em>Fig. 3: Scope \"Building\"</em></p><p>The building represents our program's nested scope collection. The first floor of the building represents the currently executing scope. The top level of the building is the global scope.</p><p>You resolve a <em>target</em> or <em>source</em> variable reference by first looking on the current floor, and if you don't find it, taking the elevator to the next floor (i.e., an outer scope), looking there, then the next, and so on. Once you get to the top floor (the global scope), you either find what you're looking for, or you don't. But you have to stop regardless.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Building On Metaphors", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To visualize nested scope resolution, I prefer yet another metaphor, an office building, as in Figure 3:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig3.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 3: Scope \"Building\"", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "paragraph", "content": [{"text": "The building represents our program's nested scope collection. The first floor of the building represents the currently executing scope. The top level of the building is the global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You resolve a ", "type": "text"}, {"text": "target", "type": "text", "marks": [{"type": "italic"}]}, {"text": " or ", "type": "text"}, {"text": "source", "type": "text", "marks": [{"type": "italic"}]}, {"text": " variable reference by first looking on the current floor, and if you don't find it, taking the elevator to the next floor (i.e., an outer scope), looking there, then the next, and so on. Once you get to the top floor (the global scope), you either find what you're looking for, or you don't. But you have to stop regardless.", "type": "text"}]}]}, "article_text": "Building On Metaphors\n\nTo visualize nested scope resolution, I prefer yet another metaphor, an office building, as in Figure 3:\n\nFig. 3: Scope \"Building\"\n\nThe building represents our program's nested scope collection. The first floor of the building represents the currently executing scope. The top level of the building is the global scope.\n\nYou resolve a target or source variable reference by first looking on the current floor, and if you don't find it, taking the elevator to the next floor (i.e., an outer scope), looking there, then the next, and so on. Once you get to the top floor (the global scope), you either find what you're looking for, or you don't. But you have to stop regardless."}, "id": 180}]}, {"data": {"uuid": "8acd1546-e712-4c12-a147-37f096ee21ab", "user": 1, "title": "Continue the Conversation", "author": "Kyle Simpson", "created_on": "2023-06-09 00:57:31.094389+00:00", "updated_on": "2023-06-09 00:57:46.592402+00:00", "article_html": "<h2>Continue the Conversation</h2><p>By this point, you should be developing richer mental models for what scope is and how the JS engine determines and uses it from your code.</p><p>Before <em>continuing</em>, go find some code in one of your projects and run through these conversations. Seriously, actually speak out loud. Find a friend and practice each role with them. If either of you find yourself confused or tripped up, spend more time reviewing this material.</p><p>As we move (up) to the next (outer) chapter, we'll explore how the lexical scopes of a program are connected in a chain.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Continue the Conversation", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By this point, you should be developing richer mental models for what scope is and how the JS engine determines and uses it from your code.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Before ", "type": "text"}, {"text": "continuing", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", go find some code in one of your projects and run through these conversations. Seriously, actually speak out loud. Find a friend and practice each role with them. If either of you find yourself confused or tripped up, spend more time reviewing this material.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As we move (up) to the next (outer) chapter, we'll explore how the lexical scopes of a program are connected in a chain.", "type": "text"}]}]}, "article_text": "Continue the Conversation\n\nBy this point, you should be developing richer mental models for what scope is and how the JS engine determines and uses it from your code.\n\nBefore continuing, go find some code in one of your projects and run through these conversations. Seriously, actually speak out loud. Find a friend and practice each role with them. If either of you find yourself confused or tripped up, spend more time reviewing this material.\n\nAs we move (up) to the next (outer) chapter, we'll explore how the lexical scopes of a program are connected in a chain."}, "id": 181}]}, {"data": {"uuid": "ff0107e0-cc77-426f-9857-e102c175948f", "user": 1, "title": "Chapter 3: The Scope Chain", "author": "Kyle Simpson", "created_on": "2023-06-09 00:58:26.353921+00:00", "updated_on": "2023-06-09 00:59:04.983473+00:00", "article_html": "<h1>Chapter 3: The Scope Chain</h1><p>Chapters 1 and 2 laid down a concrete definition of <em>lexical scope</em> (and its parts) and illustrated helpful metaphors for its conceptual foundation. Before proceeding with this chapter, find someone else to explain (written or aloud), in your own words, what lexical scope is and why it's useful to understand.</p><p>That seems like a step you might skip, but I've found it really does help to take the time to reformulate these ideas as explanations to others. That helps our brains digest what we're learning!</p><p>Now it's time to dig into the nuts and bolts, so expect that things will get a lot more detailed from here forward. Stick with it, though, because these discussions really hammer home just how much we all <em>don't know</em> about scope, yet. Make sure to take your time with the text and all the code snippets provided.</p><p>To refresh the context of our running example, let's recall the color-coded illustration of the nested scope bubbles, from Chapter 2, Figure 2:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig2.png\"><p><em>Fig. 2 (Ch. 2): Colored Scope Bubbles</em></p><p>The connections between scopes that are nested within other scopes is called the scope chain, which determines the path along which variables can be accessed. The chain is directed, meaning the lookup moves upward/outward only.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 3: The Scope Chain", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Chapters 1 and 2 laid down a concrete definition of ", "type": "text"}, {"text": "lexical scope", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (and its parts) and illustrated helpful metaphors for its conceptual foundation. Before proceeding with this chapter, find someone else to explain (written or aloud), in your own words, what lexical scope is and why it's useful to understand.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That seems like a step you might skip, but I've found it really does help to take the time to reformulate these ideas as explanations to others. That helps our brains digest what we're learning!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now it's time to dig into the nuts and bolts, so expect that things will get a lot more detailed from here forward. Stick with it, though, because these discussions really hammer home just how much we all ", "type": "text"}, {"text": "don't know", "type": "text", "marks": [{"type": "italic"}]}, {"text": " about scope, yet. Make sure to take your time with the text and all the code snippets provided.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To refresh the context of our running example, let's recall the color-coded illustration of the nested scope bubbles, from Chapter 2, Figure 2:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig2.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 2 (Ch. 2): Colored Scope Bubbles", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "paragraph", "content": [{"text": "The connections between scopes that are nested within other scopes is called the scope chain, which determines the path along which variables can be accessed. The chain is directed, meaning the lookup moves upward/outward only.", "type": "text"}]}]}, "article_text": "Chapter 3: The Scope Chain\n\nChapters 1 and 2 laid down a concrete definition of lexical scope (and its parts) and illustrated helpful metaphors for its conceptual foundation. Before proceeding with this chapter, find someone else to explain (written or aloud), in your own words, what lexical scope is and why it's useful to understand.\n\nThat seems like a step you might skip, but I've found it really does help to take the time to reformulate these ideas as explanations to others. That helps our brains digest what we're learning!\n\nNow it's time to dig into the nuts and bolts, so expect that things will get a lot more detailed from here forward. Stick with it, though, because these discussions really hammer home just how much we all don't know about scope, yet. Make sure to take your time with the text and all the code snippets provided.\n\nTo refresh the context of our running example, let's recall the color-coded illustration of the nested scope bubbles, from Chapter 2, Figure 2:\n\nFig. 2 (Ch. 2): Colored Scope Bubbles\n\nThe connections between scopes that are nested within other scopes is called the scope chain, which determines the path along which variables can be accessed. The chain is directed, meaning the lookup moves upward/outward only."}, "id": 182, "children": [{"data": {"uuid": "5224cbe2-4e9f-4bcd-a7b1-dfdf99f7c087", "user": 1, "title": "\"Lookup\" Is (Mostly) Conceptual", "author": "Kyle Simpson", "created_on": "2023-06-09 00:59:16.316596+00:00", "updated_on": "2023-06-09 01:01:10.073922+00:00", "article_html": "<h2>\"Lookup\" Is (Mostly) Conceptual</h2><p>In Figure 2, notice the color of the <code>students</code> variable reference in the <code>for</code>-loop. How exactly did we determine that it's a RED(1) marble?</p><p>In Chapter 2, we described the runtime access of a variable as a \"lookup,\" where the <em>Engine</em> has to start by asking the current scope's <em>Scope Manager</em> if it knows about an identifier/variable, and proceeding upward/outward back through the chain of nested scopes (toward the global scope) until found, if ever. The lookup stops as soon as the first matching named declaration in a scope bucket is found.</p><p>The lookup process thus determined that <code>students</code> is a RED(1) marble, because we had not yet found a matching variable name as we traversed the scope chain, until we arrived at the final RED(1) global scope.</p><p>Similarly, <code>studentID</code> in the <code>if</code>-statement is determined to be a BLUE(2) marble.</p><p>This suggestion of a runtime lookup process works well for conceptual understanding, but it's not actually how things usually work in practice.</p><p>The color of a marble's bucket (aka, meta information of what scope a variable originates from) is <em>usually determined</em> during the initial compilation processing. Because lexical scope is pretty much finalized at that point, a marble's color will not change based on anything that can happen later during runtime.</p><p>Since the marble's color is known from compilation, and it's immutable, this information would likely be stored with (or at least accessible from) each variable's entry in the AST; that information is then used explicitly by the executable instructions that constitute the program's runtime.</p><p>In other words, <em>Engine</em> (from Chapter 2) doesn't need to lookup through a bunch of scopes to figure out which scope bucket a variable comes from. That information is already known! Avoiding the need for a runtime lookup is a key optimization benefit of lexical scope. The runtime operates more performantly without spending time on all these lookups.</p><p>But I said \"...usually determined...\" just a moment ago, with respect to figuring out a marble's color during compilation. So in what case would it ever <em>not</em> be known during compilation?</p><p>Consider a reference to a variable that isn't declared in any lexically available scopes in the current file\u2014see <em>Get Started</em>, Chapter 1, which asserts that each file is its own separate program from the perspective of JS compilation. If no declaration is found, that's not <em>necessarily</em> an error. Another file (program) in the runtime may indeed declare that variable in the shared global scope.</p><p>So the ultimate determination of whether the variable was ever appropriately declared in some accessible bucket may need to be deferred to the runtime.</p><p>Any reference to a variable that's initially <em>undeclared</em> is left as an uncolored marble during that file's compilation; this color cannot be determined until other relevant file(s) have been compiled and the application runtime commences. That deferred lookup will eventually resolve the color to whichever scope the variable is found in (likely the global scope).</p><p>However, this lookup would only be needed once per variable at most, since nothing else during runtime could later change that marble's color.</p><p>The \"Lookup Failures\" section in Chapter 2 covers what happens if a marble is ultimately still uncolored at the moment its reference is runtime executed.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "\"Lookup\" Is (Mostly) Conceptual", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Figure 2, notice the color of the ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable reference in the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop. How exactly did we determine that it's a RED(1) marble?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Chapter 2, we described the runtime access of a variable as a \"lookup,\" where the ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " has to start by asking the current scope's ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if it knows about an identifier/variable, and proceeding upward/outward back through the chain of nested scopes (toward the global scope) until found, if ever. The lookup stops as soon as the first matching named declaration in a scope bucket is found.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The lookup process thus determined that ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a RED(1) marble, because we had not yet found a matching variable name as we traversed the scope chain, until we arrived at the final RED(1) global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Similarly, ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": "-statement is determined to be a BLUE(2) marble.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This suggestion of a runtime lookup process works well for conceptual understanding, but it's not actually how things usually work in practice.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The color of a marble's bucket (aka, meta information of what scope a variable originates from) is ", "type": "text"}, {"text": "usually determined", "type": "text", "marks": [{"type": "italic"}]}, {"text": " during the initial compilation processing. Because lexical scope is pretty much finalized at that point, a marble's color will not change based on anything that can happen later during runtime.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since the marble's color is known from compilation, and it's immutable, this information would likely be stored with (or at least accessible from) each variable's entry in the AST; that information is then used explicitly by the executable instructions that constitute the program's runtime.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, ", "type": "text"}, {"text": "Engine", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (from Chapter 2) doesn't need to lookup through a bunch of scopes to figure out which scope bucket a variable comes from. That information is already known! Avoiding the need for a runtime lookup is a key optimization benefit of lexical scope. The runtime operates more performantly without spending time on all these lookups.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I said \"...usually determined...\" just a moment ago, with respect to figuring out a marble's color during compilation. So in what case would it ever ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " be known during compilation?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider a reference to a variable that isn't declared in any lexically available scopes in the current file\u2014see ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", Chapter 1, which asserts that each file is its own separate program from the perspective of JS compilation. If no declaration is found, that's not ", "type": "text"}, {"text": "necessarily", "type": "text", "marks": [{"type": "italic"}]}, {"text": " an error. Another file (program) in the runtime may indeed declare that variable in the shared global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So the ultimate determination of whether the variable was ever appropriately declared in some accessible bucket may need to be deferred to the runtime.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Any reference to a variable that's initially ", "type": "text"}, {"text": "undeclared", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is left as an uncolored marble during that file's compilation; this color cannot be determined until other relevant file(s) have been compiled and the application runtime commences. That deferred lookup will eventually resolve the color to whichever scope the variable is found in (likely the global scope).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However, this lookup would only be needed once per variable at most, since nothing else during runtime could later change that marble's color.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The \"Lookup Failures\" section in Chapter 2 covers what happens if a marble is ultimately still uncolored at the moment its reference is runtime executed.", "type": "text"}]}]}, "article_text": "\"Lookup\" Is (Mostly) Conceptual\n\nIn Figure 2, notice the color of the students variable reference in the for-loop. How exactly did we determine that it's a RED(1) marble?\n\nIn Chapter 2, we described the runtime access of a variable as a \"lookup,\" where the Engine has to start by asking the current scope's Scope Manager if it knows about an identifier/variable, and proceeding upward/outward back through the chain of nested scopes (toward the global scope) until found, if ever. The lookup stops as soon as the first matching named declaration in a scope bucket is found.\n\nThe lookup process thus determined that students is a RED(1) marble, because we had not yet found a matching variable name as we traversed the scope chain, until we arrived at the final RED(1) global scope.\n\nSimilarly, studentID in the if-statement is determined to be a BLUE(2) marble.\n\nThis suggestion of a runtime lookup process works well for conceptual understanding, but it's not actually how things usually work in practice.\n\nThe color of a marble's bucket (aka, meta information of what scope a variable originates from) is usually determined during the initial compilation processing. Because lexical scope is pretty much finalized at that point, a marble's color will not change based on anything that can happen later during runtime.\n\nSince the marble's color is known from compilation, and it's immutable, this information would likely be stored with (or at least accessible from) each variable's entry in the AST; that information is then used explicitly by the executable instructions that constitute the program's runtime.\n\nIn other words, Engine (from Chapter 2) doesn't need to lookup through a bunch of scopes to figure out which scope bucket a variable comes from. That information is already known! Avoiding the need for a runtime lookup is a key optimization benefit of lexical scope. The runtime operates more performantly without spending time on all these lookups.\n\nBut I said \"...usually determined...\" just a moment ago, with respect to figuring out a marble's color during compilation. So in what case would it ever not be known during compilation?\n\nConsider a reference to a variable that isn't declared in any lexically available scopes in the current file\u2014see Get Started, Chapter 1, which asserts that each file is its own separate program from the perspective of JS compilation. If no declaration is found, that's not necessarily an error. Another file (program) in the runtime may indeed declare that variable in the shared global scope.\n\nSo the ultimate determination of whether the variable was ever appropriately declared in some accessible bucket may need to be deferred to the runtime.\n\nAny reference to a variable that's initially undeclared is left as an uncolored marble during that file's compilation; this color cannot be determined until other relevant file(s) have been compiled and the application runtime commences. That deferred lookup will eventually resolve the color to whichever scope the variable is found in (likely the global scope).\n\nHowever, this lookup would only be needed once per variable at most, since nothing else during runtime could later change that marble's color.\n\nThe \"Lookup Failures\" section in Chapter 2 covers what happens if a marble is ultimately still uncolored at the moment its reference is runtime executed."}, "id": 183}, {"data": {"uuid": "b86bcc96-1fff-4377-b4d9-5a88967a08ca", "user": 1, "title": "Shadowing", "author": "Kyle Simpson", "created_on": "2023-06-09 01:01:29.518800+00:00", "updated_on": "2023-06-09 01:01:52.104504+00:00", "article_html": "<h2>Shadowing</h2><p>\"Shadowing\" might sound mysterious and a little bit sketchy. But don't worry, it's completely legit!</p><p>Our running example for these chapters uses different variable names across the scope boundaries. Since they all have unique names, in a way it wouldn't matter if all of them were just stored in one bucket (like RED(1)).</p><p>Where having different lexical scope buckets starts to matter more is when you have two or more variables, each in different scopes, with the same lexical names. A single scope cannot have two or more variables with the same name; such multiple references would be assumed as just one variable.</p><p>So if you need to maintain two or more variables of the same name, you must use separate (often nested) scopes. And in that case, it's very relevant how the different scope buckets are laid out.</p><p>Consider:</p><pre><code>var studentName = \"Suzy\";\n\nfunction printStudent(studentName) {\n    studentName = studentName.toUpperCase();\n    console.log(studentName);\n}\n\nprintStudent(\"Frank\");\n// FRANK\n\nprintStudent(studentName);\n// SUZY\n\nconsole.log(studentName);\n// Suzy</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Before you move on, take some time to analyze this code using the various techniques/metaphors we've covered in the book. In particular, make sure to identify the marble/bubble colors in this snippet. It's good practice!</p></td></tr></tbody></table><p>The <code>studentName</code> variable on line 1 (the <code>var studentName = ..</code> statement) creates a RED(1) marble. The same named variable is declared as a BLUE(2) marble on line 3, the parameter in the <code>printStudent(..)</code> function definition.</p><p>What color marble will <code>studentName</code> be in the <code>studentName = studentName.toUpperCase()</code> assignment statement and the <code>console.log(studentName)</code> statement? All three <code>studentName</code> references will be BLUE(2).</p><p>With the conceptual notion of the \"lookup,\" we asserted that it starts with the current scope and works its way outward/upward, stopping as soon as a matching variable is found. The BLUE(2) <code>studentName</code> is found right away. The RED(1) <code>studentName</code> is never even considered.</p><p>This is a key aspect of lexical scope behavior, called <em>shadowing</em>. The BLUE(2) <code>studentName</code> variable (parameter) shadows the RED(1) <code>studentName</code>. So, the parameter is shadowing the (shadowed) global variable. Repeat that sentence to yourself a few times to make sure you have the terminology straight!</p><p>That's why the re-assignment of <code>studentName</code> affects only the inner (parameter) variable: the BLUE(2) <code>studentName</code>, not the global RED(1) <code>studentName</code>.</p><p>When you choose to shadow a variable from an outer scope, one direct impact is that from that scope inward/downward (through any nested scopes) it's now impossible for any marble to be colored as the shadowed variable\u2014(RED(1), in this case). In other words, any <code>studentName</code> identifier reference will correspond to that parameter variable, never the global <code>studentName</code> variable. It's lexically impossible to reference the global <code>studentName</code> anywhere inside of the <code>printStudent(..)</code> function (or from any nested scopes).</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Shadowing", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "\"Shadowing\" might sound mysterious and a little bit sketchy. But don't worry, it's completely legit!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Our running example for these chapters uses different variable names across the scope boundaries. Since they all have unique names, in a way it wouldn't matter if all of them were just stored in one bucket (like RED(1)).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Where having different lexical scope buckets starts to matter more is when you have two or more variables, each in different scopes, with the same lexical names. A single scope cannot have two or more variables with the same name; such multiple references would be assumed as just one variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So if you need to maintain two or more variables of the same name, you must use separate (often nested) scopes. And in that case, it's very relevant how the different scope buckets are laid out.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Suzy\";\n\nfunction printStudent(studentName) {\n    studentName = studentName.toUpperCase();\n    console.log(studentName);\n}\n\nprintStudent(\"Frank\");\n// FRANK\n\nprintStudent(studentName);\n// SUZY\n\nconsole.log(studentName);\n// Suzy", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Before you move on, take some time to analyze this code using the various techniques/metaphors we've covered in the book. In particular, make sure to identify the marble/bubble colors in this snippet. It's good practice!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable on line 1 (the ", "type": "text"}, {"text": "var studentName = ..", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement) creates a RED(1) marble. The same named variable is declared as a BLUE(2) marble on line 3, the parameter in the ", "type": "text"}, {"text": "printStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function definition.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What color marble will ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " be in the ", "type": "text"}, {"text": "studentName = studentName.toUpperCase()", "type": "text", "marks": [{"type": "code"}]}, {"text": " assignment statement and the ", "type": "text"}, {"text": "console.log(studentName)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement? All three ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " references will be BLUE(2).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With the conceptual notion of the \"lookup,\" we asserted that it starts with the current scope and works its way outward/upward, stopping as soon as a matching variable is found. The BLUE(2) ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is found right away. The RED(1) ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is never even considered.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is a key aspect of lexical scope behavior, called ", "type": "text"}, {"text": "shadowing", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". The BLUE(2) ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable (parameter) shadows the RED(1) ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ". So, the parameter is shadowing the (shadowed) global variable. Repeat that sentence to yourself a few times to make sure you have the terminology straight!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's why the re-assignment of ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " affects only the inner (parameter) variable: the BLUE(2) ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ", not the global RED(1) ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When you choose to shadow a variable from an outer scope, one direct impact is that from that scope inward/downward (through any nested scopes) it's now impossible for any marble to be colored as the shadowed variable\u2014(RED(1), in this case). In other words, any ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier reference will correspond to that parameter variable, never the global ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable. It's lexically impossible to reference the global ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " anywhere inside of the ", "type": "text"}, {"text": "printStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function (or from any nested scopes).", "type": "text"}]}]}, "article_text": "Shadowing\n\n\"Shadowing\" might sound mysterious and a little bit sketchy. But don't worry, it's completely legit!\n\nOur running example for these chapters uses different variable names across the scope boundaries. Since they all have unique names, in a way it wouldn't matter if all of them were just stored in one bucket (like RED(1)).\n\nWhere having different lexical scope buckets starts to matter more is when you have two or more variables, each in different scopes, with the same lexical names. A single scope cannot have two or more variables with the same name; such multiple references would be assumed as just one variable.\n\nSo if you need to maintain two or more variables of the same name, you must use separate (often nested) scopes. And in that case, it's very relevant how the different scope buckets are laid out.\n\nConsider:\n\nvar studentName = \"Suzy\";\n\nfunction printStudent(studentName) {\n    studentName = studentName.toUpperCase();\n    console.log(studentName);\n}\n\nprintStudent(\"Frank\");\n// FRANK\n\nprintStudent(studentName);\n// SUZY\n\nconsole.log(studentName);\n// Suzy\n\nTIP:\n\nBefore you move on, take some time to analyze this code using the various techniques/metaphors we've covered in the book. In particular, make sure to identify the marble/bubble colors in this snippet. It's good practice!\n\nThe studentName variable on line 1 (the var studentName = .. statement) creates a RED(1) marble. The same named variable is declared as a BLUE(2) marble on line 3, the parameter in the printStudent(..) function definition.\n\nWhat color marble will studentName be in the studentName = studentName.toUpperCase() assignment statement and the console.log(studentName) statement? All three studentName references will be BLUE(2).\n\nWith the conceptual notion of the \"lookup,\" we asserted that it starts with the current scope and works its way outward/upward, stopping as soon as a matching variable is found. The BLUE(2) studentName is found right away. The RED(1) studentName is never even considered.\n\nThis is a key aspect of lexical scope behavior, called shadowing. The BLUE(2) studentName variable (parameter) shadows the RED(1) studentName. So, the parameter is shadowing the (shadowed) global variable. Repeat that sentence to yourself a few times to make sure you have the terminology straight!\n\nThat's why the re-assignment of studentName affects only the inner (parameter) variable: the BLUE(2) studentName, not the global RED(1) studentName.\n\nWhen you choose to shadow a variable from an outer scope, one direct impact is that from that scope inward/downward (through any nested scopes) it's now impossible for any marble to be colored as the shadowed variable\u2014(RED(1), in this case). In other words, any studentName identifier reference will correspond to that parameter variable, never the global studentName variable. It's lexically impossible to reference the global studentName anywhere inside of the printStudent(..) function (or from any nested scopes)."}, "id": 184, "children": [{"data": {"uuid": "229dff30-ed1e-4dea-a4d9-deabf7fc8e43", "user": 1, "title": "Global Unshadowing Trick", "author": "Kyle Simpson", "created_on": "2023-06-09 01:02:10.833219+00:00", "updated_on": "2023-06-09 01:02:42.655875+00:00", "article_html": "<h3>Global Unshadowing Trick</h3><p>Please beware: leveraging the technique I'm about to describe is not very good practice, as it's limited in utility, confusing for readers of your code, and likely to invite bugs to your program. I'm covering it only because you may run across this behavior in existing programs, and understanding what's happening is critical to not getting tripped up.</p><p>It <em>is</em> possible to access a global variable from a scope where that variable has been shadowed, but not through a typical lexical identifier reference.</p><p>In the global scope (RED(1)), <code>var</code> declarations and <code>function</code> declarations also expose themselves as properties (of the same name as the identifier) on the <em>global object</em>\u2014essentially an object representation of the global scope. If you've written JS for a browser environment, you probably recognize the global object as <code>window</code>. That's not <em>entirely</em> accurate, but it's good enough for our discussion. In the next chapter, we'll explore the global scope/object topic more.</p><p>Consider this program, specifically executed as a standalone .js file in a browser environment:</p><pre><code>var studentName = \"Suzy\";\n\nfunction printStudent(studentName) {\n    console.log(studentName);\n    console.log(window.studentName);\n}\n\nprintStudent(\"Frank\");\n// \"Frank\"\n// \"Suzy\"</code></pre><p>Notice the <code>window.studentName</code> reference? This expression is accessing the global variable <code>studentName</code> as a property on <code>window</code> (which we're pretending for now is synonymous with the global object). That's the only way to access a shadowed variable from inside a scope where the shadowing variable is present.</p><p>The <code>window.studentName</code> is a mirror of the global <code>studentName</code> variable, not a separate snapshot copy. Changes to one are still seen from the other, in either direction. You can think of <code>window.studentName</code> as a getter/setter that accesses the actual <code>studentName</code> variable. As a matter of fact, you can even <em>add</em> a variable to the global scope by creating/setting a property on the global object.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Remember: just because you <em>can</em> doesn't mean you <em>should</em>. Don't shadow a global variable that you need to access, and conversely, avoid using this trick to access a global variable that you've shadowed. And definitely don't confuse readers of your code by creating global variables as <code>window</code> properties instead of with formal declarations!</p></td></tr></tbody></table><p>This little \"trick\" only works for accessing a global scope variable (not a shadowed variable from a nested scope), and even then, only one that was declared with <code>var</code> or <code>function</code>.</p><p>Other forms of global scope declarations do not create mirrored global object properties:</p><pre><code>var one = 1;\nlet notOne = 2;\nconst notTwo = 3;\nclass notThree {}\n\nconsole.log(window.one);       // 1\nconsole.log(window.notOne);    // undefined\nconsole.log(window.notTwo);    // undefined\nconsole.log(window.notThree);  // undefined</code></pre><p>Variables (no matter how they're declared!) that exist in any other scope than the global scope are completely inaccessible from a scope where they've been shadowed:</p><pre><code>var special = 42;\n\nfunction lookingFor(special) {\n    // The identifier `special` (parameter) in this\n    // scope is shadowed inside keepLooking(), and\n    // is thus inaccessible from that scope.\n\n    function keepLooking() {\n        var special = 3.141592;\n        console.log(special);\n        console.log(window.special);\n    }\n\n    keepLooking();\n}\n\nlookingFor(112358132134);\n// 3.141592\n// 42</code></pre><p>The global RED(1) <code>special</code> is shadowed by the BLUE(2) <code>special</code> (parameter), and the BLUE(2) <code>special</code> is itself shadowed by the GREEN(3) <code>special</code> inside <code>keepLooking()</code>. We can still access the RED(1) <code>special</code> using the indirect reference <code>window.special</code>. But there's no way for <code>keepLooking()</code> to access the BLUE(2) <code>special</code> that holds the number <code>112358132134</code>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Global Unshadowing Trick", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Please beware: leveraging the technique I'm about to describe is not very good practice, as it's limited in utility, confusing for readers of your code, and likely to invite bugs to your program. I'm covering it only because you may run across this behavior in existing programs, and understanding what's happening is critical to not getting tripped up.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " possible to access a global variable from a scope where that variable has been shadowed, but not through a typical lexical identifier reference.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the global scope (RED(1)), ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations and ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations also expose themselves as properties (of the same name as the identifier) on the ", "type": "text"}, {"text": "global object", "type": "text", "marks": [{"type": "italic"}]}, {"text": "\u2014essentially an object representation of the global scope. If you've written JS for a browser environment, you probably recognize the global object as ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": ". That's not ", "type": "text"}, {"text": "entirely", "type": "text", "marks": [{"type": "italic"}]}, {"text": " accurate, but it's good enough for our discussion. In the next chapter, we'll explore the global scope/object topic more.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider this program, specifically executed as a standalone .js file in a browser environment:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Suzy\";\n\nfunction printStudent(studentName) {\n    console.log(studentName);\n    console.log(window.studentName);\n}\n\nprintStudent(\"Frank\");\n// \"Frank\"\n// \"Suzy\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice the ", "type": "text"}, {"text": "window.studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " reference? This expression is accessing the global variable ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a property on ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " (which we're pretending for now is synonymous with the global object). That's the only way to access a shadowed variable from inside a scope where the shadowing variable is present.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "window.studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a mirror of the global ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable, not a separate snapshot copy. Changes to one are still seen from the other, in either direction. You can think of ", "type": "text"}, {"text": "window.studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a getter/setter that accesses the actual ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable. As a matter of fact, you can even ", "type": "text"}, {"text": "add", "type": "text", "marks": [{"type": "italic"}]}, {"text": " a variable to the global scope by creating/setting a property on the global object.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Remember: just because you ", "type": "text"}, {"text": "can", "type": "text", "marks": [{"type": "italic"}]}, {"text": " doesn't mean you ", "type": "text"}, {"text": "should", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Don't shadow a global variable that you need to access, and conversely, avoid using this trick to access a global variable that you've shadowed. And definitely don't confuse readers of your code by creating global variables as ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " properties instead of with formal declarations!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "This little \"trick\" only works for accessing a global scope variable (not a shadowed variable from a nested scope), and even then, only one that was declared with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Other forms of global scope declarations do not create mirrored global object properties:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var one = 1;\nlet notOne = 2;\nconst notTwo = 3;\nclass notThree {}\n\nconsole.log(window.one);       // 1\nconsole.log(window.notOne);    // undefined\nconsole.log(window.notTwo);    // undefined\nconsole.log(window.notThree);  // undefined", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Variables (no matter how they're declared!) that exist in any other scope than the global scope are completely inaccessible from a scope where they've been shadowed:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var special = 42;\n\nfunction lookingFor(special) {\n    // The identifier `special` (parameter) in this\n    // scope is shadowed inside keepLooking(), and\n    // is thus inaccessible from that scope.\n\n    function keepLooking() {\n        var special = 3.141592;\n        console.log(special);\n        console.log(window.special);\n    }\n\n    keepLooking();\n}\n\nlookingFor(112358132134);\n// 3.141592\n// 42", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The global RED(1) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " is shadowed by the BLUE(2) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " (parameter), and the BLUE(2) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " is itself shadowed by the GREEN(3) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside ", "type": "text"}, {"text": "keepLooking()", "type": "text", "marks": [{"type": "code"}]}, {"text": ". We can still access the RED(1) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " using the indirect reference ", "type": "text"}, {"text": "window.special", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But there's no way for ", "type": "text"}, {"text": "keepLooking()", "type": "text", "marks": [{"type": "code"}]}, {"text": " to access the BLUE(2) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " that holds the number ", "type": "text"}, {"text": "112358132134", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Global Unshadowing Trick\n\nPlease beware: leveraging the technique I'm about to describe is not very good practice, as it's limited in utility, confusing for readers of your code, and likely to invite bugs to your program. I'm covering it only because you may run across this behavior in existing programs, and understanding what's happening is critical to not getting tripped up.\n\nIt is possible to access a global variable from a scope where that variable has been shadowed, but not through a typical lexical identifier reference.\n\nIn the global scope (RED(1)), var declarations and function declarations also expose themselves as properties (of the same name as the identifier) on the global object\u2014essentially an object representation of the global scope. If you've written JS for a browser environment, you probably recognize the global object as window. That's not entirely accurate, but it's good enough for our discussion. In the next chapter, we'll explore the global scope/object topic more.\n\nConsider this program, specifically executed as a standalone .js file in a browser environment:\n\nvar studentName = \"Suzy\";\n\nfunction printStudent(studentName) {\n    console.log(studentName);\n    console.log(window.studentName);\n}\n\nprintStudent(\"Frank\");\n// \"Frank\"\n// \"Suzy\"\n\nNotice the window.studentName reference? This expression is accessing the global variable studentName as a property on window (which we're pretending for now is synonymous with the global object). That's the only way to access a shadowed variable from inside a scope where the shadowing variable is present.\n\nThe window.studentName is a mirror of the global studentName variable, not a separate snapshot copy. Changes to one are still seen from the other, in either direction. You can think of window.studentName as a getter/setter that accesses the actual studentName variable. As a matter of fact, you can even add a variable to the global scope by creating/setting a property on the global object.\n\nWARNING:\n\nRemember: just because you can doesn't mean you should. Don't shadow a global variable that you need to access, and conversely, avoid using this trick to access a global variable that you've shadowed. And definitely don't confuse readers of your code by creating global variables as window properties instead of with formal declarations!\n\nThis little \"trick\" only works for accessing a global scope variable (not a shadowed variable from a nested scope), and even then, only one that was declared with var or function.\n\nOther forms of global scope declarations do not create mirrored global object properties:\n\nvar one = 1;\nlet notOne = 2;\nconst notTwo = 3;\nclass notThree {}\n\nconsole.log(window.one);       // 1\nconsole.log(window.notOne);    // undefined\nconsole.log(window.notTwo);    // undefined\nconsole.log(window.notThree);  // undefined\n\nVariables (no matter how they're declared!) that exist in any other scope than the global scope are completely inaccessible from a scope where they've been shadowed:\n\nvar special = 42;\n\nfunction lookingFor(special) {\n    // The identifier `special` (parameter) in this\n    // scope is shadowed inside keepLooking(), and\n    // is thus inaccessible from that scope.\n\n    function keepLooking() {\n        var special = 3.141592;\n        console.log(special);\n        console.log(window.special);\n    }\n\n    keepLooking();\n}\n\nlookingFor(112358132134);\n// 3.141592\n// 42\n\nThe global RED(1) special is shadowed by the BLUE(2) special (parameter), and the BLUE(2) special is itself shadowed by the GREEN(3) special inside keepLooking(). We can still access the RED(1) special using the indirect reference window.special. But there's no way for keepLooking() to access the BLUE(2) special that holds the number 112358132134."}, "id": 185}, {"data": {"uuid": "bbf497eb-22b3-49de-a30d-7fd9d6b0a0e3", "user": 1, "title": "Copying Is Not Accessing", "author": "Kyle Simpson", "created_on": "2023-06-09 01:02:57.428412+00:00", "updated_on": "2023-06-09 01:03:21.939739+00:00", "article_html": "<h3>Copying Is Not Accessing</h3><p>I've been asked the following \"But what about...?\" question dozens of times. Consider:</p><pre><code>var special = 42;\n\nfunction lookingFor(special) {\n    var another = {\n        special: special\n    };\n\n    function keepLooking() {\n        var special = 3.141592;\n        console.log(special);\n        console.log(another.special);  // Ooo, tricky!\n        console.log(window.special);\n    }\n\n    keepLooking();\n}\n\nlookingFor(112358132134);\n// 3.141592\n// 112358132134\n// 42</code></pre><p>Oh! So does this <code>another</code> object technique disprove my claim that the <code>special</code> parameter is \"completely inaccessible\" from inside <code>keepLooking()</code>? No, the claim is still correct.</p><p><code>special: special</code> is copying the value of the <code>special</code> parameter variable into another container (a property of the same name). Of course, if you put a value in another container, shadowing no longer applies (unless <code>another</code> was shadowed, too!). But that doesn't mean we're accessing the parameter <code>special</code>; it means we're accessing the copy of the value it had at that moment, by way of <em>another</em> container (object property). We cannot reassign the BLUE(2) <code>special</code> parameter to a different value from inside <code>keepLooking()</code>.</p><p>Another \"But...!?\" you may be about to raise: what if I'd used objects or arrays as the values instead of the numbers (<code>112358132134</code>, etc.)? Would us having references to objects instead of copies of primitive values \"fix\" the inaccessibility?</p><p>No. Mutating the contents of the object value via a reference copy is <strong>not</strong> the same thing as lexically accessing the variable itself. We still can't reassign the BLUE(2) <code>special</code> parameter.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Copying Is Not Accessing", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I've been asked the following \"But what about...?\" question dozens of times. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var special = 42;\n\nfunction lookingFor(special) {\n    var another = {\n        special: special\n    };\n\n    function keepLooking() {\n        var special = 3.141592;\n        console.log(special);\n        console.log(another.special);  // Ooo, tricky!\n        console.log(window.special);\n    }\n\n    keepLooking();\n}\n\nlookingFor(112358132134);\n// 3.141592\n// 112358132134\n// 42", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Oh! So does this ", "type": "text"}, {"text": "another", "type": "text", "marks": [{"type": "code"}]}, {"text": " object technique disprove my claim that the ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter is \"completely inaccessible\" from inside ", "type": "text"}, {"text": "keepLooking()", "type": "text", "marks": [{"type": "code"}]}, {"text": "? No, the claim is still correct.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "special: special", "type": "text", "marks": [{"type": "code"}]}, {"text": " is copying the value of the ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter variable into another container (a property of the same name). Of course, if you put a value in another container, shadowing no longer applies (unless ", "type": "text"}, {"text": "another", "type": "text", "marks": [{"type": "code"}]}, {"text": " was shadowed, too!). But that doesn't mean we're accessing the parameter ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": "; it means we're accessing the copy of the value it had at that moment, by way of ", "type": "text"}, {"text": "another", "type": "text", "marks": [{"type": "italic"}]}, {"text": " container (object property). We cannot reassign the BLUE(2) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter to a different value from inside ", "type": "text"}, {"text": "keepLooking()", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another \"But...!?\" you may be about to raise: what if I'd used objects or arrays as the values instead of the numbers (", "type": "text"}, {"text": "112358132134", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc.)? Would us having references to objects instead of copies of primitive values \"fix\" the inaccessibility?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "No. Mutating the contents of the object value via a reference copy is ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " the same thing as lexically accessing the variable itself. We still can't reassign the BLUE(2) ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter.", "type": "text"}]}]}, "article_text": "Copying Is Not Accessing\n\nI've been asked the following \"But what about...?\" question dozens of times. Consider:\n\nvar special = 42;\n\nfunction lookingFor(special) {\n    var another = {\n        special: special\n    };\n\n    function keepLooking() {\n        var special = 3.141592;\n        console.log(special);\n        console.log(another.special);  // Ooo, tricky!\n        console.log(window.special);\n    }\n\n    keepLooking();\n}\n\nlookingFor(112358132134);\n// 3.141592\n// 112358132134\n// 42\n\nOh! So does this another object technique disprove my claim that the special parameter is \"completely inaccessible\" from inside keepLooking()? No, the claim is still correct.\n\nspecial: special is copying the value of the special parameter variable into another container (a property of the same name). Of course, if you put a value in another container, shadowing no longer applies (unless another was shadowed, too!). But that doesn't mean we're accessing the parameter special; it means we're accessing the copy of the value it had at that moment, by way of another container (object property). We cannot reassign the BLUE(2) special parameter to a different value from inside keepLooking().\n\nAnother \"But...!?\" you may be about to raise: what if I'd used objects or arrays as the values instead of the numbers (112358132134, etc.)? Would us having references to objects instead of copies of primitive values \"fix\" the inaccessibility?\n\nNo. Mutating the contents of the object value via a reference copy is not the same thing as lexically accessing the variable itself. We still can't reassign the BLUE(2) special parameter."}, "id": 186}, {"data": {"uuid": "a0f88c93-239c-4c9f-8bcb-388e4081350d", "user": 1, "title": "Illegal Shadowing", "author": "Kyle Simpson", "created_on": "2023-06-09 01:03:42.353389+00:00", "updated_on": "2023-06-09 01:04:01.181081+00:00", "article_html": "<h3>Illegal Shadowing</h3><p>Not all combinations of declaration shadowing are allowed. <code>let</code> can shadow <code>var</code>, but <code>var</code> cannot shadow <code>let</code>:</p><pre><code>function something() {\n    var special = \"JavaScript\";\n\n    {\n        let special = 42;   // totally fine shadowing\n\n        // ..\n    }\n}\n\nfunction another() {\n    // ..\n\n    {\n        let special = \"JavaScript\";\n\n        {\n            var special = \"JavaScript\";\n            // ^^^ Syntax Error\n\n            // ..\n        }\n    }\n}</code></pre><p>Notice in the <code>another()</code> function, the inner <code>var special</code> declaration is attempting to declare a function-wide <code>special</code>, which in and of itself is fine (as shown by the <code>something()</code> function).</p><p>The syntax error description in this case indicates that <code>special</code> has already been defined, but that error message is a little misleading\u2014again, no such error happens in <code>something()</code>, as shadowing is generally allowed just fine.</p><p>The real reason it's raised as a <code>SyntaxError</code> is because the <code>var</code> is basically trying to \"cross the boundary\" of (or hop over) the <code>let</code> declaration of the same name, which is not allowed.</p><p>That boundary-crossing prohibition effectively stops at each function boundary, so this variant raises no exception:</p><pre><code>function another() {\n    // ..\n\n    {\n        let special = \"JavaScript\";\n\n        ajax(\"https://some.url\",function callback(){\n            // totally fine shadowing\n            var special = \"JavaScript\";\n\n            // ..\n        });\n    }\n}</code></pre><p>Summary: <code>let</code> (in an inner scope) can always shadow an outer scope's <code>var</code>. <code>var</code> (in an inner scope) can only shadow an outer scope's <code>let</code> if there is a function boundary in between.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Illegal Shadowing", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Not all combinations of declaration shadowing are allowed. ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " can shadow ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " cannot shadow ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function something() {\n    var special = \"JavaScript\";\n\n    {\n        let special = 42;   // totally fine shadowing\n\n        // ..\n    }\n}\n\nfunction another() {\n    // ..\n\n    {\n        let special = \"JavaScript\";\n\n        {\n            var special = \"JavaScript\";\n            // ^^^ Syntax Error\n\n            // ..\n        }\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice in the ", "type": "text"}, {"text": "another()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, the inner ", "type": "text"}, {"text": "var special", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration is attempting to declare a function-wide ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which in and of itself is fine (as shown by the ", "type": "text"}, {"text": "something()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The syntax error description in this case indicates that ", "type": "text"}, {"text": "special", "type": "text", "marks": [{"type": "code"}]}, {"text": " has already been defined, but that error message is a little misleading\u2014again, no such error happens in ", "type": "text"}, {"text": "something()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", as shadowing is generally allowed just fine.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The real reason it's raised as a ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": " is because the ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is basically trying to \"cross the boundary\" of (or hop over) the ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration of the same name, which is not allowed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That boundary-crossing prohibition effectively stops at each function boundary, so this variant raises no exception:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function another() {\n    // ..\n\n    {\n        let special = \"JavaScript\";\n\n        ajax(\"https://some.url\",function callback(){\n            // totally fine shadowing\n            var special = \"JavaScript\";\n\n            // ..\n        });\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Summary: ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " (in an inner scope) can always shadow an outer scope's ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ". ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " (in an inner scope) can only shadow an outer scope's ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " if there is a function boundary in between.", "type": "text"}]}]}, "article_text": "Illegal Shadowing\n\nNot all combinations of declaration shadowing are allowed. let can shadow var, but var cannot shadow let:\n\nfunction something() {\n    var special = \"JavaScript\";\n\n    {\n        let special = 42;   // totally fine shadowing\n\n        // ..\n    }\n}\n\nfunction another() {\n    // ..\n\n    {\n        let special = \"JavaScript\";\n\n        {\n            var special = \"JavaScript\";\n            // ^^^ Syntax Error\n\n            // ..\n        }\n    }\n}\n\nNotice in the another() function, the inner var special declaration is attempting to declare a function-wide special, which in and of itself is fine (as shown by the something() function).\n\nThe syntax error description in this case indicates that special has already been defined, but that error message is a little misleading\u2014again, no such error happens in something(), as shadowing is generally allowed just fine.\n\nThe real reason it's raised as a SyntaxError is because the var is basically trying to \"cross the boundary\" of (or hop over) the let declaration of the same name, which is not allowed.\n\nThat boundary-crossing prohibition effectively stops at each function boundary, so this variant raises no exception:\n\nfunction another() {\n    // ..\n\n    {\n        let special = \"JavaScript\";\n\n        ajax(\"https://some.url\",function callback(){\n            // totally fine shadowing\n            var special = \"JavaScript\";\n\n            // ..\n        });\n    }\n}\n\nSummary: let (in an inner scope) can always shadow an outer scope's var. var (in an inner scope) can only shadow an outer scope's let if there is a function boundary in between."}, "id": 187}]}, {"data": {"uuid": "24511bdb-79a1-48ad-8fc6-65daaab0eb85", "user": 1, "title": "Function Name Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 01:04:17.658248+00:00", "updated_on": "2023-06-09 01:04:44.988077+00:00", "article_html": "<h2>Function Name Scope</h2><p>As you've seen by now, a <code>function</code> declaration looks like this:</p><pre><code>function askQuestion() {\n    // ..\n}</code></pre><p>And as discussed in Chapters 1 and 2, such a <code>function</code> declaration will create an identifier in the enclosing scope (in this case, the global scope) named <code>askQuestion</code>.</p><p>What about this program?</p><pre><code>var askQuestion = function(){\n    // ..\n};</code></pre><p>The same is true for the variable <code>askQuestion</code> being created. But since it's a <code>function</code> expression\u2014a function definition used as value instead of a standalone declaration\u2014the function itself will not \"hoist\" (see Chapter 5).</p><p>One major difference between <code>function</code> declarations and <code>function</code> expressions is what happens to the name identifier of the function. Consider a named <code>function</code> expression:</p><pre><code>var askQuestion = function ofTheTeacher(){\n    // ..\n};</code></pre><p>We know <code>askQuestion</code> ends up in the outer scope. But what about the <code>ofTheTeacher</code> identifier? For formal <code>function</code> declarations, the name identifier ends up in the outer/enclosing scope, so it may be reasonable to assume that's the case here. But <code>ofTheTeacher</code> is declared as an identifier <strong>inside the function itself</strong>:</p><pre><code>var askQuestion = function ofTheTeacher() {\n    console.log(ofTheTeacher);\n};\n\naskQuestion();\n// function ofTheTeacher()...\n\nconsole.log(ofTheTeacher);\n// ReferenceError: ofTheTeacher is not defined</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Actually, <code>ofTheTeacher</code> is not exactly <em>in the scope of the function</em>. Appendix A, \"Implied Scopes\" will explain further.</p></td></tr></tbody></table><p>Not only is <code>ofTheTeacher</code> declared inside the function rather than outside, but it's also defined as read-only:</p><pre><code>var askQuestion = function ofTheTeacher() {\n    \"use strict\";\n    ofTheTeacher = 42;   // TypeError\n\n    //..\n};\n\naskQuestion();\n// TypeError</code></pre><p>Because we used strict-mode, the assignment failure is reported as a <code>TypeError</code>; in non-strict-mode, such an assignment fails silently with no exception.</p><p>What about when a <code>function</code> expression has no name identifier?</p><pre><code>var askQuestion = function(){\n   // ..\n};</code></pre><p>A <code>function</code> expression with a name identifier is referred to as a \"named function expression,\" but one without a name identifier is referred to as an \"anonymous function expression.\" Anonymous function expressions clearly have no name identifier that affects either scope.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>We'll discuss named vs. anonymous <code>function</code> expressions in much more detail, including what factors affect the decision to use one or the other, in Appendix A.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Function Name Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As you've seen by now, a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration looks like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function askQuestion() {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And as discussed in Chapters 1 and 2, such a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration will create an identifier in the enclosing scope (in this case, the global scope) named ", "type": "text"}, {"text": "askQuestion", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about this program?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function(){\n    // ..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The same is true for the variable ", "type": "text"}, {"text": "askQuestion", "type": "text", "marks": [{"type": "code"}]}, {"text": " being created. But since it's a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression\u2014a function definition used as value instead of a standalone declaration\u2014the function itself will not \"hoist\" (see Chapter 5).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One major difference between ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations and ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions is what happens to the name identifier of the function. Consider a named ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function ofTheTeacher(){\n    // ..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We know ", "type": "text"}, {"text": "askQuestion", "type": "text", "marks": [{"type": "code"}]}, {"text": " ends up in the outer scope. But what about the ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier? For formal ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations, the name identifier ends up in the outer/enclosing scope, so it may be reasonable to assume that's the case here. But ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " is declared as an identifier ", "type": "text"}, {"text": "inside the function itself", "type": "text", "marks": [{"type": "bold"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function ofTheTeacher() {\n    console.log(ofTheTeacher);\n};\n\naskQuestion();\n// function ofTheTeacher()...\n\nconsole.log(ofTheTeacher);\n// ReferenceError: ofTheTeacher is not defined", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Actually, ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not exactly ", "type": "text"}, {"text": "in the scope of the function", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Appendix A, \"Implied Scopes\" will explain further.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Not only is ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " declared inside the function rather than outside, but it's also defined as read-only:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function ofTheTeacher() {\n    \"use strict\";\n    ofTheTeacher = 42;   // TypeError\n\n    //..\n};\n\naskQuestion();\n// TypeError", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Because we used strict-mode, the assignment failure is reported as a ", "type": "text"}, {"text": "TypeError", "type": "text", "marks": [{"type": "code"}]}, {"text": "; in non-strict-mode, such an assignment fails silently with no exception.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about when a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression has no name identifier?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function(){\n   // ..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression with a name identifier is referred to as a \"named function expression,\" but one without a name identifier is referred to as an \"anonymous function expression.\" Anonymous function expressions clearly have no name identifier that affects either scope.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "We'll discuss named vs. anonymous ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions in much more detail, including what factors affect the decision to use one or the other, in Appendix A.", "type": "text"}]}]}]}]}]}, "article_text": "Function Name Scope\n\nAs you've seen by now, a function declaration looks like this:\n\nfunction askQuestion() {\n    // ..\n}\n\nAnd as discussed in Chapters 1 and 2, such a function declaration will create an identifier in the enclosing scope (in this case, the global scope) named askQuestion.\n\nWhat about this program?\n\nvar askQuestion = function(){\n    // ..\n};\n\nThe same is true for the variable askQuestion being created. But since it's a function expression\u2014a function definition used as value instead of a standalone declaration\u2014the function itself will not \"hoist\" (see Chapter 5).\n\nOne major difference between function declarations and function expressions is what happens to the name identifier of the function. Consider a named function expression:\n\nvar askQuestion = function ofTheTeacher(){\n    // ..\n};\n\nWe know askQuestion ends up in the outer scope. But what about the ofTheTeacher identifier? For formal function declarations, the name identifier ends up in the outer/enclosing scope, so it may be reasonable to assume that's the case here. But ofTheTeacher is declared as an identifier inside the function itself:\n\nvar askQuestion = function ofTheTeacher() {\n    console.log(ofTheTeacher);\n};\n\naskQuestion();\n// function ofTheTeacher()...\n\nconsole.log(ofTheTeacher);\n// ReferenceError: ofTheTeacher is not defined\n\nNOTE:\n\nActually, ofTheTeacher is not exactly in the scope of the function. Appendix A, \"Implied Scopes\" will explain further.\n\nNot only is ofTheTeacher declared inside the function rather than outside, but it's also defined as read-only:\n\nvar askQuestion = function ofTheTeacher() {\n    \"use strict\";\n    ofTheTeacher = 42;   // TypeError\n\n    //..\n};\n\naskQuestion();\n// TypeError\n\nBecause we used strict-mode, the assignment failure is reported as a TypeError; in non-strict-mode, such an assignment fails silently with no exception.\n\nWhat about when a function expression has no name identifier?\n\nvar askQuestion = function(){\n   // ..\n};\n\nA function expression with a name identifier is referred to as a \"named function expression,\" but one without a name identifier is referred to as an \"anonymous function expression.\" Anonymous function expressions clearly have no name identifier that affects either scope.\n\nNOTE:\n\nWe'll discuss named vs. anonymous function expressions in much more detail, including what factors affect the decision to use one or the other, in Appendix A."}, "id": 188}, {"data": {"uuid": "4436551c-e864-4dde-a435-f84f57bca64d", "user": 1, "title": "Arrow Functions", "author": "Kyle Simpson", "created_on": "2023-06-09 01:05:07.187357+00:00", "updated_on": "2023-06-09 01:05:24.647330+00:00", "article_html": "<h2>Arrow Functions</h2><p>ES6 added an additional <code>function</code> expression form to the language, called \"arrow functions\":</p><pre><code>var askQuestion = () =&gt; {\n    // ..\n};</code></pre><p>The <code>=&gt;</code> arrow function doesn't require the word <code>function</code> to define it. Also, the <code>( .. )</code> around the parameter list is optional in some simple cases. Likewise, the <code>{ .. }</code> around the function body is optional in some cases. And when the <code>{ .. }</code> are omitted, a return value is sent out without using a <code>return</code> keyword.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The attractiveness of <code>=&gt;</code> arrow functions is often sold as \"shorter syntax,\" and that's claimed to equate to objectively more readable code. This claim is dubious at best, and I believe outright misguided. We'll dig into the \"readability\" of various function forms in Appendix A.</p></td></tr></tbody></table><p>Arrow functions are lexically anonymous, meaning they have no directly related identifier that references the function. The assignment to <code>askQuestion</code> creates an inferred name of \"askQuestion\", but that's <strong>not the same thing as being non-anonymous</strong>:</p><pre><code>var askQuestion = () =&gt; {\n    // ..\n};\n\naskQuestion.name;   // askQuestion</code></pre><p>Arrow functions achieve their syntactic brevity at the expense of having to mentally juggle a bunch of variations for different forms/conditions. Just a few, for example:</p><pre><code>() =&gt; 42;\n\nid =&gt; id.toUpperCase();\n\n(id,name) =&gt; ({ id, name });\n\n(...args) =&gt; {\n    return args[args.length - 1];\n};</code></pre><p>The real reason I bring up arrow functions is because of the common but incorrect claim that arrow functions somehow behave differently with respect to lexical scope from standard <code>function</code> functions.</p><p>This is incorrect.</p><p>Other than being anonymous (and having no declarative form), <code>=&gt;</code> arrow functions have the same lexical scope rules as <code>function</code> functions do. An arrow function, with or without <code>{ .. }</code> around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a <code>function</code> scope.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Arrow Functions", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES6 added an additional ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression form to the language, called \"arrow functions\":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = () => {\n    // ..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "=>", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow function doesn't require the word ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " to define it. Also, the ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": " around the parameter list is optional in some simple cases. Likewise, the ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " around the function body is optional in some cases. And when the ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " are omitted, a return value is sent out without using a ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The attractiveness of ", "type": "text"}, {"text": "=>", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow functions is often sold as \"shorter syntax,\" and that's claimed to equate to objectively more readable code. This claim is dubious at best, and I believe outright misguided. We'll dig into the \"readability\" of various function forms in Appendix A.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Arrow functions are lexically anonymous, meaning they have no directly related identifier that references the function. The assignment to ", "type": "text"}, {"text": "askQuestion", "type": "text", "marks": [{"type": "code"}]}, {"text": " creates an inferred name of \"askQuestion\", but that's ", "type": "text"}, {"text": "not the same thing as being non-anonymous", "type": "text", "marks": [{"type": "bold"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = () => {\n    // ..\n};\n\naskQuestion.name;   // askQuestion", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Arrow functions achieve their syntactic brevity at the expense of having to mentally juggle a bunch of variations for different forms/conditions. Just a few, for example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "() => 42;\n\nid => id.toUpperCase();\n\n(id,name) => ({ id, name });\n\n(...args) => {\n    return args[args.length - 1];\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The real reason I bring up arrow functions is because of the common but incorrect claim that arrow functions somehow behave differently with respect to lexical scope from standard ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " functions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is incorrect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Other than being anonymous (and having no declarative form), ", "type": "text"}, {"text": "=>", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow functions have the same lexical scope rules as ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " functions do. An arrow function, with or without ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " scope.", "type": "text"}]}]}, "article_text": "Arrow Functions\n\nES6 added an additional function expression form to the language, called \"arrow functions\":\n\nvar askQuestion = () => {\n    // ..\n};\n\nThe => arrow function doesn't require the word function to define it. Also, the ( .. ) around the parameter list is optional in some simple cases. Likewise, the { .. } around the function body is optional in some cases. And when the { .. } are omitted, a return value is sent out without using a return keyword.\n\nNOTE:\n\nThe attractiveness of => arrow functions is often sold as \"shorter syntax,\" and that's claimed to equate to objectively more readable code. This claim is dubious at best, and I believe outright misguided. We'll dig into the \"readability\" of various function forms in Appendix A.\n\nArrow functions are lexically anonymous, meaning they have no directly related identifier that references the function. The assignment to askQuestion creates an inferred name of \"askQuestion\", but that's not the same thing as being non-anonymous:\n\nvar askQuestion = () => {\n    // ..\n};\n\naskQuestion.name;   // askQuestion\n\nArrow functions achieve their syntactic brevity at the expense of having to mentally juggle a bunch of variations for different forms/conditions. Just a few, for example:\n\n() => 42;\n\nid => id.toUpperCase();\n\n(id,name) => ({ id, name });\n\n(...args) => {\n    return args[args.length - 1];\n};\n\nThe real reason I bring up arrow functions is because of the common but incorrect claim that arrow functions somehow behave differently with respect to lexical scope from standard function functions.\n\nThis is incorrect.\n\nOther than being anonymous (and having no declarative form), => arrow functions have the same lexical scope rules as function functions do. An arrow function, with or without { .. } around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a function scope."}, "id": 189}, {"data": {"uuid": "9f2b20f3-79bb-46b6-9220-a73947a71c67", "user": 1, "title": "Backing Out", "author": "Kyle Simpson", "created_on": "2023-06-09 01:05:46.505548+00:00", "updated_on": "2023-06-09 01:06:05.453966+00:00", "article_html": "<h2>Backing Out</h2><p>When a function (declaration or expression) is defined, a new scope is created. The positioning of scopes nested inside one another creates a natural scope hierarchy throughout the program, called the scope chain. The scope chain controls variable access, directionally oriented upward and outward.</p><p>Each new scope offers a clean slate, a space to hold its own set of variables. When a variable name is repeated at different levels of the scope chain, shadowing occurs, which prevents access to the outer variable from that point inward.</p><p>As we step back out from these finer details, the next chapter shifts focus to the primary scope all JS programs include: the global scope.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Backing Out", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When a function (declaration or expression) is defined, a new scope is created. The positioning of scopes nested inside one another creates a natural scope hierarchy throughout the program, called the scope chain. The scope chain controls variable access, directionally oriented upward and outward.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each new scope offers a clean slate, a space to hold its own set of variables. When a variable name is repeated at different levels of the scope chain, shadowing occurs, which prevents access to the outer variable from that point inward.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As we step back out from these finer details, the next chapter shifts focus to the primary scope all JS programs include: the global scope.", "type": "text"}]}]}, "article_text": "Backing Out\n\nWhen a function (declaration or expression) is defined, a new scope is created. The positioning of scopes nested inside one another creates a natural scope hierarchy throughout the program, called the scope chain. The scope chain controls variable access, directionally oriented upward and outward.\n\nEach new scope offers a clean slate, a space to hold its own set of variables. When a variable name is repeated at different levels of the scope chain, shadowing occurs, which prevents access to the outer variable from that point inward.\n\nAs we step back out from these finer details, the next chapter shifts focus to the primary scope all JS programs include: the global scope."}, "id": 190}]}, {"data": {"uuid": "4772846f-2ece-4527-87a1-23937b086b7e", "user": 1, "title": "Chapter 4: Around the Global Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 01:06:45.824935+00:00", "updated_on": "2023-06-09 01:07:05.616336+00:00", "article_html": "<h1>Chapter 4: Around the Global Scope</h1><p>Chapter 3 mentioned the \"global scope\" several times, but you may still be wondering why a program's outermost scope is all that important in modern JS. The vast majority of work is now done inside of functions and modules rather than globally.</p><p>Is it good enough to just assert, \"Avoid using the global scope,\" and be done with it?</p><p>The global scope of a JS program is a rich topic, with much more utility and nuance than you would likely assume. This chapter first explores how the global scope is (still) useful and relevant to writing JS programs today, then looks at differences in where and <em>how to access</em> the global scope in different JS environments.</p><p>Fully understanding the global scope is critical in your mastery of using lexical scope to structure your programs.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 4: Around the Global Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Chapter 3 mentioned the \"global scope\" several times, but you may still be wondering why a program's outermost scope is all that important in modern JS. The vast majority of work is now done inside of functions and modules rather than globally.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Is it good enough to just assert, \"Avoid using the global scope,\" and be done with it?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The global scope of a JS program is a rich topic, with much more utility and nuance than you would likely assume. This chapter first explores how the global scope is (still) useful and relevant to writing JS programs today, then looks at differences in where and ", "type": "text"}, {"text": "how to access", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the global scope in different JS environments.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Fully understanding the global scope is critical in your mastery of using lexical scope to structure your programs.", "type": "text"}]}]}, "article_text": "Chapter 4: Around the Global Scope\n\nChapter 3 mentioned the \"global scope\" several times, but you may still be wondering why a program's outermost scope is all that important in modern JS. The vast majority of work is now done inside of functions and modules rather than globally.\n\nIs it good enough to just assert, \"Avoid using the global scope,\" and be done with it?\n\nThe global scope of a JS program is a rich topic, with much more utility and nuance than you would likely assume. This chapter first explores how the global scope is (still) useful and relevant to writing JS programs today, then looks at differences in where and how to access the global scope in different JS environments.\n\nFully understanding the global scope is critical in your mastery of using lexical scope to structure your programs."}, "id": 191, "children": [{"data": {"uuid": "ee143bfb-88e9-4158-b858-2837ca8ed514", "user": 1, "title": "Why Global Scope?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:07:23.141650+00:00", "updated_on": "2023-06-09 01:07:53.165846+00:00", "article_html": "<h2>Why Global Scope?</h2><p>It's likely no surprise to readers that most applications are composed of multiple (sometimes many!) individual JS files. So how exactly do all those separate files get stitched together in a single runtime context by the JS engine?</p><p>With respect to browser-executed applications, there are three main ways.</p><p>First, if you're directly using ES modules (not transpiling them into some other module-bundle format), these files are loaded individually by the JS environment. Each module then <code>import</code>s references to whichever other modules it needs to access. The separate module files cooperate with each other exclusively through these shared imports, without needing any shared outer scope.</p><p>Second, if you're using a bundler in your build process, all the files are typically concatenated together before delivery to the browser and JS engine, which then only processes one big file. Even with all the pieces of the application co-located in a single file, some mechanism is necessary for each piece to register a <em>name</em> to be referred to by other pieces, as well as some facility for that access to occur.</p><p>In some build setups, the entire contents of the file are wrapped in a single enclosing scope, such as a wrapper function, universal module (UMD\u2014see Appendix A), etc. Each piece can register itself for access from other pieces by way of local variables in that shared scope. For example:</p><pre><code>(function wrappingOuterScope(){\n    var moduleOne = (function one(){\n        // ..\n    })();\n\n    var moduleTwo = (function two(){\n        // ..\n\n        function callModuleOne() {\n            moduleOne.someMethod();\n        }\n\n        // ..\n    })();\n})();</code></pre><p>As shown, the <code>moduleOne</code> and <code>moduleTwo</code> local variables inside the <code>wrappingOuterScope()</code> function scope are declared so that these modules can access each other for their cooperation.</p><p>While the scope of <code>wrappingOuterScope()</code> is a function and not the full environment global scope, it does act as a sort of \"application-wide scope,\" a bucket where all the top-level identifiers can be stored, though not in the real global scope. It's kind of like a stand-in for the global scope in that respect.</p><p>And finally, the third way: whether a bundler tool is used for an application, or whether the (non-ES module) files are simply loaded in the browser individually (via <code>&lt;script&gt;</code> tags or other dynamic JS resource loading), if there is no single surrounding scope encompassing all these pieces, the <strong>global scope</strong> is the only way for them to cooperate with each other:</p><p>A bundled file of this sort often looks something like this:</p><pre><code>var moduleOne = (function one(){\n    // ..\n})();\nvar moduleTwo = (function two(){\n    // ..\n\n    function callModuleOne() {\n        moduleOne.someMethod();\n    }\n\n    // ..\n})();</code></pre><p>Here, since there is no surrounding function scope, these <code>moduleOne</code> and <code>moduleTwo</code> declarations are simply dropped into the global scope. This is effectively the same as if the files hadn't been concatenated, but loaded separately:</p><p>module1.js:</p><pre><code>var moduleOne = (function one(){\n    // ..\n})();</code></pre><p>module2.js:</p><pre><code>var moduleTwo = (function two(){\n    // ..\n\n    function callModuleOne() {\n        moduleOne.someMethod();\n    }\n\n    // ..\n})();</code></pre><p>If these files are loaded separately as normal standalone .js files in a browser environment, each top-level variable declaration will end up as a global variable, since the global scope is the only shared resource between these two separate files\u2014they're independent programs, from the perspective of the JS engine.</p><p>In addition to (potentially) accounting for where an application's code resides during runtime, and how each piece is able to access the other pieces to cooperate, the global scope is also where:</p><ul><li><p>JS exposes its built-ins:</p><ul><li><p>primitives: <code>undefined</code>, <code>null</code>, <code>Infinity</code>, <code>NaN</code></p></li><li><p>natives: <code>Date()</code>, <code>Object()</code>, <code>String()</code>, etc.</p></li><li><p>global functions: <code>eval()</code>, <code>parseInt()</code>, etc.</p></li><li><p>namespaces: <code>Math</code>, <code>Atomics</code>, <code>JSON</code></p></li><li><p>friends of JS: <code>Intl</code>, <code>WebAssembly</code></p></li></ul></li><li><p>The environment hosting the JS engine exposes its own built-ins:</p><ul><li><p><code>console</code> (and its methods)</p></li><li><p>the DOM (<code>window</code>, <code>document</code>, etc)</p></li><li><p>timers (<code>setTimeout(..)</code>, etc)</p></li><li><p>web platform APIs: <code>navigator</code>, <code>history</code>, geolocation, WebRTC, etc.</p></li></ul></li></ul><p>These are just some of the many <em>globals</em> your programs will interact with.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Node also exposes several elements \"globally,\" but they're technically not in the <code>global</code> scope: <code>require()</code>, <code>__dirname</code>, <code>module</code>, <code>URL</code>, and so on.</p></td></tr></tbody></table><p>Most developers agree that the global scope shouldn't just be a dumping ground for every variable in your application. That's a mess of bugs just waiting to happen. But it's also undeniable that the global scope is an important <em>glue</em> for practically every JS application.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Why Global Scope?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's likely no surprise to readers that most applications are composed of multiple (sometimes many!) individual JS files. So how exactly do all those separate files get stitched together in a single runtime context by the JS engine?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With respect to browser-executed applications, there are three main ways.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First, if you're directly using ES modules (not transpiling them into some other module-bundle format), these files are loaded individually by the JS environment. Each module then ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": "s references to whichever other modules it needs to access. The separate module files cooperate with each other exclusively through these shared imports, without needing any shared outer scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Second, if you're using a bundler in your build process, all the files are typically concatenated together before delivery to the browser and JS engine, which then only processes one big file. Even with all the pieces of the application co-located in a single file, some mechanism is necessary for each piece to register a ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to be referred to by other pieces, as well as some facility for that access to occur.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In some build setups, the entire contents of the file are wrapped in a single enclosing scope, such as a wrapper function, universal module (UMD\u2014see Appendix A), etc. Each piece can register itself for access from other pieces by way of local variables in that shared scope. For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "(function wrappingOuterScope(){\n    var moduleOne = (function one(){\n        // ..\n    })();\n\n    var moduleTwo = (function two(){\n        // ..\n\n        function callModuleOne() {\n            moduleOne.someMethod();\n        }\n\n        // ..\n    })();\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As shown, the ", "type": "text"}, {"text": "moduleOne", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "moduleTwo", "type": "text", "marks": [{"type": "code"}]}, {"text": " local variables inside the ", "type": "text"}, {"text": "wrappingOuterScope()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function scope are declared so that these modules can access each other for their cooperation.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "While the scope of ", "type": "text"}, {"text": "wrappingOuterScope()", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a function and not the full environment global scope, it does act as a sort of \"application-wide scope,\" a bucket where all the top-level identifiers can be stored, though not in the real global scope. It's kind of like a stand-in for the global scope in that respect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And finally, the third way: whether a bundler tool is used for an application, or whether the (non-ES module) files are simply loaded in the browser individually (via ", "type": "text"}, {"text": "<script>", "type": "text", "marks": [{"type": "code"}]}, {"text": " tags or other dynamic JS resource loading), if there is no single surrounding scope encompassing all these pieces, the ", "type": "text"}, {"text": "global scope", "type": "text", "marks": [{"type": "bold"}]}, {"text": " is the only way for them to cooperate with each other:", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A bundled file of this sort often looks something like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var moduleOne = (function one(){\n    // ..\n})();\nvar moduleTwo = (function two(){\n    // ..\n\n    function callModuleOne() {\n        moduleOne.someMethod();\n    }\n\n    // ..\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, since there is no surrounding function scope, these ", "type": "text"}, {"text": "moduleOne", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "moduleTwo", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations are simply dropped into the global scope. This is effectively the same as if the files hadn't been concatenated, but loaded separately:", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "module1.js:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var moduleOne = (function one(){\n    // ..\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "module2.js:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var moduleTwo = (function two(){\n    // ..\n\n    function callModuleOne() {\n        moduleOne.someMethod();\n    }\n\n    // ..\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If these files are loaded separately as normal standalone .js files in a browser environment, each top-level variable declaration will end up as a global variable, since the global scope is the only shared resource between these two separate files\u2014they're independent programs, from the perspective of the JS engine.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In addition to (potentially) accounting for where an application's code resides during runtime, and how each piece is able to access the other pieces to cooperate, the global scope is also where:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "JS exposes its built-ins:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "primitives: ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "null", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "Infinity", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "natives: ", "type": "text"}, {"text": "Date()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "Object()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "String()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "global functions: ", "type": "text"}, {"text": "eval()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "parseInt()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "namespaces: ", "type": "text"}, {"text": "Math", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "Atomics", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "JSON", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "friends of JS: ", "type": "text"}, {"text": "Intl", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "WebAssembly", "type": "text", "marks": [{"type": "code"}]}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The environment hosting the JS engine exposes its own built-ins:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "console", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and its methods)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "the DOM (", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "document", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "timers (", "type": "text"}, {"text": "setTimeout(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "web platform APIs: ", "type": "text"}, {"text": "navigator", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "history", "type": "text", "marks": [{"type": "code"}]}, {"text": ", geolocation, WebRTC, etc.", "type": "text"}]}]}]}]}]}, {"type": "paragraph", "content": [{"text": "These are just some of the many ", "type": "text"}, {"text": "globals", "type": "text", "marks": [{"type": "italic"}]}, {"text": " your programs will interact with.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Node also exposes several elements \"globally,\" but they're technically not in the ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": " scope: ", "type": "text"}, {"text": "require()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "__dirname", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "module", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "URL", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and so on.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Most developers agree that the global scope shouldn't just be a dumping ground for every variable in your application. That's a mess of bugs just waiting to happen. But it's also undeniable that the global scope is an important ", "type": "text"}, {"text": "glue", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for practically every JS application.", "type": "text"}]}]}, "article_text": "Why Global Scope?\n\nIt's likely no surprise to readers that most applications are composed of multiple (sometimes many!) individual JS files. So how exactly do all those separate files get stitched together in a single runtime context by the JS engine?\n\nWith respect to browser-executed applications, there are three main ways.\n\nFirst, if you're directly using ES modules (not transpiling them into some other module-bundle format), these files are loaded individually by the JS environment. Each module then imports references to whichever other modules it needs to access. The separate module files cooperate with each other exclusively through these shared imports, without needing any shared outer scope.\n\nSecond, if you're using a bundler in your build process, all the files are typically concatenated together before delivery to the browser and JS engine, which then only processes one big file. Even with all the pieces of the application co-located in a single file, some mechanism is necessary for each piece to register a name to be referred to by other pieces, as well as some facility for that access to occur.\n\nIn some build setups, the entire contents of the file are wrapped in a single enclosing scope, such as a wrapper function, universal module (UMD\u2014see Appendix A), etc. Each piece can register itself for access from other pieces by way of local variables in that shared scope. For example:\n\n(function wrappingOuterScope(){\n    var moduleOne = (function one(){\n        // ..\n    })();\n\n    var moduleTwo = (function two(){\n        // ..\n\n        function callModuleOne() {\n            moduleOne.someMethod();\n        }\n\n        // ..\n    })();\n})();\n\nAs shown, the moduleOne and moduleTwo local variables inside the wrappingOuterScope() function scope are declared so that these modules can access each other for their cooperation.\n\nWhile the scope of wrappingOuterScope() is a function and not the full environment global scope, it does act as a sort of \"application-wide scope,\" a bucket where all the top-level identifiers can be stored, though not in the real global scope. It's kind of like a stand-in for the global scope in that respect.\n\nAnd finally, the third way: whether a bundler tool is used for an application, or whether the (non-ES module) files are simply loaded in the browser individually (via <script> tags or other dynamic JS resource loading), if there is no single surrounding scope encompassing all these pieces, the global scope is the only way for them to cooperate with each other:\n\nA bundled file of this sort often looks something like this:\n\nvar moduleOne = (function one(){\n    // ..\n})();\nvar moduleTwo = (function two(){\n    // ..\n\n    function callModuleOne() {\n        moduleOne.someMethod();\n    }\n\n    // ..\n})();\n\nHere, since there is no surrounding function scope, these moduleOne and moduleTwo declarations are simply dropped into the global scope. This is effectively the same as if the files hadn't been concatenated, but loaded separately:\n\nmodule1.js:\n\nvar moduleOne = (function one(){\n    // ..\n})();\n\nmodule2.js:\n\nvar moduleTwo = (function two(){\n    // ..\n\n    function callModuleOne() {\n        moduleOne.someMethod();\n    }\n\n    // ..\n})();\n\nIf these files are loaded separately as normal standalone .js files in a browser environment, each top-level variable declaration will end up as a global variable, since the global scope is the only shared resource between these two separate files\u2014they're independent programs, from the perspective of the JS engine.\n\nIn addition to (potentially) accounting for where an application's code resides during runtime, and how each piece is able to access the other pieces to cooperate, the global scope is also where:\n\nJS exposes its built-ins:\n\nprimitives: undefined, null, Infinity, NaN\n\nnatives: Date(), Object(), String(), etc.\n\nglobal functions: eval(), parseInt(), etc.\n\nnamespaces: Math, Atomics, JSON\n\nfriends of JS: Intl, WebAssembly\n\nThe environment hosting the JS engine exposes its own built-ins:\n\nconsole (and its methods)\n\nthe DOM (window, document, etc)\n\ntimers (setTimeout(..), etc)\n\nweb platform APIs: navigator, history, geolocation, WebRTC, etc.\n\nThese are just some of the many globals your programs will interact with.\n\nNOTE:\n\nNode also exposes several elements \"globally,\" but they're technically not in the global scope: require(), __dirname, module, URL, and so on.\n\nMost developers agree that the global scope shouldn't just be a dumping ground for every variable in your application. That's a mess of bugs just waiting to happen. But it's also undeniable that the global scope is an important glue for practically every JS application."}, "id": 192}, {"data": {"uuid": "3aa38aa8-e42b-40c8-a3e6-c1b4831da3e0", "user": 1, "title": "Where Exactly is this Global Scope?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:08:31.379006+00:00", "updated_on": "2023-06-09 01:08:53.469617+00:00", "article_html": "<h2>Where Exactly is this Global Scope?</h2><p>It might seem obvious that the global scope is located in the outermost portion of a file; that is, not inside any function or other block. But it's not quite as simple as that.</p><p>Different JS environments handle the scopes of your programs, especially the global scope, differently. It's quite common for JS developers to harbor misconceptions without even realizing it.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Where Exactly is this Global Scope?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It might seem obvious that the global scope is located in the outermost portion of a file; that is, not inside any function or other block. But it's not quite as simple as that.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Different JS environments handle the scopes of your programs, especially the global scope, differently. It's quite common for JS developers to harbor misconceptions without even realizing it.", "type": "text"}]}]}, "article_text": "Where Exactly is this Global Scope?\n\nIt might seem obvious that the global scope is located in the outermost portion of a file; that is, not inside any function or other block. But it's not quite as simple as that.\n\nDifferent JS environments handle the scopes of your programs, especially the global scope, differently. It's quite common for JS developers to harbor misconceptions without even realizing it."}, "id": 193, "children": [{"data": {"uuid": "1986a76f-6e04-431a-8831-334c48bb7b4e", "user": 1, "title": "Browser \"Window\"", "author": "Kyle Simpson", "created_on": "2023-06-09 01:09:22.980127+00:00", "updated_on": "2023-06-09 01:09:51.412154+00:00", "article_html": "<h3>Browser \"Window\"</h3><p>With respect to treatment of the global scope, the most <em>pure</em> environment JS can be run in is as a standalone .js file loaded in a web page environment in a browser. I don't mean \"pure\" as in nothing automatically added\u2014lots may be added!\u2014but rather in terms of minimal intrusion on the code or interference with its expected global scope behavior.</p><p>Consider this .js file:</p><pre><code>var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!</code></pre><p>This code may be loaded in a web page environment using an inline <code>&lt;script&gt;</code> tag, a <code>&lt;script src=..&gt;</code> script tag in the markup, or even a dynamically created <code>&lt;script&gt;</code> DOM element. In all three cases, the <code>studentName</code> and <code>hello</code> identifiers are declared in the global scope.</p><p>That means if you access the global object (commonly, <code>window</code> in the browser), you'll find properties of those same names there:</p><pre><code>var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ window.studentName }!`);\n}\n\nwindow.hello();\n// Hello, Kyle!</code></pre><p>That's the default behavior one would expect from a reading of the JS specification: the outer scope <em>is</em> the global scope and <code>studentName</code> is legitimately created as global variable.</p><p>That's what I mean by <em>pure</em>. But unfortunately, that won't always be true of all JS environments you encounter, and that's often surprising to JS developers.</p><h4></h4><h4>Globals Shadowing Globals</h4><p>Recall the discussion of shadowing (and global unshadowing) from Chapter 3, where one variable declaration can override and prevent access to a declaration of the same name from an outer scope.</p><p>An unusual consequence of the difference between a global variable and a global property of the same name is that, within just the global scope itself, a global object property can be shadowed by a global variable:</p><pre><code>window.something = 42;\n\nlet something = \"Kyle\";\n\nconsole.log(something);\n// Kyle\n\nconsole.log(window.something);\n// 42</code></pre><p>The <code>let</code> declaration adds a <code>something</code> global variable but not a global object property (see Chapter 3). The effect then is that the <code>something</code> lexical identifier shadows the <code>something</code> global object property.</p><p>It's almost certainly a bad idea to create a divergence between the global object and the global scope. Readers of your code will almost certainly be tripped up.</p><p>A simple way to avoid this gotcha with global declarations: always use <code>var</code> for globals. Reserve <code>let</code> and <code>const</code> for block scopes (see \"Scoping with Blocks\" in Chapter 6).</p><h4></h4><h4>DOM Globals</h4><p>I asserted that a browser-hosted JS environment has the most <em>pure</em> global scope behavior we'll see. However, it's not entirely <em>pure</em>.</p><p>One surprising behavior in the global scope you may encounter with browser-based JS applications: a DOM element with an <code>id</code> attribute automatically creates a global variable that references it.</p><p>Consider this markup:</p><pre><code>&lt;ul id=\"my-todo-list\"&gt;\n   &lt;li id=\"first\"&gt;Write a book&lt;/li&gt;\n   ..\n&lt;/ul&gt;\n</code></pre><p>And the JS for that page could include:</p><pre><code>first;\n// &lt;li id=\"first\"&gt;..&lt;/li&gt;\n\nwindow[\"my-todo-list\"];\n// &lt;ul id=\"my-todo-list\"&gt;..&lt;/ul&gt;</code></pre><p>If the <code>id</code> value is a valid lexical name (like <code>first</code>), the lexical variable is created. If not, the only way to access that global is through the global object (<code>window[..]</code>).</p><p>The auto-registration of all <code>id</code>-bearing DOM elements as global variables is an old legacy browser behavior that nevertheless must remain because so many old sites still rely on it. My advice is never to use these global variables, even though they will always be silently created.</p><h4></h4><h4>What's in a (Window) Name?</h4><p>Another global scope oddity in browser-based JS:</p><pre><code>var name = 42;\n\nconsole.log(name, typeof name);\n// \"42\" string</code></pre><p><code>window.name</code> is a pre-defined \"global\" in a browser context; it's a property on the global object, so it seems like a normal global variable (yet it's anything but \"normal\").</p><p>We used <code>var</code> for our declaration, which <strong>does not</strong> shadow the pre-defined <code>name</code> global property. That means, effectively, the <code>var</code> declaration is ignored, since there's already a global scope object property of that name. As we discussed earlier, had we used <code>let name</code>, we would have shadowed <code>window.name</code> with a separate global <code>name</code> variable.</p><p>But the truly surprising behavior is that even though we assigned the number <code>42</code> to <code>name</code> (and thus <code>window.name</code>), when we then retrieve its value, it's a string <code>\"42\"</code>! In this case, the weirdness is because <code>name</code> is actually a pre-defined getter/setter on the <code>window</code> object, which insists on its value being a string value. Yikes!</p><p>With the exception of some rare corner cases like DOM element ID's and <code>window.name</code>, JS running as a standalone file in a browser page has some of the most <em>pure</em> global scope behavior we will encounter.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Browser \"Window\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With respect to treatment of the global scope, the most ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " environment JS can be run in is as a standalone .js file loaded in a web page environment in a browser. I don't mean \"pure\" as in nothing automatically added\u2014lots may be added!\u2014but rather in terms of minimal intrusion on the code or interference with its expected global scope behavior.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider this .js file:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This code may be loaded in a web page environment using an inline ", "type": "text"}, {"text": "<script>", "type": "text", "marks": [{"type": "code"}]}, {"text": " tag, a ", "type": "text"}, {"text": "<script src=..>", "type": "text", "marks": [{"type": "code"}]}, {"text": " script tag in the markup, or even a dynamically created ", "type": "text"}, {"text": "<script>", "type": "text", "marks": [{"type": "code"}]}, {"text": " DOM element. In all three cases, the ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifiers are declared in the global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That means if you access the global object (commonly, ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the browser), you'll find properties of those same names there:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ window.studentName }!`);\n}\n\nwindow.hello();\n// Hello, Kyle!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's the default behavior one would expect from a reading of the JS specification: the outer scope ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the global scope and ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is legitimately created as global variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's what I mean by ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". But unfortunately, that won't always be true of all JS environments you encounter, and that's often surprising to JS developers.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Globals Shadowing Globals", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall the discussion of shadowing (and global unshadowing) from Chapter 3, where one variable declaration can override and prevent access to a declaration of the same name from an outer scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An unusual consequence of the difference between a global variable and a global property of the same name is that, within just the global scope itself, a global object property can be shadowed by a global variable:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "window.something = 42;\n\nlet something = \"Kyle\";\n\nconsole.log(something);\n// Kyle\n\nconsole.log(window.something);\n// 42", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration adds a ", "type": "text"}, {"text": "something", "type": "text", "marks": [{"type": "code"}]}, {"text": " global variable but not a global object property (see Chapter 3). The effect then is that the ", "type": "text"}, {"text": "something", "type": "text", "marks": [{"type": "code"}]}, {"text": " lexical identifier shadows the ", "type": "text"}, {"text": "something", "type": "text", "marks": [{"type": "code"}]}, {"text": " global object property.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's almost certainly a bad idea to create a divergence between the global object and the global scope. Readers of your code will almost certainly be tripped up.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A simple way to avoid this gotcha with global declarations: always use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " for globals. Reserve ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " for block scopes (see \"Scoping with Blocks\" in Chapter 6).", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "DOM Globals", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I asserted that a browser-hosted JS environment has the most ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " global scope behavior we'll see. However, it's not entirely ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One surprising behavior in the global scope you may encounter with browser-based JS applications: a DOM element with an ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " attribute automatically creates a global variable that references it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider this markup:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "<ul id=\"my-todo-list\">\n   <li id=\"first\">Write a book</li>\n   ..\n</ul>\n", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And the JS for that page could include:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "first;\n// <li id=\"first\">..</li>\n\nwindow[\"my-todo-list\"];\n// <ul id=\"my-todo-list\">..</ul>", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If the ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " value is a valid lexical name (like ", "type": "text"}, {"text": "first", "type": "text", "marks": [{"type": "code"}]}, {"text": "), the lexical variable is created. If not, the only way to access that global is through the global object (", "type": "text"}, {"text": "window[..]", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The auto-registration of all ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": "-bearing DOM elements as global variables is an old legacy browser behavior that nevertheless must remain because so many old sites still rely on it. My advice is never to use these global variables, even though they will always be silently created.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "What's in a (Window) Name?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another global scope oddity in browser-based JS:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var name = 42;\n\nconsole.log(name, typeof name);\n// \"42\" string", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "window.name", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a pre-defined \"global\" in a browser context; it's a property on the global object, so it seems like a normal global variable (yet it's anything but \"normal\").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We used ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " for our declaration, which ", "type": "text"}, {"text": "does not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " shadow the pre-defined ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " global property. That means, effectively, the ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration is ignored, since there's already a global scope object property of that name. As we discussed earlier, had we used ", "type": "text"}, {"text": "let name", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we would have shadowed ", "type": "text"}, {"text": "window.name", "type": "text", "marks": [{"type": "code"}]}, {"text": " with a separate global ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But the truly surprising behavior is that even though we assigned the number ", "type": "text"}, {"text": "42", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and thus ", "type": "text"}, {"text": "window.name", "type": "text", "marks": [{"type": "code"}]}, {"text": "), when we then retrieve its value, it's a string ", "type": "text"}, {"text": "\"42\"", "type": "text", "marks": [{"type": "code"}]}, {"text": "! In this case, the weirdness is because ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " is actually a pre-defined getter/setter on the ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " object, which insists on its value being a string value. Yikes!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With the exception of some rare corner cases like DOM element ID's and ", "type": "text"}, {"text": "window.name", "type": "text", "marks": [{"type": "code"}]}, {"text": ", JS running as a standalone file in a browser page has some of the most ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " global scope behavior we will encounter.", "type": "text"}]}]}, "article_text": "Browser \"Window\"\n\nWith respect to treatment of the global scope, the most pure environment JS can be run in is as a standalone .js file loaded in a web page environment in a browser. I don't mean \"pure\" as in nothing automatically added\u2014lots may be added!\u2014but rather in terms of minimal intrusion on the code or interference with its expected global scope behavior.\n\nConsider this .js file:\n\nvar studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nThis code may be loaded in a web page environment using an inline <script> tag, a <script src=..> script tag in the markup, or even a dynamically created <script> DOM element. In all three cases, the studentName and hello identifiers are declared in the global scope.\n\nThat means if you access the global object (commonly, window in the browser), you'll find properties of those same names there:\n\nvar studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ window.studentName }!`);\n}\n\nwindow.hello();\n// Hello, Kyle!\n\nThat's the default behavior one would expect from a reading of the JS specification: the outer scope is the global scope and studentName is legitimately created as global variable.\n\nThat's what I mean by pure. But unfortunately, that won't always be true of all JS environments you encounter, and that's often surprising to JS developers.\n\nGlobals Shadowing Globals\n\nRecall the discussion of shadowing (and global unshadowing) from Chapter 3, where one variable declaration can override and prevent access to a declaration of the same name from an outer scope.\n\nAn unusual consequence of the difference between a global variable and a global property of the same name is that, within just the global scope itself, a global object property can be shadowed by a global variable:\n\nwindow.something = 42;\n\nlet something = \"Kyle\";\n\nconsole.log(something);\n// Kyle\n\nconsole.log(window.something);\n// 42\n\nThe let declaration adds a something global variable but not a global object property (see Chapter 3). The effect then is that the something lexical identifier shadows the something global object property.\n\nIt's almost certainly a bad idea to create a divergence between the global object and the global scope. Readers of your code will almost certainly be tripped up.\n\nA simple way to avoid this gotcha with global declarations: always use var for globals. Reserve let and const for block scopes (see \"Scoping with Blocks\" in Chapter 6).\n\nDOM Globals\n\nI asserted that a browser-hosted JS environment has the most pure global scope behavior we'll see. However, it's not entirely pure.\n\nOne surprising behavior in the global scope you may encounter with browser-based JS applications: a DOM element with an id attribute automatically creates a global variable that references it.\n\nConsider this markup:\n\n<ul id=\"my-todo-list\">\n   <li id=\"first\">Write a book</li>\n   ..\n</ul>\n\n\nAnd the JS for that page could include:\n\nfirst;\n// <li id=\"first\">..</li>\n\nwindow[\"my-todo-list\"];\n// <ul id=\"my-todo-list\">..</ul>\n\nIf the id value is a valid lexical name (like first), the lexical variable is created. If not, the only way to access that global is through the global object (window[..]).\n\nThe auto-registration of all id-bearing DOM elements as global variables is an old legacy browser behavior that nevertheless must remain because so many old sites still rely on it. My advice is never to use these global variables, even though they will always be silently created.\n\nWhat's in a (Window) Name?\n\nAnother global scope oddity in browser-based JS:\n\nvar name = 42;\n\nconsole.log(name, typeof name);\n// \"42\" string\n\nwindow.name is a pre-defined \"global\" in a browser context; it's a property on the global object, so it seems like a normal global variable (yet it's anything but \"normal\").\n\nWe used var for our declaration, which does not shadow the pre-defined name global property. That means, effectively, the var declaration is ignored, since there's already a global scope object property of that name. As we discussed earlier, had we used let name, we would have shadowed window.name with a separate global name variable.\n\nBut the truly surprising behavior is that even though we assigned the number 42 to name (and thus window.name), when we then retrieve its value, it's a string \"42\"! In this case, the weirdness is because name is actually a pre-defined getter/setter on the window object, which insists on its value being a string value. Yikes!\n\nWith the exception of some rare corner cases like DOM element ID's and window.name, JS running as a standalone file in a browser page has some of the most pure global scope behavior we will encounter."}, "id": 194}, {"data": {"uuid": "eabb9d44-ed32-42b5-9c5a-23fdce9c1510", "user": 1, "title": "Web Workers", "author": "Kyle Simpson", "created_on": "2023-06-09 01:10:10.410016+00:00", "updated_on": "2023-06-09 01:10:38.905921+00:00", "article_html": "<h3>Web Workers</h3><p>Web Workers are a web platform extension on top of browser-JS behavior, which allows a JS file to run in a completely separate thread (operating system wise) from the thread that's running the main JS program.</p><p>Since these Web Worker programs run on a separate thread, they're restricted in their communications with the main application thread, to avoid/limit race conditions and other complications. Web Worker code does not have access to the DOM, for example. Some web APIs are, however, made available to the worker, such as <code>navigator</code>.</p><p>Since a Web Worker is treated as a wholly separate program, it does not share the global scope with the main JS program. However, the browser's JS engine is still running the code, so we can expect similar <em>purity</em> of its global scope behavior. Since there is no DOM access, the <code>window</code> alias for the global scope doesn't exist.</p><p>In a Web Worker, the global object reference is typically made using <code>self</code>:</p><pre><code>var studentName = \"Kyle\";\nlet studentID = 42;\n\nfunction hello() {\n    console.log(`Hello, ${ self.studentName }!`);\n}\n\nself.hello();\n// Hello, Kyle!\n\nself.studentID;\n// undefined</code></pre><p>Just as with main JS programs, <code>var</code> and <code>function</code> declarations create mirrored properties on the global object (aka, <code>self</code>), where other declarations (<code>let</code>, etc) do not.</p><p>So again, the global scope behavior we're seeing here is about as <em>pure</em> as it gets for running JS programs; perhaps it's even more <em>pure</em> since there's no DOM to muck things up!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Web Workers", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Web Workers are a web platform extension on top of browser-JS behavior, which allows a JS file to run in a completely separate thread (operating system wise) from the thread that's running the main JS program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since these Web Worker programs run on a separate thread, they're restricted in their communications with the main application thread, to avoid/limit race conditions and other complications. Web Worker code does not have access to the DOM, for example. Some web APIs are, however, made available to the worker, such as ", "type": "text"}, {"text": "navigator", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since a Web Worker is treated as a wholly separate program, it does not share the global scope with the main JS program. However, the browser's JS engine is still running the code, so we can expect similar ", "type": "text"}, {"text": "purity", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of its global scope behavior. Since there is no DOM access, the ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " alias for the global scope doesn't exist.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In a Web Worker, the global object reference is typically made using ", "type": "text"}, {"text": "self", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Kyle\";\nlet studentID = 42;\n\nfunction hello() {\n    console.log(`Hello, ${ self.studentName }!`);\n}\n\nself.hello();\n// Hello, Kyle!\n\nself.studentID;\n// undefined", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Just as with main JS programs, ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations create mirrored properties on the global object (aka, ", "type": "text"}, {"text": "self", "type": "text", "marks": [{"type": "code"}]}, {"text": "), where other declarations (", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc) do not.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So again, the global scope behavior we're seeing here is about as ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " as it gets for running JS programs; perhaps it's even more ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " since there's no DOM to muck things up!", "type": "text"}]}]}, "article_text": "Web Workers\n\nWeb Workers are a web platform extension on top of browser-JS behavior, which allows a JS file to run in a completely separate thread (operating system wise) from the thread that's running the main JS program.\n\nSince these Web Worker programs run on a separate thread, they're restricted in their communications with the main application thread, to avoid/limit race conditions and other complications. Web Worker code does not have access to the DOM, for example. Some web APIs are, however, made available to the worker, such as navigator.\n\nSince a Web Worker is treated as a wholly separate program, it does not share the global scope with the main JS program. However, the browser's JS engine is still running the code, so we can expect similar purity of its global scope behavior. Since there is no DOM access, the window alias for the global scope doesn't exist.\n\nIn a Web Worker, the global object reference is typically made using self:\n\nvar studentName = \"Kyle\";\nlet studentID = 42;\n\nfunction hello() {\n    console.log(`Hello, ${ self.studentName }!`);\n}\n\nself.hello();\n// Hello, Kyle!\n\nself.studentID;\n// undefined\n\nJust as with main JS programs, var and function declarations create mirrored properties on the global object (aka, self), where other declarations (let, etc) do not.\n\nSo again, the global scope behavior we're seeing here is about as pure as it gets for running JS programs; perhaps it's even more pure since there's no DOM to muck things up!"}, "id": 195}, {"data": {"uuid": "f738c02d-b431-4d9d-a2f1-4771f64fa25d", "user": 1, "title": "Developer Tools Console/REPL", "author": "Kyle Simpson", "created_on": "2023-06-09 01:10:57.159255+00:00", "updated_on": "2023-06-09 01:11:15.387168+00:00", "article_html": "<h3>Developer Tools Console/REPL</h3><p>Recall from Chapter 1 in <em>Get Started</em> that Developer Tools don't create a completely adherent JS environment. They do process JS code, but they also lean in favor of the UX interaction being most friendly to developers (aka, developer experience, or DX).</p><p>In some cases, favoring DX when typing in short JS snippets, over the normal strict steps expected for processing a full JS program, produces observable differences in code behavior between programs and tools. For example, certain error conditions applicable to a JS program may be relaxed and not displayed when the code is entered into a developer tool.</p><p>With respect to our discussions here about scope, such observable differences in behavior may include:</p><ul><li><p>The behavior of the global scope</p></li><li><p>Hoisting (see Chapter 5)</p></li><li><p>Block-scoping declarators (<code>let</code> / <code>const</code>, see Chapter 6) when used in the outermost scope</p></li></ul><p>Although it might seem, while using the console/REPL, that statements entered in the outermost scope are being processed in the real global scope, that's not quite accurate. Such tools typically emulate the global scope position to an extent; it's emulation, not strict adherence. These tool environments prioritize developer convenience, which means that at times (such as with our current discussions regarding scope), observed behavior may deviate from the JS specification.</p><p>The take-away is that Developer Tools, while optimized to be convenient and useful for a variety of developer activities, are <strong>not</strong> suitable environments to determine or verify explicit and nuanced behaviors of an actual JS program context.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Developer Tools Console/REPL", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall from Chapter 1 in ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that Developer Tools don't create a completely adherent JS environment. They do process JS code, but they also lean in favor of the UX interaction being most friendly to developers (aka, developer experience, or DX).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In some cases, favoring DX when typing in short JS snippets, over the normal strict steps expected for processing a full JS program, produces observable differences in code behavior between programs and tools. For example, certain error conditions applicable to a JS program may be relaxed and not displayed when the code is entered into a developer tool.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With respect to our discussions here about scope, such observable differences in behavior may include:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The behavior of the global scope", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Hoisting (see Chapter 5)", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Block-scoping declarators (", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", see Chapter 6) when used in the outermost scope", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Although it might seem, while using the console/REPL, that statements entered in the outermost scope are being processed in the real global scope, that's not quite accurate. Such tools typically emulate the global scope position to an extent; it's emulation, not strict adherence. These tool environments prioritize developer convenience, which means that at times (such as with our current discussions regarding scope), observed behavior may deviate from the JS specification.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The take-away is that Developer Tools, while optimized to be convenient and useful for a variety of developer activities, are ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " suitable environments to determine or verify explicit and nuanced behaviors of an actual JS program context.", "type": "text"}]}]}, "article_text": "Developer Tools Console/REPL\n\nRecall from Chapter 1 in Get Started that Developer Tools don't create a completely adherent JS environment. They do process JS code, but they also lean in favor of the UX interaction being most friendly to developers (aka, developer experience, or DX).\n\nIn some cases, favoring DX when typing in short JS snippets, over the normal strict steps expected for processing a full JS program, produces observable differences in code behavior between programs and tools. For example, certain error conditions applicable to a JS program may be relaxed and not displayed when the code is entered into a developer tool.\n\nWith respect to our discussions here about scope, such observable differences in behavior may include:\n\nThe behavior of the global scope\n\nHoisting (see Chapter 5)\n\nBlock-scoping declarators (let / const, see Chapter 6) when used in the outermost scope\n\nAlthough it might seem, while using the console/REPL, that statements entered in the outermost scope are being processed in the real global scope, that's not quite accurate. Such tools typically emulate the global scope position to an extent; it's emulation, not strict adherence. These tool environments prioritize developer convenience, which means that at times (such as with our current discussions regarding scope), observed behavior may deviate from the JS specification.\n\nThe take-away is that Developer Tools, while optimized to be convenient and useful for a variety of developer activities, are not suitable environments to determine or verify explicit and nuanced behaviors of an actual JS program context."}, "id": 196}, {"data": {"uuid": "a1c21388-75b2-43fa-81c0-03f33038ecd7", "user": 1, "title": "ES Modules (ESM)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:11:37.652100+00:00", "updated_on": "2023-06-09 01:11:58.538454+00:00", "article_html": "<h3>ES Modules (ESM)</h3><p>ES6 introduced first-class support for the module pattern (covered in Chapter 8). One of the most obvious impacts of using ESM is how it changes the behavior of the observably top-level scope in a file.</p><p>Recall this code snippet from earlier (which we'll adjust to ESM format by using the <code>export</code> keyword):</p><pre><code>var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nexport hello;</code></pre><p>If that code is in a file that's loaded as an ES module, it will still run exactly the same. However, the observable effects, from the overall application perspective, will be different.</p><p>Despite being declared at the top level of the (module) file, in the outermost obvious scope, <code>studentName</code> and <code>hello</code> are not global variables. Instead, they are module-wide, or if you prefer, \"module-global.\"</p><p>However, in a module there's no implicit \"module-wide scope object\" for these top-level declarations to be added to as properties, as there is when declarations appear in the top-level of non-module JS files. This is not to say that global variables cannot exist or be accessed in such programs. It's just that global variables don't get <em>created</em> by declaring variables in the top-level scope of a module.</p><p>The module's top-level scope is descended from the global scope, almost as if the entire contents of the module were wrapped in a function. Thus, all variables that exist in the global scope (whether they're on the global object or not!) are available as lexical identifiers from inside the module's scope.</p><p>ESM encourages a minimization of reliance on the global scope, where you import whatever modules you may need for the current module to operate. As such, you less often see usage of the global scope or its global object.</p><p>However, as noted earlier, there are still plenty of JS and web globals that you will continue to access from the global scope, whether you realize it or not!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "ES Modules (ESM)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES6 introduced first-class support for the module pattern (covered in Chapter 8). One of the most obvious impacts of using ESM is how it changes the behavior of the observably top-level scope in a file.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall this code snippet from earlier (which we'll adjust to ESM format by using the ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nexport hello;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If that code is in a file that's loaded as an ES module, it will still run exactly the same. However, the observable effects, from the overall application perspective, will be different.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Despite being declared at the top level of the (module) file, in the outermost obvious scope, ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " are not global variables. Instead, they are module-wide, or if you prefer, \"module-global.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However, in a module there's no implicit \"module-wide scope object\" for these top-level declarations to be added to as properties, as there is when declarations appear in the top-level of non-module JS files. This is not to say that global variables cannot exist or be accessed in such programs. It's just that global variables don't get ", "type": "text"}, {"text": "created", "type": "text", "marks": [{"type": "italic"}]}, {"text": " by declaring variables in the top-level scope of a module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The module's top-level scope is descended from the global scope, almost as if the entire contents of the module were wrapped in a function. Thus, all variables that exist in the global scope (whether they're on the global object or not!) are available as lexical identifiers from inside the module's scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ESM encourages a minimization of reliance on the global scope, where you import whatever modules you may need for the current module to operate. As such, you less often see usage of the global scope or its global object.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However, as noted earlier, there are still plenty of JS and web globals that you will continue to access from the global scope, whether you realize it or not!", "type": "text"}]}]}, "article_text": "ES Modules (ESM)\n\nES6 introduced first-class support for the module pattern (covered in Chapter 8). One of the most obvious impacts of using ESM is how it changes the behavior of the observably top-level scope in a file.\n\nRecall this code snippet from earlier (which we'll adjust to ESM format by using the export keyword):\n\nvar studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nexport hello;\n\nIf that code is in a file that's loaded as an ES module, it will still run exactly the same. However, the observable effects, from the overall application perspective, will be different.\n\nDespite being declared at the top level of the (module) file, in the outermost obvious scope, studentName and hello are not global variables. Instead, they are module-wide, or if you prefer, \"module-global.\"\n\nHowever, in a module there's no implicit \"module-wide scope object\" for these top-level declarations to be added to as properties, as there is when declarations appear in the top-level of non-module JS files. This is not to say that global variables cannot exist or be accessed in such programs. It's just that global variables don't get created by declaring variables in the top-level scope of a module.\n\nThe module's top-level scope is descended from the global scope, almost as if the entire contents of the module were wrapped in a function. Thus, all variables that exist in the global scope (whether they're on the global object or not!) are available as lexical identifiers from inside the module's scope.\n\nESM encourages a minimization of reliance on the global scope, where you import whatever modules you may need for the current module to operate. As such, you less often see usage of the global scope or its global object.\n\nHowever, as noted earlier, there are still plenty of JS and web globals that you will continue to access from the global scope, whether you realize it or not!"}, "id": 197}, {"data": {"uuid": "7a07ffcc-12d5-4068-9dfc-12d1c89f2a60", "user": 1, "title": "Node", "author": "Kyle Simpson", "created_on": "2023-06-09 01:12:20.204485+00:00", "updated_on": "2023-06-09 01:12:42.882590+00:00", "article_html": "<h3>Node</h3><p>One aspect of Node that often catches JS developers off-guard is that Node treats every single .js file that it loads, including the main one you start the Node process with, as a <em>module</em> (ES module or CommonJS module, see Chapter 8). The practical effect is that the top level of your Node programs <strong>is never actually the global scope</strong>, the way it is when loading a non-module file in the browser.</p><p>As of time of this writing, Node has recently added support for ES modules. But additionally, Node has from its beginning supported a module format referred to as \"CommonJS\", which looks like this:</p><pre><code>var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;</code></pre><p>Before processing, Node effectively wraps such code in a function, so that the <code>var</code> and <code>function</code> declarations are contained in that wrapping function's scope, <strong>not</strong> treated as global variables.</p><p>Envision the preceding code as being seen by Node as this (illustrative, not actual):</p><pre><code>function Module(module,require,__dirname,...) {\n    var studentName = \"Kyle\";\n\n    function hello() {\n        console.log(`Hello, ${ studentName }!`);\n    }\n\n    hello();\n    // Hello, Kyle!\n\n    module.exports.hello = hello;\n}</code></pre><p>Node then essentially invokes the added <code>Module(..)</code> function to run your module. You can clearly see here why <code>studentName</code> and <code>hello</code> identifiers are not global, but rather declared in the module scope.</p><p>As noted earlier, Node defines a number of \"globals\" like <code>require()</code>, but they're not actually identifiers in the global scope (nor properties of the global object). They're injected in the scope of every module, essentially a bit like the parameters listed in the <code>Module(..)</code> function declaration.</p><p>So how do you define actual global variables in Node? The only way to do so is to add properties to another of Node's automatically provided \"globals,\" which is ironically called <code>global</code>. <code>global</code> is a reference to the real global scope object, somewhat like using <code>window</code> in a browser JS environment.</p><p>Consider:</p><pre><code>global.studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;</code></pre><p>Here we add <code>studentName</code> as a property on the <code>global</code> object, and then in the <code>console.log(..)</code> statement we're able to access <code>studentName</code> as a normal global variable.</p><p>Remember, the identifier <code>global</code> is not defined by JS; it's specifically defined by Node.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Node", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One aspect of Node that often catches JS developers off-guard is that Node treats every single .js file that it loads, including the main one you start the Node process with, as a ", "type": "text"}, {"text": "module", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (ES module or CommonJS module, see Chapter 8). The practical effect is that the top level of your Node programs ", "type": "text"}, {"text": "is never actually the global scope", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", the way it is when loading a non-module file in the browser.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As of time of this writing, Node has recently added support for ES modules. But additionally, Node has from its beginning supported a module format referred to as \"CommonJS\", which looks like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Before processing, Node effectively wraps such code in a function, so that the ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations are contained in that wrapping function's scope, ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " treated as global variables.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Envision the preceding code as being seen by Node as this (illustrative, not actual):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function Module(module,require,__dirname,...) {\n    var studentName = \"Kyle\";\n\n    function hello() {\n        console.log(`Hello, ${ studentName }!`);\n    }\n\n    hello();\n    // Hello, Kyle!\n\n    module.exports.hello = hello;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Node then essentially invokes the added ", "type": "text"}, {"text": "Module(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function to run your module. You can clearly see here why ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifiers are not global, but rather declared in the module scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As noted earlier, Node defines a number of \"globals\" like ", "type": "text"}, {"text": "require()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but they're not actually identifiers in the global scope (nor properties of the global object). They're injected in the scope of every module, essentially a bit like the parameters listed in the ", "type": "text"}, {"text": "Module(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function declaration.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So how do you define actual global variables in Node? The only way to do so is to add properties to another of Node's automatically provided \"globals,\" which is ironically called ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": ". ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a reference to the real global scope object, somewhat like using ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " in a browser JS environment.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "global.studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here we add ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a property on the ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": " object, and then in the ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement we're able to access ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a normal global variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember, the identifier ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not defined by JS; it's specifically defined by Node.", "type": "text"}]}]}, "article_text": "Node\n\nOne aspect of Node that often catches JS developers off-guard is that Node treats every single .js file that it loads, including the main one you start the Node process with, as a module (ES module or CommonJS module, see Chapter 8). The practical effect is that the top level of your Node programs is never actually the global scope, the way it is when loading a non-module file in the browser.\n\nAs of time of this writing, Node has recently added support for ES modules. But additionally, Node has from its beginning supported a module format referred to as \"CommonJS\", which looks like this:\n\nvar studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;\n\nBefore processing, Node effectively wraps such code in a function, so that the var and function declarations are contained in that wrapping function's scope, not treated as global variables.\n\nEnvision the preceding code as being seen by Node as this (illustrative, not actual):\n\nfunction Module(module,require,__dirname,...) {\n    var studentName = \"Kyle\";\n\n    function hello() {\n        console.log(`Hello, ${ studentName }!`);\n    }\n\n    hello();\n    // Hello, Kyle!\n\n    module.exports.hello = hello;\n}\n\nNode then essentially invokes the added Module(..) function to run your module. You can clearly see here why studentName and hello identifiers are not global, but rather declared in the module scope.\n\nAs noted earlier, Node defines a number of \"globals\" like require(), but they're not actually identifiers in the global scope (nor properties of the global object). They're injected in the scope of every module, essentially a bit like the parameters listed in the Module(..) function declaration.\n\nSo how do you define actual global variables in Node? The only way to do so is to add properties to another of Node's automatically provided \"globals,\" which is ironically called global. global is a reference to the real global scope object, somewhat like using window in a browser JS environment.\n\nConsider:\n\nglobal.studentName = \"Kyle\";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;\n\nHere we add studentName as a property on the global object, and then in the console.log(..) statement we're able to access studentName as a normal global variable.\n\nRemember, the identifier global is not defined by JS; it's specifically defined by Node."}, "id": 198}]}, {"data": {"uuid": "7ef1cd1b-428e-4280-9d60-56f6e4c3bde6", "user": 1, "title": "Global This", "author": "Kyle Simpson", "created_on": "2023-06-09 01:15:21.585605+00:00", "updated_on": "2023-06-09 01:15:41.827329+00:00", "article_html": "<h2>Global This</h2><p>Reviewing the JS environments we've looked at so far, a program may or may not:</p><ul><li><p>Declare a global variable in the top-level scope with <code>var</code> or <code>function</code> declarations\u2014or <code>let</code>, <code>const</code>, and <code>class</code>.</p></li><li><p>Also add global variables declarations as properties of the global scope object if <code>var</code> or <code>function</code> are used for the declaration.</p></li><li><p>Refer to the global scope object (for adding or retrieving global variables, as properties) with <code>window</code>, <code>self</code>, or <code>global</code>.</p></li></ul><p>I think it's fair to say that global scope access and behavior is more complicated than most developers assume, as the preceding sections have illustrated. But the complexity is never more obvious than in trying to nail down a universally applicable reference to the global scope object.</p><p>Yet another \"trick\" for obtaining a reference to the global scope object looks like:</p><pre><code>const theGlobalScopeObject =\n    (new Function(\"return this\"))();</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>A function can be dynamically constructed from code stored in a string value with the <code>Function()</code> constructor, similar to <code>eval(..)</code> (see \"Cheating: Runtime Scope Modifications\" in Chapter 1). Such a function will automatically be run in non-strict-mode (for legacy reasons) when invoked with the normal <code>()</code> function invocation as shown; its <code>this</code> will point at the global object. See the third book in the series, <em>Objects &amp; Classes</em>, for more information on determining <code>this</code> bindings.</p></td></tr></tbody></table><p>So, we have <code>window</code>, <code>self</code>, <code>global</code>, and this ugly <code>new Function(..)</code> trick. That's a lot of different ways to try to get at this global object. Each has its pros and cons.</p><p>Why not introduce yet another!?!?</p><p>As of ES2020, JS has finally defined a standardized reference to the global scope object, called <code>globalThis</code>. So, subject to the recency of the JS engines your code runs in, you can use <code>globalThis</code> in place of any of those other approaches.</p><p>We could even attempt to define a cross-environment polyfill that's safer across pre-<code>globalThis</code> JS environments, such as:</p><pre><code>const theGlobalScopeObject =\n    (typeof globalThis != \"undefined\") ? globalThis :\n    (typeof global != \"undefined\") ? global :\n    (typeof window != \"undefined\") ? window :\n    (typeof self != \"undefined\") ? self :\n    (new Function(\"return this\"))();</code></pre><p>Phew! That's certainly not ideal, but it works if you find yourself needing a reliable global scope reference.</p><p>(The proposed name <code>globalThis</code> was fairly controversial while the feature was being added to JS. Specifically, I and many others felt the \"this\" reference in its name was misleading, since the reason you reference this object is to access to the global scope, never to access some sort of global/default <code>this</code> binding. There were many other names considered, but for a variety of reasons ruled out. Unfortunately, the name chosen ended up as a last resort. If you plan to interact with the global scope object in your programs, to reduce confusion, I strongly recommend choosing a better name, such as (the laughably long but accurate!) <code>theGlobalScopeObject</code> used here.)</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Global This", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Reviewing the JS environments we've looked at so far, a program may or may not:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Declare a global variable in the top-level scope with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations\u2014or ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Also add global variables declarations as properties of the global scope object if ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " are used for the declaration.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Refer to the global scope object (for adding or retrieving global variables, as properties) with ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "self", "type": "text", "marks": [{"type": "code"}]}, {"text": ", or ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "I think it's fair to say that global scope access and behavior is more complicated than most developers assume, as the preceding sections have illustrated. But the complexity is never more obvious than in trying to nail down a universally applicable reference to the global scope object.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Yet another \"trick\" for obtaining a reference to the global scope object looks like:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const theGlobalScopeObject =\n    (new Function(\"return this\"))();", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "A function can be dynamically constructed from code stored in a string value with the ", "type": "text"}, {"text": "Function()", "type": "text", "marks": [{"type": "code"}]}, {"text": " constructor, similar to ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (see \"Cheating: Runtime Scope Modifications\" in Chapter 1). Such a function will automatically be run in non-strict-mode (for legacy reasons) when invoked with the normal ", "type": "text"}, {"text": "()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function invocation as shown; its ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " will point at the global object. See the third book in the series, ", "type": "text"}, {"text": "Objects & Classes", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", for more information on determining ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " bindings.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "So, we have ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "self", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "global", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and this ugly ", "type": "text"}, {"text": "new Function(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " trick. That's a lot of different ways to try to get at this global object. Each has its pros and cons.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why not introduce yet another!?!?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As of ES2020, JS has finally defined a standardized reference to the global scope object, called ", "type": "text"}, {"text": "globalThis", "type": "text", "marks": [{"type": "code"}]}, {"text": ". So, subject to the recency of the JS engines your code runs in, you can use ", "type": "text"}, {"text": "globalThis", "type": "text", "marks": [{"type": "code"}]}, {"text": " in place of any of those other approaches.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We could even attempt to define a cross-environment polyfill that's safer across pre-", "type": "text"}, {"text": "globalThis", "type": "text", "marks": [{"type": "code"}]}, {"text": " JS environments, such as:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const theGlobalScopeObject =\n    (typeof globalThis != \"undefined\") ? globalThis :\n    (typeof global != \"undefined\") ? global :\n    (typeof window != \"undefined\") ? window :\n    (typeof self != \"undefined\") ? self :\n    (new Function(\"return this\"))();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Phew! That's certainly not ideal, but it works if you find yourself needing a reliable global scope reference.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "(The proposed name ", "type": "text"}, {"text": "globalThis", "type": "text", "marks": [{"type": "code"}]}, {"text": " was fairly controversial while the feature was being added to JS. Specifically, I and many others felt the \"this\" reference in its name was misleading, since the reason you reference this object is to access to the global scope, never to access some sort of global/default ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " binding. There were many other names considered, but for a variety of reasons ruled out. Unfortunately, the name chosen ended up as a last resort. If you plan to interact with the global scope object in your programs, to reduce confusion, I strongly recommend choosing a better name, such as (the laughably long but accurate!) ", "type": "text"}, {"text": "theGlobalScopeObject", "type": "text", "marks": [{"type": "code"}]}, {"text": " used here.)", "type": "text"}]}]}, "article_text": "Global This\n\nReviewing the JS environments we've looked at so far, a program may or may not:\n\nDeclare a global variable in the top-level scope with var or function declarations\u2014or let, const, and class.\n\nAlso add global variables declarations as properties of the global scope object if var or function are used for the declaration.\n\nRefer to the global scope object (for adding or retrieving global variables, as properties) with window, self, or global.\n\nI think it's fair to say that global scope access and behavior is more complicated than most developers assume, as the preceding sections have illustrated. But the complexity is never more obvious than in trying to nail down a universally applicable reference to the global scope object.\n\nYet another \"trick\" for obtaining a reference to the global scope object looks like:\n\nconst theGlobalScopeObject =\n    (new Function(\"return this\"))();\n\nNOTE:\n\nA function can be dynamically constructed from code stored in a string value with the Function() constructor, similar to eval(..) (see \"Cheating: Runtime Scope Modifications\" in Chapter 1). Such a function will automatically be run in non-strict-mode (for legacy reasons) when invoked with the normal () function invocation as shown; its this will point at the global object. See the third book in the series, Objects & Classes, for more information on determining this bindings.\n\nSo, we have window, self, global, and this ugly new Function(..) trick. That's a lot of different ways to try to get at this global object. Each has its pros and cons.\n\nWhy not introduce yet another!?!?\n\nAs of ES2020, JS has finally defined a standardized reference to the global scope object, called globalThis. So, subject to the recency of the JS engines your code runs in, you can use globalThis in place of any of those other approaches.\n\nWe could even attempt to define a cross-environment polyfill that's safer across pre-globalThis JS environments, such as:\n\nconst theGlobalScopeObject =\n    (typeof globalThis != \"undefined\") ? globalThis :\n    (typeof global != \"undefined\") ? global :\n    (typeof window != \"undefined\") ? window :\n    (typeof self != \"undefined\") ? self :\n    (new Function(\"return this\"))();\n\nPhew! That's certainly not ideal, but it works if you find yourself needing a reliable global scope reference.\n\n(The proposed name globalThis was fairly controversial while the feature was being added to JS. Specifically, I and many others felt the \"this\" reference in its name was misleading, since the reason you reference this object is to access to the global scope, never to access some sort of global/default this binding. There were many other names considered, but for a variety of reasons ruled out. Unfortunately, the name chosen ended up as a last resort. If you plan to interact with the global scope object in your programs, to reduce confusion, I strongly recommend choosing a better name, such as (the laughably long but accurate!) theGlobalScopeObject used here.)"}, "id": 199}, {"data": {"uuid": "a583b1b8-b3d8-465a-9f0f-8cc5dda5206c", "user": 1, "title": "Globally Aware", "author": "Kyle Simpson", "created_on": "2023-06-09 01:16:02.676608+00:00", "updated_on": "2023-06-09 01:16:14.422751+00:00", "article_html": "<h2>Globally Aware</h2><p>The global scope is present and relevant in every JS program, even though modern patterns for organizing code into modules de-emphasizes much of the reliance on storing identifiers in that namespace.</p><p>Still, as our code proliferates more and more beyond the confines of the browser, it's especially important we have a solid grasp on the differences in how the global scope (and global scope object!) behave across different JS environments.</p><p>With the big picture of global scope now sharper in focus, the next chapter again descends into the deeper details of lexical scope, examining how and when variables can be used.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Globally Aware", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The global scope is present and relevant in every JS program, even though modern patterns for organizing code into modules de-emphasizes much of the reliance on storing identifiers in that namespace.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Still, as our code proliferates more and more beyond the confines of the browser, it's especially important we have a solid grasp on the differences in how the global scope (and global scope object!) behave across different JS environments.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With the big picture of global scope now sharper in focus, the next chapter again descends into the deeper details of lexical scope, examining how and when variables can be used.", "type": "text"}]}]}, "article_text": "Globally Aware\n\nThe global scope is present and relevant in every JS program, even though modern patterns for organizing code into modules de-emphasizes much of the reliance on storing identifiers in that namespace.\n\nStill, as our code proliferates more and more beyond the confines of the browser, it's especially important we have a solid grasp on the differences in how the global scope (and global scope object!) behave across different JS environments.\n\nWith the big picture of global scope now sharper in focus, the next chapter again descends into the deeper details of lexical scope, examining how and when variables can be used."}, "id": 200}]}, {"data": {"uuid": "1bba66e9-33e3-43a6-9eac-b14c5bfef0d2", "user": 1, "title": "Chapter 5: The (Not So) Secret Lifecycle of Variables", "author": "Kyle Simpson", "created_on": "2023-06-09 01:17:03.502822+00:00", "updated_on": "2023-06-09 01:17:59.214223+00:00", "article_html": "<h1>Chapter 5: The (Not So) Secret Lifecycle of Variables</h1><p>By now you should have a decent grasp of the nesting of scopes, from the global scope downward\u2014called a program's scope chain.</p><p>But just knowing which scope a variable comes from is only part of the story. If a variable declaration appears past the first statement of a scope, how will any references to that identifier <em>before</em> the declaration behave? What happens if you try to declare the same variable twice in a scope?</p><p>JS's particular flavor of lexical scope is rich with nuance in how and when variables come into existence and become available to the program.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 5: The (Not So) Secret Lifecycle of Variables", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By now you should have a decent grasp of the nesting of scopes, from the global scope downward\u2014called a program's scope chain.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But just knowing which scope a variable comes from is only part of the story. If a variable declaration appears past the first statement of a scope, how will any references to that identifier ", "type": "text"}, {"text": "before", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the declaration behave? What happens if you try to declare the same variable twice in a scope?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS's particular flavor of lexical scope is rich with nuance in how and when variables come into existence and become available to the program.", "type": "text"}]}]}, "article_text": "Chapter 5: The (Not So) Secret Lifecycle of Variables\n\nBy now you should have a decent grasp of the nesting of scopes, from the global scope downward\u2014called a program's scope chain.\n\nBut just knowing which scope a variable comes from is only part of the story. If a variable declaration appears past the first statement of a scope, how will any references to that identifier before the declaration behave? What happens if you try to declare the same variable twice in a scope?\n\nJS's particular flavor of lexical scope is rich with nuance in how and when variables come into existence and become available to the program."}, "id": 201, "children": [{"data": {"uuid": "189c6301-80d8-4737-bb98-afbccc0d6cc2", "user": 1, "title": "When Can I Use a Variable?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:18:21.478069+00:00", "updated_on": "2023-06-09 01:18:36.851809+00:00", "article_html": "<h2>When Can I Use a Variable?</h2><p>At what point does a variable become available to use within its scope? There may seem to be an obvious answer: <em>after</em> the variable has been declared/created. Right? Not quite.</p><p>Consider:</p><pre><code>greeting();\n// Hello!\n\nfunction greeting() {\n    console.log(\"Hello!\");\n}</code></pre><p>This code works fine. You may have seen or even written code like it before. But did you ever wonder how or why it works? Specifically, why can you access the identifier <code>greeting</code> from line 1 (to retrieve and execute a function reference), even though the <code>greeting()</code> function declaration doesn't occur until line 4?</p><p>Recall Chapter 1 points out that all identifiers are registered to their respective scopes during compile time. Moreover, every identifier is <em>created</em> at the beginning of the scope it belongs to, <strong>every time that scope is entered</strong>.</p><p>The term most commonly used for a variable being visible from the beginning of its enclosing scope, even though its declaration may appear further down in the scope, is called <strong>hoisting</strong>.</p><p>But hoisting alone doesn't fully answer the question. We can see an identifier called <code>greeting</code> from the beginning of the scope, but why can we <strong>call</strong> the <code>greeting()</code> function before it's been declared?</p><p>In other words, how does the variable <code>greeting</code> have any value (the function reference) assigned to it, from the moment the scope starts running? The answer is a special characteristic of formal <code>function</code> declarations, called <em>function hoisting</em>. When a <code>function</code> declaration's name identifier is registered at the top of its scope, it's additionally auto-initialized to that function's reference. That's why the function can be called throughout the entire scope!</p><p>One key detail is that both <em>function hoisting</em> and <code>var</code>-flavored <em>variable hoisting</em> attach their name identifiers to the nearest enclosing <strong>function scope</strong> (or, if none, the global scope), not a block scope.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Declarations with <code>let</code> and <code>const</code> still hoist (see the TDZ discussion later in this chapter). But these two declaration forms attach to their enclosing block rather than just an enclosing function as with <code>var</code> and <code>function</code> declarations. See \"Scoping with Blocks\" in Chapter 6 for more information.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "When Can I Use a Variable?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "At what point does a variable become available to use within its scope? There may seem to be an obvious answer: ", "type": "text"}, {"text": "after", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the variable has been declared/created. Right? Not quite.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "greeting();\n// Hello!\n\nfunction greeting() {\n    console.log(\"Hello!\");\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This code works fine. You may have seen or even written code like it before. But did you ever wonder how or why it works? Specifically, why can you access the identifier ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " from line 1 (to retrieve and execute a function reference), even though the ", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function declaration doesn't occur until line 4?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall Chapter 1 points out that all identifiers are registered to their respective scopes during compile time. Moreover, every identifier is ", "type": "text"}, {"text": "created", "type": "text", "marks": [{"type": "italic"}]}, {"text": " at the beginning of the scope it belongs to, ", "type": "text"}, {"text": "every time that scope is entered", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The term most commonly used for a variable being visible from the beginning of its enclosing scope, even though its declaration may appear further down in the scope, is called ", "type": "text"}, {"text": "hoisting", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But hoisting alone doesn't fully answer the question. We can see an identifier called ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " from the beginning of the scope, but why can we ", "type": "text"}, {"text": "call", "type": "text", "marks": [{"type": "bold"}]}, {"text": " the ", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function before it's been declared?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, how does the variable ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " have any value (the function reference) assigned to it, from the moment the scope starts running? The answer is a special characteristic of formal ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations, called ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". When a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration's name identifier is registered at the top of its scope, it's additionally auto-initialized to that function's reference. That's why the function can be called throughout the entire scope!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One key detail is that both ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "-flavored ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " attach their name identifiers to the nearest enclosing ", "type": "text"}, {"text": "function scope", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (or, if none, the global scope), not a block scope.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Declarations with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " still hoist (see the TDZ discussion later in this chapter). But these two declaration forms attach to their enclosing block rather than just an enclosing function as with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations. See \"Scoping with Blocks\" in Chapter 6 for more information.", "type": "text"}]}]}]}]}]}, "article_text": "When Can I Use a Variable?\n\nAt what point does a variable become available to use within its scope? There may seem to be an obvious answer: after the variable has been declared/created. Right? Not quite.\n\nConsider:\n\ngreeting();\n// Hello!\n\nfunction greeting() {\n    console.log(\"Hello!\");\n}\n\nThis code works fine. You may have seen or even written code like it before. But did you ever wonder how or why it works? Specifically, why can you access the identifier greeting from line 1 (to retrieve and execute a function reference), even though the greeting() function declaration doesn't occur until line 4?\n\nRecall Chapter 1 points out that all identifiers are registered to their respective scopes during compile time. Moreover, every identifier is created at the beginning of the scope it belongs to, every time that scope is entered.\n\nThe term most commonly used for a variable being visible from the beginning of its enclosing scope, even though its declaration may appear further down in the scope, is called hoisting.\n\nBut hoisting alone doesn't fully answer the question. We can see an identifier called greeting from the beginning of the scope, but why can we call the greeting() function before it's been declared?\n\nIn other words, how does the variable greeting have any value (the function reference) assigned to it, from the moment the scope starts running? The answer is a special characteristic of formal function declarations, called function hoisting. When a function declaration's name identifier is registered at the top of its scope, it's additionally auto-initialized to that function's reference. That's why the function can be called throughout the entire scope!\n\nOne key detail is that both function hoisting and var-flavored variable hoisting attach their name identifiers to the nearest enclosing function scope (or, if none, the global scope), not a block scope.\n\nNOTE:\n\nDeclarations with let and const still hoist (see the TDZ discussion later in this chapter). But these two declaration forms attach to their enclosing block rather than just an enclosing function as with var and function declarations. See \"Scoping with Blocks\" in Chapter 6 for more information."}, "id": 202, "children": [{"data": {"uuid": "add91914-a355-4335-a208-40e9dc652905", "user": 1, "title": "Hoisting: Declaration vs. Expression", "author": "Kyle Simpson", "created_on": "2023-06-09 01:18:52.704515+00:00", "updated_on": "2023-06-09 01:19:10.631259+00:00", "article_html": "<h3>Hoisting: Declaration vs. Expression</h3><p><em>Function hoisting</em> only applies to formal <code>function</code> declarations (specifically those which appear outside of blocks\u2014see \"FiB\" in Chapter 6), not to <code>function</code> expression assignments. Consider:</p><pre><code>greeting();\n// TypeError\n\nvar greeting = function greeting() {\n    console.log(\"Hello!\");\n};</code></pre><p>Line 1 (<code>greeting();</code>) throws an error. But the <em>kind</em> of error thrown is very important to notice. A <code>TypeError</code> means we're trying to do something with a value that is not allowed. Depending on your JS environment, the error message would say something like, \"'undefined' is not a function,\" or more helpfully, \"'greeting' is not a function.\"</p><p>Notice that the error is <strong>not</strong> a <code>ReferenceError</code>. JS isn't telling us that it couldn't find <code>greeting</code> as an identifier in the scope. It's telling us that <code>greeting</code> was found but doesn't hold a function reference at that moment. Only functions can be invoked, so attempting to invoke some non-function value results in an error.</p><p>But what does <code>greeting</code> hold, if not the function reference?</p><p>In addition to being hoisted, variables declared with <code>var</code> are also automatically initialized to <code>undefined</code> at the beginning of their scope\u2014again, the nearest enclosing function, or the global. Once initialized, they're available to be used (assigned to, retrieved from, etc.) throughout the whole scope.</p><p>So on that first line, <code>greeting</code> exists, but it holds only the default <code>undefined</code> value. It's not until line 4 that <code>greeting</code> gets assigned the function reference.</p><p>Pay close attention to the distinction here. A <code>function</code> declaration is hoisted <strong>and initialized to its function value</strong> (again, called <em>function hoisting</em>). A <code>var</code> variable is also hoisted, and then auto-initialized to <code>undefined</code>. Any subsequent <code>function</code> expression assignments to that variable don't happen until that assignment is processed during runtime execution.</p><p>In both cases, the name of the identifier is hoisted. But the function reference association isn't handled at initialization time (beginning of the scope) unless the identifier was created in a formal <code>function</code> declaration.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Hoisting: Declaration vs. Expression", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " only applies to formal ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations (specifically those which appear outside of blocks\u2014see \"FiB\" in Chapter 6), not to ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression assignments. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "greeting();\n// TypeError\n\nvar greeting = function greeting() {\n    console.log(\"Hello!\");\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Line 1 (", "type": "text"}, {"text": "greeting();", "type": "text", "marks": [{"type": "code"}]}, {"text": ") throws an error. But the ", "type": "text"}, {"text": "kind", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of error thrown is very important to notice. A ", "type": "text"}, {"text": "TypeError", "type": "text", "marks": [{"type": "code"}]}, {"text": " means we're trying to do something with a value that is not allowed. Depending on your JS environment, the error message would say something like, \"'undefined' is not a function,\" or more helpfully, \"'greeting' is not a function.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice that the error is ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": ". JS isn't telling us that it couldn't find ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " as an identifier in the scope. It's telling us that ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " was found but doesn't hold a function reference at that moment. Only functions can be invoked, so attempting to invoke some non-function value results in an error.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But what does ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " hold, if not the function reference?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In addition to being hoisted, variables declared with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " are also automatically initialized to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " at the beginning of their scope\u2014again, the nearest enclosing function, or the global. Once initialized, they're available to be used (assigned to, retrieved from, etc.) throughout the whole scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So on that first line, ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " exists, but it holds only the default ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " value. It's not until line 4 that ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " gets assigned the function reference.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Pay close attention to the distinction here. A ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration is hoisted ", "type": "text"}, {"text": "and initialized to its function value", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (again, called ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": "). A ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable is also hoisted, and then auto-initialized to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Any subsequent ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression assignments to that variable don't happen until that assignment is processed during runtime execution.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In both cases, the name of the identifier is hoisted. But the function reference association isn't handled at initialization time (beginning of the scope) unless the identifier was created in a formal ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration.", "type": "text"}]}]}, "article_text": "Hoisting: Declaration vs. Expression\n\nFunction hoisting only applies to formal function declarations (specifically those which appear outside of blocks\u2014see \"FiB\" in Chapter 6), not to function expression assignments. Consider:\n\ngreeting();\n// TypeError\n\nvar greeting = function greeting() {\n    console.log(\"Hello!\");\n};\n\nLine 1 (greeting();) throws an error. But the kind of error thrown is very important to notice. A TypeError means we're trying to do something with a value that is not allowed. Depending on your JS environment, the error message would say something like, \"'undefined' is not a function,\" or more helpfully, \"'greeting' is not a function.\"\n\nNotice that the error is not a ReferenceError. JS isn't telling us that it couldn't find greeting as an identifier in the scope. It's telling us that greeting was found but doesn't hold a function reference at that moment. Only functions can be invoked, so attempting to invoke some non-function value results in an error.\n\nBut what does greeting hold, if not the function reference?\n\nIn addition to being hoisted, variables declared with var are also automatically initialized to undefined at the beginning of their scope\u2014again, the nearest enclosing function, or the global. Once initialized, they're available to be used (assigned to, retrieved from, etc.) throughout the whole scope.\n\nSo on that first line, greeting exists, but it holds only the default undefined value. It's not until line 4 that greeting gets assigned the function reference.\n\nPay close attention to the distinction here. A function declaration is hoisted and initialized to its function value (again, called function hoisting). A var variable is also hoisted, and then auto-initialized to undefined. Any subsequent function expression assignments to that variable don't happen until that assignment is processed during runtime execution.\n\nIn both cases, the name of the identifier is hoisted. But the function reference association isn't handled at initialization time (beginning of the scope) unless the identifier was created in a formal function declaration."}, "id": 203}, {"data": {"uuid": "0e639d90-b099-46d2-bf54-1d648e6dc46c", "user": 1, "title": "Variable Hoisting", "author": "Kyle Simpson", "created_on": "2023-06-09 01:19:27.534552+00:00", "updated_on": "2023-06-09 01:19:46.372963+00:00", "article_html": "<h3>Variable Hoisting</h3><p>Let's look at another example of <em>variable hoisting</em>:</p><pre><code>greeting = \"Hello!\";\nconsole.log(greeting);\n// Hello!\n\nvar greeting = \"Howdy!\";</code></pre><p>Though <code>greeting</code> isn't declared until line 5, it's available to be assigned to as early as line 1. Why?</p><p>There's two necessary parts to the explanation:</p><ul><li><p>the identifier is hoisted,</p></li><li><p><strong>and</strong> it's automatically initialized to the value <code>undefined</code> from the top of the scope.</p></li></ul><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Using <em>variable hoisting</em> of this sort probably feels unnatural, and many readers might rightly want to avoid relying on it in their programs. But should all hoisting (including <em>function hoisting</em>) be avoided? We'll explore these different perspectives on hoisting in more detail in Appendix A.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Variable Hoisting", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's look at another example of ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "greeting = \"Hello!\";\nconsole.log(greeting);\n// Hello!\n\nvar greeting = \"Howdy!\";", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " isn't declared until line 5, it's available to be assigned to as early as line 1. Why?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's two necessary parts to the explanation:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "the identifier is hoisted,", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "and", "type": "text", "marks": [{"type": "bold"}]}, {"text": " it's automatically initialized to the value ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " from the top of the scope.", "type": "text"}]}]}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Using ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of this sort probably feels unnatural, and many readers might rightly want to avoid relying on it in their programs. But should all hoisting (including ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ") be avoided? We'll explore these different perspectives on hoisting in more detail in Appendix A.", "type": "text"}]}]}]}]}]}, "article_text": "Variable Hoisting\n\nLet's look at another example of variable hoisting:\n\ngreeting = \"Hello!\";\nconsole.log(greeting);\n// Hello!\n\nvar greeting = \"Howdy!\";\n\nThough greeting isn't declared until line 5, it's available to be assigned to as early as line 1. Why?\n\nThere's two necessary parts to the explanation:\n\nthe identifier is hoisted,\n\nand it's automatically initialized to the value undefined from the top of the scope.\n\nNOTE:\n\nUsing variable hoisting of this sort probably feels unnatural, and many readers might rightly want to avoid relying on it in their programs. But should all hoisting (including function hoisting) be avoided? We'll explore these different perspectives on hoisting in more detail in Appendix A."}, "id": 204}]}, {"data": {"uuid": "9bef623c-acbc-4e62-9c3a-1c86ff498289", "user": 1, "title": "Hoisting: Yet Another Metaphor", "author": "Kyle Simpson", "created_on": "2023-06-09 01:20:03.402584+00:00", "updated_on": "2023-06-09 01:20:23.296269+00:00", "article_html": "<h2>Hoisting: Yet Another Metaphor</h2><p>Chapter 2 was full of metaphors (to illustrate scope), but here we are faced with yet another: hoisting itself. Rather than hoisting being a concrete execution step the JS engine performs, it's more useful to think of hoisting as a visualization of various actions JS takes in setting up the program <strong>before execution</strong>.</p><p>The typical assertion of what hoisting means: <em>lifting</em>\u2014like lifting a heavy weight upward\u2014any identifiers all the way to the top of a scope. The explanation often asserted is that the JS engine will actually <em>rewrite</em> that program before execution, so that it looks more like this:</p><pre><code>var greeting;           // hoisted declaration\ngreeting = \"Hello!\";    // the original line 1\nconsole.log(greeting);  // Hello!\ngreeting = \"Howdy!\";    // `var` is gone!</code></pre><p>The hoisting (metaphor) proposes that JS pre-processes the original program and re-arranges it a bit, so that all the declarations have been moved to the top of their respective scopes, before execution. Moreover, the hoisting metaphor asserts that <code>function</code> declarations are, in their entirety, hoisted to the top of each scope. Consider:</p><pre><code>studentName = \"Suzy\";\ngreeting();\n// Hello Suzy!\n\nfunction greeting() {\n    console.log(`Hello ${ studentName }!`);\n}\nvar studentName;</code></pre><p>The \"rule\" of the hoisting metaphor is that function declarations are hoisted first, then variables are hoisted immediately after all the functions. Thus, the hoisting story suggests that program is <em>re-arranged</em> by the JS engine to look like this:</p><pre><code>function greeting() {\n    console.log(`Hello ${ studentName }!`);\n}\nvar studentName;\n\nstudentName = \"Suzy\";\ngreeting();\n// Hello Suzy!</code></pre><p>This hoisting metaphor is convenient. Its benefit is allowing us to hand wave over the magical look-ahead pre-processing necessary to find all these declarations buried deep in scopes and somehow move (hoist) them to the top; we can just think about the program as if it's executed by the JS engine in a <strong>single pass</strong>, top-down.</p><p>Single-pass definitely seems more straightforward than Chapter 1's assertion of a two-phase processing.</p><p>Hoisting as a mechanism for re-ordering code may be an attractive simplification, but it's not accurate. The JS engine doesn't actually re-arrange the code. It can't magically look ahead and find declarations; the only way to accurately find them, as well as all the scope boundaries in the program, would be to fully parse the code.</p><p>Guess what parsing is? The first phase of the two-phase processing! There's no magical mental gymnastics that gets around that fact.</p><p>So if the hoisting metaphor is (at best) inaccurate, what should we do with the term? I think it's still useful\u2014indeed, even members of TC39 regularly use it!\u2014but I don't think we should claim it's an actual re-arrangement of source code.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Incorrect or incomplete mental models often still seem sufficient because they can occasionally lead to accidental right answers. But in the long run it's harder to accurately analyze and predict outcomes if your thinking isn't particularly aligned with how the JS engine works.</p></td></tr></tbody></table><p>I assert that hoisting <em>should</em> be used to refer to the <strong>compile-time operation</strong> of generating runtime instructions for the automatic registration of a variable at the beginning of its scope, each time that scope is entered.</p><p>That's a subtle but important shift, from hoisting as a runtime behavior to its proper place among compile-time tasks.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Hoisting: Yet Another Metaphor", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Chapter 2 was full of metaphors (to illustrate scope), but here we are faced with yet another: hoisting itself. Rather than hoisting being a concrete execution step the JS engine performs, it's more useful to think of hoisting as a visualization of various actions JS takes in setting up the program ", "type": "text"}, {"text": "before execution", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The typical assertion of what hoisting means: ", "type": "text"}, {"text": "lifting", "type": "text", "marks": [{"type": "italic"}]}, {"text": "\u2014like lifting a heavy weight upward\u2014any identifiers all the way to the top of a scope. The explanation often asserted is that the JS engine will actually ", "type": "text"}, {"text": "rewrite", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that program before execution, so that it looks more like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var greeting;           // hoisted declaration\ngreeting = \"Hello!\";    // the original line 1\nconsole.log(greeting);  // Hello!\ngreeting = \"Howdy!\";    // `var` is gone!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The hoisting (metaphor) proposes that JS pre-processes the original program and re-arranges it a bit, so that all the declarations have been moved to the top of their respective scopes, before execution. Moreover, the hoisting metaphor asserts that ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations are, in their entirety, hoisted to the top of each scope. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "studentName = \"Suzy\";\ngreeting();\n// Hello Suzy!\n\nfunction greeting() {\n    console.log(`Hello ${ studentName }!`);\n}\nvar studentName;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The \"rule\" of the hoisting metaphor is that function declarations are hoisted first, then variables are hoisted immediately after all the functions. Thus, the hoisting story suggests that program is ", "type": "text"}, {"text": "re-arranged", "type": "text", "marks": [{"type": "italic"}]}, {"text": " by the JS engine to look like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function greeting() {\n    console.log(`Hello ${ studentName }!`);\n}\nvar studentName;\n\nstudentName = \"Suzy\";\ngreeting();\n// Hello Suzy!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This hoisting metaphor is convenient. Its benefit is allowing us to hand wave over the magical look-ahead pre-processing necessary to find all these declarations buried deep in scopes and somehow move (hoist) them to the top; we can just think about the program as if it's executed by the JS engine in a ", "type": "text"}, {"text": "single pass", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", top-down.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Single-pass definitely seems more straightforward than Chapter 1's assertion of a two-phase processing.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Hoisting as a mechanism for re-ordering code may be an attractive simplification, but it's not accurate. The JS engine doesn't actually re-arrange the code. It can't magically look ahead and find declarations; the only way to accurately find them, as well as all the scope boundaries in the program, would be to fully parse the code.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Guess what parsing is? The first phase of the two-phase processing! There's no magical mental gymnastics that gets around that fact.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So if the hoisting metaphor is (at best) inaccurate, what should we do with the term? I think it's still useful\u2014indeed, even members of TC39 regularly use it!\u2014but I don't think we should claim it's an actual re-arrangement of source code.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Incorrect or incomplete mental models often still seem sufficient because they can occasionally lead to accidental right answers. But in the long run it's harder to accurately analyze and predict outcomes if your thinking isn't particularly aligned with how the JS engine works.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "I assert that hoisting ", "type": "text"}, {"text": "should", "type": "text", "marks": [{"type": "italic"}]}, {"text": " be used to refer to the ", "type": "text"}, {"text": "compile-time operation", "type": "text", "marks": [{"type": "bold"}]}, {"text": " of generating runtime instructions for the automatic registration of a variable at the beginning of its scope, each time that scope is entered.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's a subtle but important shift, from hoisting as a runtime behavior to its proper place among compile-time tasks.", "type": "text"}]}]}, "article_text": "Hoisting: Yet Another Metaphor\n\nChapter 2 was full of metaphors (to illustrate scope), but here we are faced with yet another: hoisting itself. Rather than hoisting being a concrete execution step the JS engine performs, it's more useful to think of hoisting as a visualization of various actions JS takes in setting up the program before execution.\n\nThe typical assertion of what hoisting means: lifting\u2014like lifting a heavy weight upward\u2014any identifiers all the way to the top of a scope. The explanation often asserted is that the JS engine will actually rewrite that program before execution, so that it looks more like this:\n\nvar greeting;           // hoisted declaration\ngreeting = \"Hello!\";    // the original line 1\nconsole.log(greeting);  // Hello!\ngreeting = \"Howdy!\";    // `var` is gone!\n\nThe hoisting (metaphor) proposes that JS pre-processes the original program and re-arranges it a bit, so that all the declarations have been moved to the top of their respective scopes, before execution. Moreover, the hoisting metaphor asserts that function declarations are, in their entirety, hoisted to the top of each scope. Consider:\n\nstudentName = \"Suzy\";\ngreeting();\n// Hello Suzy!\n\nfunction greeting() {\n    console.log(`Hello ${ studentName }!`);\n}\nvar studentName;\n\nThe \"rule\" of the hoisting metaphor is that function declarations are hoisted first, then variables are hoisted immediately after all the functions. Thus, the hoisting story suggests that program is re-arranged by the JS engine to look like this:\n\nfunction greeting() {\n    console.log(`Hello ${ studentName }!`);\n}\nvar studentName;\n\nstudentName = \"Suzy\";\ngreeting();\n// Hello Suzy!\n\nThis hoisting metaphor is convenient. Its benefit is allowing us to hand wave over the magical look-ahead pre-processing necessary to find all these declarations buried deep in scopes and somehow move (hoist) them to the top; we can just think about the program as if it's executed by the JS engine in a single pass, top-down.\n\nSingle-pass definitely seems more straightforward than Chapter 1's assertion of a two-phase processing.\n\nHoisting as a mechanism for re-ordering code may be an attractive simplification, but it's not accurate. The JS engine doesn't actually re-arrange the code. It can't magically look ahead and find declarations; the only way to accurately find them, as well as all the scope boundaries in the program, would be to fully parse the code.\n\nGuess what parsing is? The first phase of the two-phase processing! There's no magical mental gymnastics that gets around that fact.\n\nSo if the hoisting metaphor is (at best) inaccurate, what should we do with the term? I think it's still useful\u2014indeed, even members of TC39 regularly use it!\u2014but I don't think we should claim it's an actual re-arrangement of source code.\n\nWARNING:\n\nIncorrect or incomplete mental models often still seem sufficient because they can occasionally lead to accidental right answers. But in the long run it's harder to accurately analyze and predict outcomes if your thinking isn't particularly aligned with how the JS engine works.\n\nI assert that hoisting should be used to refer to the compile-time operation of generating runtime instructions for the automatic registration of a variable at the beginning of its scope, each time that scope is entered.\n\nThat's a subtle but important shift, from hoisting as a runtime behavior to its proper place among compile-time tasks."}, "id": 205}, {"data": {"uuid": "60b8144e-b3b2-46f1-9b51-8eda439be44d", "user": 1, "title": "Re-declaration?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:20:49.905873+00:00", "updated_on": "2023-06-09 01:21:17.647334+00:00", "article_html": "<h2>Re-declaration?</h2><p>What do you think happens when a variable is declared more than once in the same scope? Consider:</p><pre><code>var studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nvar studentName;\nconsole.log(studentName);   // ???</code></pre><p>What do you expect to be printed for that second message? Many believe the second <code>var studentName</code> has re-declared the variable (and thus \"reset\" it), so they expect <code>undefined</code> to be printed.</p><p>But is there such a thing as a variable being \"re-declared\" in the same scope? No.</p><p>If you consider this program from the perspective of the hoisting metaphor, the code would be re-arranged like this for execution purposes:</p><pre><code>var studentName;\nvar studentName;    // clearly a pointless no-op!\n\nstudentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nconsole.log(studentName);\n// Frank</code></pre><p>Since hoisting is actually about registering a variable at the beginning of a scope, there's nothing to be done in the middle of the scope where the original program actually had the second <code>var studentName</code> statement. It's just a no-op(eration), a pointless statement.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>In the style of the conversation narrative from Chapter 2, <em>Compiler</em> would find the second <code>var</code> declaration statement and ask the <em>Scope Manager</em> if it had already seen a <code>studentName</code> identifier; since it had, there wouldn't be anything else to do.</p></td></tr></tbody></table><p>It's also important to point out that <code>var studentName;</code> doesn't mean <code>var studentName = undefined;</code>, as most assume. Let's prove they're different by considering this variation of the program:</p><pre><code>var studentName = \"Frank\";\nconsole.log(studentName);   // Frank\n\nvar studentName;\nconsole.log(studentName);   // Frank &lt;--- still!\n\n// let's add the initialization explicitly\nvar studentName = undefined;\nconsole.log(studentName);   // undefined &lt;--- see!?</code></pre><p>See how the explicit <code>= undefined</code> initialization produces a different outcome than assuming it happens implicitly when omitted? In the next section, we'll revisit this topic of initialization of variables from their declarations.</p><p>A repeated <code>var</code> declaration of the same identifier name in a scope is effectively a do-nothing operation. Here's another illustration, this time across a function of the same name:</p><pre><code>var greeting;\n\nfunction greeting() {\n    console.log(\"Hello!\");\n}\n\n// basically, a no-op\nvar greeting;\n\ntypeof greeting;        // \"function\"\n\nvar greeting = \"Hello!\";\n\ntypeof greeting;        // \"string\"</code></pre><p>The first <code>greeting</code> declaration registers the identifier to the scope, and because it's a <code>var</code> the auto-initialization will be <code>undefined</code>. The <code>function</code> declaration doesn't need to re-register the identifier, but because of <em>function hoisting</em> it overrides the auto-initialization to use the function reference. The second <code>var greeting</code> by itself doesn't do anything since <code>greeting</code> is already an identifier and <em>function hoisting</em> already took precedence for the auto-initialization.</p><p>Actually assigning <code>\"Hello!\"</code> to <code>greeting</code> changes its value from the initial function <code>greeting()</code> to the string; <code>var</code> itself doesn't have any effect.</p><p>What about repeating a declaration within a scope using <code>let</code> or <code>const</code>?</p><pre><code>let studentName = \"Frank\";\n\nconsole.log(studentName);\n\nlet studentName = \"Suzy\";</code></pre><p>This program will not execute, but instead immediately throw a <code>SyntaxError</code>. Depending on your JS environment, the error message will indicate something like: \"studentName has already been declared.\" In other words, this is a case where attempted \"re-declaration\" is explicitly not allowed!</p><p>It's not just that two declarations involving <code>let</code> will throw this error. If either declaration uses <code>let</code>, the other can be either <code>let</code> or <code>var</code>, and the error will still occur, as illustrated with these two variations:</p><pre><code>var studentName = \"Frank\";\n\nlet studentName = \"Suzy\";</code></pre><p>and:</p><pre><code>let studentName = \"Frank\";\n\nvar studentName = \"Suzy\";</code></pre><p>In both cases, a <code>SyntaxError</code> is thrown on the <em>second</em> declaration. In other words, the only way to \"re-declare\" a variable is to use <code>var</code> for all (two or more) of its declarations.</p><p>But why disallow it? The reason for the error is not technical per se, as <code>var</code> \"re-declaration\" has always been allowed; clearly, the same allowance could have been made for <code>let</code>.</p><p>It's really more of a \"social engineering\" issue. \"Re-declaration\" of variables is seen by some, including many on the TC39 body, as a bad habit that can lead to program bugs. So when ES6 introduced <code>let</code>, they decided to prevent \"re-declaration\" with an error.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>This is of course a stylistic opinion, not really a technical argument. Many developers agree with the position, and that's probably in part why TC39 included the error (as well as <code>let</code> conforming to <code>const</code>). But a reasonable case could have been made that staying consistent with <code>var</code>'s precedent was more prudent, and that such opinion-enforcement was best left to opt-in tooling like linters. In Appendix A, we'll explore whether <code>var</code> (and its associated behavior, like \"re-declaration\") can still be useful in modern JS.</p></td></tr></tbody></table><p>When <em>Compiler</em> asks <em>Scope Manager</em> about a declaration, if that identifier has already been declared, and if either/both declarations were made with <code>let</code>, an error is thrown. The intended signal to the developer is \"Stop relying on sloppy re-declaration!\"</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Re-declaration?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What do you think happens when a variable is declared more than once in the same scope? Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nvar studentName;\nconsole.log(studentName);   // ???", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What do you expect to be printed for that second message? Many believe the second ", "type": "text"}, {"text": "var studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " has re-declared the variable (and thus \"reset\" it), so they expect ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " to be printed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But is there such a thing as a variable being \"re-declared\" in the same scope? No.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you consider this program from the perspective of the hoisting metaphor, the code would be re-arranged like this for execution purposes:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName;\nvar studentName;    // clearly a pointless no-op!\n\nstudentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nconsole.log(studentName);\n// Frank", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since hoisting is actually about registering a variable at the beginning of a scope, there's nothing to be done in the middle of the scope where the original program actually had the second ", "type": "text"}, {"text": "var studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement. It's just a no-op(eration), a pointless statement.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "In the style of the conversation narrative from Chapter 2, ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " would find the second ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration statement and ask the ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if it had already seen a ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier; since it had, there wouldn't be anything else to do.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "It's also important to point out that ", "type": "text"}, {"text": "var studentName;", "type": "text", "marks": [{"type": "code"}]}, {"text": " doesn't mean ", "type": "text"}, {"text": "var studentName = undefined;", "type": "text", "marks": [{"type": "code"}]}, {"text": ", as most assume. Let's prove they're different by considering this variation of the program:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Frank\";\nconsole.log(studentName);   // Frank\n\nvar studentName;\nconsole.log(studentName);   // Frank <--- still!\n\n// let's add the initialization explicitly\nvar studentName = undefined;\nconsole.log(studentName);   // undefined <--- see!?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "See how the explicit ", "type": "text"}, {"text": "= undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " initialization produces a different outcome than assuming it happens implicitly when omitted? In the next section, we'll revisit this topic of initialization of variables from their declarations.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A repeated ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration of the same identifier name in a scope is effectively a do-nothing operation. Here's another illustration, this time across a function of the same name:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var greeting;\n\nfunction greeting() {\n    console.log(\"Hello!\");\n}\n\n// basically, a no-op\nvar greeting;\n\ntypeof greeting;        // \"function\"\n\nvar greeting = \"Hello!\";\n\ntypeof greeting;        // \"string\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration registers the identifier to the scope, and because it's a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " the auto-initialization will be ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration doesn't need to re-register the identifier, but because of ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " it overrides the auto-initialization to use the function reference. The second ", "type": "text"}, {"text": "var greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " by itself doesn't do anything since ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " is already an identifier and ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " already took precedence for the auto-initialization.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Actually assigning ", "type": "text"}, {"text": "\"Hello!\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " changes its value from the initial function ", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": " to the string; ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " itself doesn't have any effect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about repeating a declaration within a scope using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "let studentName = \"Frank\";\n\nconsole.log(studentName);\n\nlet studentName = \"Suzy\";", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This program will not execute, but instead immediately throw a ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Depending on your JS environment, the error message will indicate something like: \"studentName has already been declared.\" In other words, this is a case where attempted \"re-declaration\" is explicitly not allowed!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's not just that two declarations involving ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " will throw this error. If either declaration uses ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the other can be either ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and the error will still occur, as illustrated with these two variations:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Frank\";\n\nlet studentName = \"Suzy\";", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "and:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "let studentName = \"Frank\";\n\nvar studentName = \"Suzy\";", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In both cases, a ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": " is thrown on the ", "type": "text"}, {"text": "second", "type": "text", "marks": [{"type": "italic"}]}, {"text": " declaration. In other words, the only way to \"re-declare\" a variable is to use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " for all (two or more) of its declarations.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But why disallow it? The reason for the error is not technical per se, as ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " \"re-declaration\" has always been allowed; clearly, the same allowance could have been made for ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's really more of a \"social engineering\" issue. \"Re-declaration\" of variables is seen by some, including many on the TC39 body, as a bad habit that can lead to program bugs. So when ES6 introduced ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", they decided to prevent \"re-declaration\" with an error.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "This is of course a stylistic opinion, not really a technical argument. Many developers agree with the position, and that's probably in part why TC39 included the error (as well as ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " conforming to ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "). But a reasonable case could have been made that staying consistent with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "'s precedent was more prudent, and that such opinion-enforcement was best left to opt-in tooling like linters. In Appendix A, we'll explore whether ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and its associated behavior, like \"re-declaration\") can still be useful in modern JS.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "When ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " asks ", "type": "text"}, {"text": "Scope Manager", "type": "text", "marks": [{"type": "italic"}]}, {"text": " about a declaration, if that identifier has already been declared, and if either/both declarations were made with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", an error is thrown. The intended signal to the developer is \"Stop relying on sloppy re-declaration!\"", "type": "text"}]}]}, "article_text": "Re-declaration?\n\nWhat do you think happens when a variable is declared more than once in the same scope? Consider:\n\nvar studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nvar studentName;\nconsole.log(studentName);   // ???\n\nWhat do you expect to be printed for that second message? Many believe the second var studentName has re-declared the variable (and thus \"reset\" it), so they expect undefined to be printed.\n\nBut is there such a thing as a variable being \"re-declared\" in the same scope? No.\n\nIf you consider this program from the perspective of the hoisting metaphor, the code would be re-arranged like this for execution purposes:\n\nvar studentName;\nvar studentName;    // clearly a pointless no-op!\n\nstudentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nconsole.log(studentName);\n// Frank\n\nSince hoisting is actually about registering a variable at the beginning of a scope, there's nothing to be done in the middle of the scope where the original program actually had the second var studentName statement. It's just a no-op(eration), a pointless statement.\n\nTIP:\n\nIn the style of the conversation narrative from Chapter 2, Compiler would find the second var declaration statement and ask the Scope Manager if it had already seen a studentName identifier; since it had, there wouldn't be anything else to do.\n\nIt's also important to point out that var studentName; doesn't mean var studentName = undefined;, as most assume. Let's prove they're different by considering this variation of the program:\n\nvar studentName = \"Frank\";\nconsole.log(studentName);   // Frank\n\nvar studentName;\nconsole.log(studentName);   // Frank <--- still!\n\n// let's add the initialization explicitly\nvar studentName = undefined;\nconsole.log(studentName);   // undefined <--- see!?\n\nSee how the explicit = undefined initialization produces a different outcome than assuming it happens implicitly when omitted? In the next section, we'll revisit this topic of initialization of variables from their declarations.\n\nA repeated var declaration of the same identifier name in a scope is effectively a do-nothing operation. Here's another illustration, this time across a function of the same name:\n\nvar greeting;\n\nfunction greeting() {\n    console.log(\"Hello!\");\n}\n\n// basically, a no-op\nvar greeting;\n\ntypeof greeting;        // \"function\"\n\nvar greeting = \"Hello!\";\n\ntypeof greeting;        // \"string\"\n\nThe first greeting declaration registers the identifier to the scope, and because it's a var the auto-initialization will be undefined. The function declaration doesn't need to re-register the identifier, but because of function hoisting it overrides the auto-initialization to use the function reference. The second var greeting by itself doesn't do anything since greeting is already an identifier and function hoisting already took precedence for the auto-initialization.\n\nActually assigning \"Hello!\" to greeting changes its value from the initial function greeting() to the string; var itself doesn't have any effect.\n\nWhat about repeating a declaration within a scope using let or const?\n\nlet studentName = \"Frank\";\n\nconsole.log(studentName);\n\nlet studentName = \"Suzy\";\n\nThis program will not execute, but instead immediately throw a SyntaxError. Depending on your JS environment, the error message will indicate something like: \"studentName has already been declared.\" In other words, this is a case where attempted \"re-declaration\" is explicitly not allowed!\n\nIt's not just that two declarations involving let will throw this error. If either declaration uses let, the other can be either let or var, and the error will still occur, as illustrated with these two variations:\n\nvar studentName = \"Frank\";\n\nlet studentName = \"Suzy\";\n\nand:\n\nlet studentName = \"Frank\";\n\nvar studentName = \"Suzy\";\n\nIn both cases, a SyntaxError is thrown on the second declaration. In other words, the only way to \"re-declare\" a variable is to use var for all (two or more) of its declarations.\n\nBut why disallow it? The reason for the error is not technical per se, as var \"re-declaration\" has always been allowed; clearly, the same allowance could have been made for let.\n\nIt's really more of a \"social engineering\" issue. \"Re-declaration\" of variables is seen by some, including many on the TC39 body, as a bad habit that can lead to program bugs. So when ES6 introduced let, they decided to prevent \"re-declaration\" with an error.\n\nNOTE:\n\nThis is of course a stylistic opinion, not really a technical argument. Many developers agree with the position, and that's probably in part why TC39 included the error (as well as let conforming to const). But a reasonable case could have been made that staying consistent with var's precedent was more prudent, and that such opinion-enforcement was best left to opt-in tooling like linters. In Appendix A, we'll explore whether var (and its associated behavior, like \"re-declaration\") can still be useful in modern JS.\n\nWhen Compiler asks Scope Manager about a declaration, if that identifier has already been declared, and if either/both declarations were made with let, an error is thrown. The intended signal to the developer is \"Stop relying on sloppy re-declaration!\""}, "id": 206, "children": [{"data": {"uuid": "691cc944-6275-45b8-99fb-977ab7d6feb3", "user": 1, "title": "Constants?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:21:47.302237+00:00", "updated_on": "2023-06-09 01:22:20.051682+00:00", "article_html": "<h3>Constants?</h3><p>The <code>const</code> keyword is more constrained than <code>let</code>. Like <code>let</code>, <code>const</code> cannot be repeated with the same identifier in the same scope. But there's actually an overriding technical reason why that sort of \"re-declaration\" is disallowed, unlike <code>let</code> which disallows \"re-declaration\" mostly for stylistic reasons.</p><p>The <code>const</code> keyword requires a variable to be initialized, so omitting an assignment from the declaration results in a <code>SyntaxError</code>:</p><pre><code>const empty;   // SyntaxError</code></pre><p><code>const</code> declarations create variables that cannot be re-assigned:</p><pre><code>const studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nstudentName = \"Suzy\";   // TypeError</code></pre><p>The <code>studentName</code> variable cannot be re-assigned because it's declared with a <code>const</code>.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The error thrown when re-assigning <code>studentName</code> is a <code>TypeError</code>, not a <code>SyntaxError</code>. The subtle distinction here is actually pretty important, but unfortunately far too easy to miss. Syntax errors represent faults in the program that stop it from even starting execution. Type errors represent faults that arise during program execution. In the preceding snippet, <code>\"Frank\"</code> is printed out before we process the re-assignment of <code>studentName</code>, which then throws the error.</p></td></tr></tbody></table><p>So if <code>const</code> declarations cannot be re-assigned, and <code>const</code> declarations always require assignments, then we have a clear technical reason why <code>const</code> must disallow any \"re-declarations\": any <code>const</code> \"re-declaration\" would also necessarily be a <code>const</code> re-assignment, which can't be allowed!</p><pre><code>const studentName = \"Frank\";\n\n// obviously this must be an error\nconst studentName = \"Suzy\";</code></pre><p>Since <code>const</code> \"re-declaration\" must be disallowed (on those technical grounds), TC39 essentially felt that <code>let</code> \"re-declaration\" should be disallowed as well, for consistency. It's debatable if this was the best choice, but at least we have the reasoning behind the decision.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Constants?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword is more constrained than ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Like ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " cannot be repeated with the same identifier in the same scope. But there's actually an overriding technical reason why that sort of \"re-declaration\" is disallowed, unlike ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " which disallows \"re-declaration\" mostly for stylistic reasons.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword requires a variable to be initialized, so omitting an assignment from the declaration results in a ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const empty;   // SyntaxError", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations create variables that cannot be re-assigned:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nstudentName = \"Suzy\";   // TypeError", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable cannot be re-assigned because it's declared with a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The error thrown when re-assigning ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "TypeError", "type": "text", "marks": [{"type": "code"}]}, {"text": ", not a ", "type": "text"}, {"text": "SyntaxError", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The subtle distinction here is actually pretty important, but unfortunately far too easy to miss. Syntax errors represent faults in the program that stop it from even starting execution. Type errors represent faults that arise during program execution. In the preceding snippet, ", "type": "text"}, {"text": "\"Frank\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " is printed out before we process the re-assignment of ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which then throws the error.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "So if ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations cannot be re-assigned, and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations always require assignments, then we have a clear technical reason why ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " must disallow any \"re-declarations\": any ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " \"re-declaration\" would also necessarily be a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " re-assignment, which can't be allowed!", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const studentName = \"Frank\";\n\n// obviously this must be an error\nconst studentName = \"Suzy\";", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " \"re-declaration\" must be disallowed (on those technical grounds), TC39 essentially felt that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " \"re-declaration\" should be disallowed as well, for consistency. It's debatable if this was the best choice, but at least we have the reasoning behind the decision.", "type": "text"}]}]}, "article_text": "Constants?\n\nThe const keyword is more constrained than let. Like let, const cannot be repeated with the same identifier in the same scope. But there's actually an overriding technical reason why that sort of \"re-declaration\" is disallowed, unlike let which disallows \"re-declaration\" mostly for stylistic reasons.\n\nThe const keyword requires a variable to be initialized, so omitting an assignment from the declaration results in a SyntaxError:\n\nconst empty;   // SyntaxError\n\nconst declarations create variables that cannot be re-assigned:\n\nconst studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\n\nstudentName = \"Suzy\";   // TypeError\n\nThe studentName variable cannot be re-assigned because it's declared with a const.\n\nWARNING:\n\nThe error thrown when re-assigning studentName is a TypeError, not a SyntaxError. The subtle distinction here is actually pretty important, but unfortunately far too easy to miss. Syntax errors represent faults in the program that stop it from even starting execution. Type errors represent faults that arise during program execution. In the preceding snippet, \"Frank\" is printed out before we process the re-assignment of studentName, which then throws the error.\n\nSo if const declarations cannot be re-assigned, and const declarations always require assignments, then we have a clear technical reason why const must disallow any \"re-declarations\": any const \"re-declaration\" would also necessarily be a const re-assignment, which can't be allowed!\n\nconst studentName = \"Frank\";\n\n// obviously this must be an error\nconst studentName = \"Suzy\";\n\nSince const \"re-declaration\" must be disallowed (on those technical grounds), TC39 essentially felt that let \"re-declaration\" should be disallowed as well, for consistency. It's debatable if this was the best choice, but at least we have the reasoning behind the decision."}, "id": 207}, {"data": {"uuid": "21f7bcf6-9f6f-495e-b099-6b3424dd7bf9", "user": 1, "title": "Loops", "author": "Kyle Simpson", "created_on": "2023-06-09 01:22:37.872442+00:00", "updated_on": "2023-06-09 01:23:09.431215+00:00", "article_html": "<h3>Loops</h3><p>So it's clear from our previous discussion that JS doesn't really want us to \"re-declare\" our variables within the same scope. That probably seems like a straightforward admonition, until you consider what it means for repeated execution of declaration statements in loops. Consider:</p><pre><code>var keepGoing = true;\nwhile (keepGoing) {\n    let value = Math.random();\n    if (value &gt; 0.5) {\n        keepGoing = false;\n    }\n}</code></pre><p>Is <code>value</code> being \"re-declared\" repeatedly in this program? Will we get errors thrown? No.</p><p>All the rules of scope (including \"re-declaration\" of <code>let</code>-created variables) are applied <em>per scope instance</em>. In other words, each time a scope is entered during execution, everything resets.</p><p>Each loop iteration is its own new scope instance, and within each scope instance, <code>value</code> is only being declared once. So there's no attempted \"re-declaration,\" and thus no error. Before we consider other loop forms, what if the <code>value</code> declaration in the previous snippet were changed to a <code>var</code>?</p><pre><code>var keepGoing = true;\nwhile (keepGoing) {\n    var value = Math.random();\n    if (value &gt; 0.5) {\n        keepGoing = false;\n    }\n}</code></pre><p>Is <code>value</code> being \"re-declared\" here, especially since we know <code>var</code> allows it? No. Because <code>var</code> is not treated as a block-scoping declaration (see Chapter 6), it attaches itself to the global scope. So there's just one <code>value</code> variable, in the same scope as <code>keepGoing</code> (global scope, in this case). No \"re-declaration\" here, either!</p><p>One way to keep this all straight is to remember that <code>var</code>, <code>let</code>, and <code>const</code> keywords are effectively <em>removed</em> from the code by the time it starts to execute. They're handled entirely by the compiler.</p><p>If you mentally erase the declarator keywords and then try to process the code, it should help you decide if and when (re-)declarations might occur.</p><p>What about \"re-declaration\" with other loop forms, like <code>for</code>-loops?</p><pre><code>for (let i = 0; i &lt; 3; i++) {\n    let value = i * 10;\n    console.log(`${ i }: ${ value }`);\n}\n// 0: 0\n// 1: 10\n// 2: 20</code></pre><p>It should be clear that there's only one <code>value</code> declared per scope instance. But what about <code>i</code>? Is it being \"re-declared\"?</p><p>To answer that, consider what scope <code>i</code> is in. It might seem like it would be in the outer (in this case, global) scope, but it's not. It's in the scope of <code>for</code>-loop body, just like <code>value</code> is. In fact, you could sorta think about that loop in this more verbose equivalent form:</p><pre><code>{\n    // a fictional variable for illustration\n    let $$i = 0;\n\n    for ( /* nothing */; $$i &lt; 3; $$i++) {\n        // here's our actual loop `i`!\n        let i = $$i;\n\n        let value = i * 10;\n        console.log(`${ i }: ${ value }`);\n    }\n    // 0: 0\n    // 1: 10\n    // 2: 20\n}</code></pre><p>Now it should be clear: the <code>i</code> and <code>value</code> variables are both declared exactly once <strong>per scope instance</strong>. No \"re-declaration\" here.</p><p>What about other <code>for</code>-loop forms?</p><pre><code>for (let index in students) {\n    // this is fine\n}\n\nfor (let student of students) {\n    // so is this\n}</code></pre><p>Same thing with <code>for..in</code> and <code>for..of</code> loops: the declared variable is treated as <em>inside</em> the loop body, and thus is handled per iteration (aka, per scope instance). No \"re-declaration.\"</p><p>OK, I know you're thinking that I sound like a broken record at this point. But let's explore how <code>const</code> impacts these looping constructs. Consider:</p><pre><code>var keepGoing = true;\nwhile (keepGoing) {\n    // ooo, a shiny constant!\n    const value = Math.random();\n    if (value &gt; 0.5) {\n        keepGoing = false;\n    }\n}</code></pre><p>Just like the <code>let</code> variant of this program we saw earlier, <code>const</code> is being run exactly once within each loop iteration, so it's safe from \"re-declaration\" troubles. But things get more complicated when we talk about <code>for</code>-loops.</p><p><code>for..in</code> and <code>for..of</code> are fine to use with <code>const</code>:</p><pre><code>for (const index in students) {\n    // this is fine\n}\n\nfor (const student of students) {\n    // this is also fine\n}</code></pre><p>But not the general <code>for</code>-loop:</p><pre><code>for (const i = 0; i &lt; 3; i++) {\n    // oops, this is going to fail with\n    // a Type Error after the first iteration\n}</code></pre><p>What's wrong here? We could use <code>let</code> just fine in this construct, and we asserted that it creates a new <code>i</code> for each loop iteration scope, so it doesn't even seem to be a \"re-declaration.\"</p><p>Let's mentally \"expand\" that loop like we did earlier:</p><pre><code>{\n    // a fictional variable for illustration\n    const $$i = 0;\n\n    for ( ; $$i &lt; 3; $$i++) {\n        // here's our actual loop `i`!\n        const i = $$i;\n        // ..\n    }\n}</code></pre><p>Do you spot the problem? Our <code>i</code> is indeed just created once inside the loop. That's not the problem. The problem is the conceptual <code>$$i</code> that must be incremented each time with the <code>$$i++</code> expression. That's <strong>re-assignment</strong> (not \"re-declaration\"), which isn't allowed for constants.</p><p>Remember, this \"expanded\" form is only a conceptual model to help you intuit the source of the problem. You might wonder if JS could have effectively made the <code>const $$i = 0</code> instead into <code>let $ii = 0</code>, which would then allow <code>const</code> to work with our classic <code>for</code>-loop? It's possible, but then it could have introduced potentially surprising exceptions to <code>for</code>-loop semantics.</p><p>For example, it would have been a rather arbitrary (and likely confusing) nuanced exception to allow <code>i++</code> in the <code>for</code>-loop header to skirt strictness of the <code>const</code> assignment, but not allow other re-assignments of <code>i</code> inside the loop iteration, as is sometimes useful.</p><p>The straightforward answer is: <code>const</code> can't be used with the classic <code>for</code>-loop form because of the required re-assignment.</p><p>Interestingly, if you don't do re-assignment, then it's valid:</p><pre><code>var keepGoing = true;\n\nfor (const i = 0; keepGoing; /* nothing here */ ) {\n    keepGoing = (Math.random() &gt; 0.5);\n    // ..\n}</code></pre><p>That works, but it's pointless. There's no reason to declare <code>i</code> in that position with a <code>const</code>, since the whole point of such a variable in that position is <strong>to be used for counting iterations</strong>. Just use a different loop form, like a <code>while</code> loop, or use a <code>let</code>!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Loops", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So it's clear from our previous discussion that JS doesn't really want us to \"re-declare\" our variables within the same scope. That probably seems like a straightforward admonition, until you consider what it means for repeated execution of declaration statements in loops. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keepGoing = true;\nwhile (keepGoing) {\n    let value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Is ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " being \"re-declared\" repeatedly in this program? Will we get errors thrown? No.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All the rules of scope (including \"re-declaration\" of ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "-created variables) are applied ", "type": "text"}, {"text": "per scope instance", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". In other words, each time a scope is entered during execution, everything resets.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each loop iteration is its own new scope instance, and within each scope instance, ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " is only being declared once. So there's no attempted \"re-declaration,\" and thus no error. Before we consider other loop forms, what if the ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration in the previous snippet were changed to a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keepGoing = true;\nwhile (keepGoing) {\n    var value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Is ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " being \"re-declared\" here, especially since we know ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " allows it? No. Because ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not treated as a block-scoping declaration (see Chapter 6), it attaches itself to the global scope. So there's just one ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable, in the same scope as ", "type": "text"}, {"text": "keepGoing", "type": "text", "marks": [{"type": "code"}]}, {"text": " (global scope, in this case). No \"re-declaration\" here, either!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One way to keep this all straight is to remember that ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " keywords are effectively ", "type": "text"}, {"text": "removed", "type": "text", "marks": [{"type": "italic"}]}, {"text": " from the code by the time it starts to execute. They're handled entirely by the compiler.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you mentally erase the declarator keywords and then try to process the code, it should help you decide if and when (re-)declarations might occur.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about \"re-declaration\" with other loop forms, like ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loops?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (let i = 0; i < 3; i++) {\n    let value = i * 10;\n    console.log(`${ i }: ${ value }`);\n}\n// 0: 0\n// 1: 10\n// 2: 20", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It should be clear that there's only one ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " declared per scope instance. But what about ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": "? Is it being \"re-declared\"?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To answer that, consider what scope ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " is in. It might seem like it would be in the outer (in this case, global) scope, but it's not. It's in the scope of ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop body, just like ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " is. In fact, you could sorta think about that loop in this more verbose equivalent form:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "{\n    // a fictional variable for illustration\n    let $$i = 0;\n\n    for ( /* nothing */; $$i < 3; $$i++) {\n        // here's our actual loop `i`!\n        let i = $$i;\n\n        let value = i * 10;\n        console.log(`${ i }: ${ value }`);\n    }\n    // 0: 0\n    // 1: 10\n    // 2: 20\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now it should be clear: the ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables are both declared exactly once ", "type": "text"}, {"text": "per scope instance", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". No \"re-declaration\" here.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about other ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop forms?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (let index in students) {\n    // this is fine\n}\n\nfor (let student of students) {\n    // so is this\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Same thing with ", "type": "text"}, {"text": "for..in", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " loops: the declared variable is treated as ", "type": "text"}, {"text": "inside", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the loop body, and thus is handled per iteration (aka, per scope instance). No \"re-declaration.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "OK, I know you're thinking that I sound like a broken record at this point. But let's explore how ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " impacts these looping constructs. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keepGoing = true;\nwhile (keepGoing) {\n    // ooo, a shiny constant!\n    const value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Just like the ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " variant of this program we saw earlier, ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " is being run exactly once within each loop iteration, so it's safe from \"re-declaration\" troubles. But things get more complicated when we talk about ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loops.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "for..in", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " are fine to use with ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (const index in students) {\n    // this is fine\n}\n\nfor (const student of students) {\n    // this is also fine\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But not the general ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (const i = 0; i < 3; i++) {\n    // oops, this is going to fail with\n    // a Type Error after the first iteration\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What's wrong here? We could use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " just fine in this construct, and we asserted that it creates a new ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " for each loop iteration scope, so it doesn't even seem to be a \"re-declaration.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's mentally \"expand\" that loop like we did earlier:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "{\n    // a fictional variable for illustration\n    const $$i = 0;\n\n    for ( ; $$i < 3; $$i++) {\n        // here's our actual loop `i`!\n        const i = $$i;\n        // ..\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Do you spot the problem? Our ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " is indeed just created once inside the loop. That's not the problem. The problem is the conceptual ", "type": "text"}, {"text": "$$i", "type": "text", "marks": [{"type": "code"}]}, {"text": " that must be incremented each time with the ", "type": "text"}, {"text": "$$i++", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression. That's ", "type": "text"}, {"text": "re-assignment", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (not \"re-declaration\"), which isn't allowed for constants.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember, this \"expanded\" form is only a conceptual model to help you intuit the source of the problem. You might wonder if JS could have effectively made the ", "type": "text"}, {"text": "const $$i = 0", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead into ", "type": "text"}, {"text": "let $ii = 0", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which would then allow ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " to work with our classic ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop? It's possible, but then it could have introduced potentially surprising exceptions to ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop semantics.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, it would have been a rather arbitrary (and likely confusing) nuanced exception to allow ", "type": "text"}, {"text": "i++", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop header to skirt strictness of the ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " assignment, but not allow other re-assignments of ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside the loop iteration, as is sometimes useful.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The straightforward answer is: ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " can't be used with the classic ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop form because of the required re-assignment.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Interestingly, if you don't do re-assignment, then it's valid:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keepGoing = true;\n\nfor (const i = 0; keepGoing; /* nothing here */ ) {\n    keepGoing = (Math.random() > 0.5);\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That works, but it's pointless. There's no reason to declare ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " in that position with a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", since the whole point of such a variable in that position is ", "type": "text"}, {"text": "to be used for counting iterations", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". Just use a different loop form, like a ", "type": "text"}, {"text": "while", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop, or use a ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "!", "type": "text"}]}]}, "article_text": "Loops\n\nSo it's clear from our previous discussion that JS doesn't really want us to \"re-declare\" our variables within the same scope. That probably seems like a straightforward admonition, until you consider what it means for repeated execution of declaration statements in loops. Consider:\n\nvar keepGoing = true;\nwhile (keepGoing) {\n    let value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}\n\nIs value being \"re-declared\" repeatedly in this program? Will we get errors thrown? No.\n\nAll the rules of scope (including \"re-declaration\" of let-created variables) are applied per scope instance. In other words, each time a scope is entered during execution, everything resets.\n\nEach loop iteration is its own new scope instance, and within each scope instance, value is only being declared once. So there's no attempted \"re-declaration,\" and thus no error. Before we consider other loop forms, what if the value declaration in the previous snippet were changed to a var?\n\nvar keepGoing = true;\nwhile (keepGoing) {\n    var value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}\n\nIs value being \"re-declared\" here, especially since we know var allows it? No. Because var is not treated as a block-scoping declaration (see Chapter 6), it attaches itself to the global scope. So there's just one value variable, in the same scope as keepGoing (global scope, in this case). No \"re-declaration\" here, either!\n\nOne way to keep this all straight is to remember that var, let, and const keywords are effectively removed from the code by the time it starts to execute. They're handled entirely by the compiler.\n\nIf you mentally erase the declarator keywords and then try to process the code, it should help you decide if and when (re-)declarations might occur.\n\nWhat about \"re-declaration\" with other loop forms, like for-loops?\n\nfor (let i = 0; i < 3; i++) {\n    let value = i * 10;\n    console.log(`${ i }: ${ value }`);\n}\n// 0: 0\n// 1: 10\n// 2: 20\n\nIt should be clear that there's only one value declared per scope instance. But what about i? Is it being \"re-declared\"?\n\nTo answer that, consider what scope i is in. It might seem like it would be in the outer (in this case, global) scope, but it's not. It's in the scope of for-loop body, just like value is. In fact, you could sorta think about that loop in this more verbose equivalent form:\n\n{\n    // a fictional variable for illustration\n    let $$i = 0;\n\n    for ( /* nothing */; $$i < 3; $$i++) {\n        // here's our actual loop `i`!\n        let i = $$i;\n\n        let value = i * 10;\n        console.log(`${ i }: ${ value }`);\n    }\n    // 0: 0\n    // 1: 10\n    // 2: 20\n}\n\nNow it should be clear: the i and value variables are both declared exactly once per scope instance. No \"re-declaration\" here.\n\nWhat about other for-loop forms?\n\nfor (let index in students) {\n    // this is fine\n}\n\nfor (let student of students) {\n    // so is this\n}\n\nSame thing with for..in and for..of loops: the declared variable is treated as inside the loop body, and thus is handled per iteration (aka, per scope instance). No \"re-declaration.\"\n\nOK, I know you're thinking that I sound like a broken record at this point. But let's explore how const impacts these looping constructs. Consider:\n\nvar keepGoing = true;\nwhile (keepGoing) {\n    // ooo, a shiny constant!\n    const value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}\n\nJust like the let variant of this program we saw earlier, const is being run exactly once within each loop iteration, so it's safe from \"re-declaration\" troubles. But things get more complicated when we talk about for-loops.\n\nfor..in and for..of are fine to use with const:\n\nfor (const index in students) {\n    // this is fine\n}\n\nfor (const student of students) {\n    // this is also fine\n}\n\nBut not the general for-loop:\n\nfor (const i = 0; i < 3; i++) {\n    // oops, this is going to fail with\n    // a Type Error after the first iteration\n}\n\nWhat's wrong here? We could use let just fine in this construct, and we asserted that it creates a new i for each loop iteration scope, so it doesn't even seem to be a \"re-declaration.\"\n\nLet's mentally \"expand\" that loop like we did earlier:\n\n{\n    // a fictional variable for illustration\n    const $$i = 0;\n\n    for ( ; $$i < 3; $$i++) {\n        // here's our actual loop `i`!\n        const i = $$i;\n        // ..\n    }\n}\n\nDo you spot the problem? Our i is indeed just created once inside the loop. That's not the problem. The problem is the conceptual $$i that must be incremented each time with the $$i++ expression. That's re-assignment (not \"re-declaration\"), which isn't allowed for constants.\n\nRemember, this \"expanded\" form is only a conceptual model to help you intuit the source of the problem. You might wonder if JS could have effectively made the const $$i = 0 instead into let $ii = 0, which would then allow const to work with our classic for-loop? It's possible, but then it could have introduced potentially surprising exceptions to for-loop semantics.\n\nFor example, it would have been a rather arbitrary (and likely confusing) nuanced exception to allow i++ in the for-loop header to skirt strictness of the const assignment, but not allow other re-assignments of i inside the loop iteration, as is sometimes useful.\n\nThe straightforward answer is: const can't be used with the classic for-loop form because of the required re-assignment.\n\nInterestingly, if you don't do re-assignment, then it's valid:\n\nvar keepGoing = true;\n\nfor (const i = 0; keepGoing; /* nothing here */ ) {\n    keepGoing = (Math.random() > 0.5);\n    // ..\n}\n\nThat works, but it's pointless. There's no reason to declare i in that position with a const, since the whole point of such a variable in that position is to be used for counting iterations. Just use a different loop form, like a while loop, or use a let!"}, "id": 208}]}, {"data": {"uuid": "7c361504-5108-481f-89cd-3b855b13d0fb", "user": 1, "title": "Uninitialized Variables (aka, TDZ)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:23:28.942198+00:00", "updated_on": "2023-06-09 01:23:58.817639+00:00", "article_html": "<h2>Uninitialized Variables (aka, TDZ)</h2><p>With <code>var</code> declarations, the variable is \"hoisted\" to the top of its scope. But it's also automatically initialized to the <code>undefined</code> value, so that the variable can be used throughout the entire scope.</p><p>However, <code>let</code> and <code>const</code> declarations are not quite the same in this respect.</p><p>Consider:</p><pre><code>console.log(studentName);\n// ReferenceError\n\nlet studentName = \"Suzy\";</code></pre><p>The result of this program is that a <code>ReferenceError</code> is thrown on the first line. Depending on your JS environment, the error message may say something like: \"Cannot access studentName before initialization.\"</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The error message as seen here used to be much more vague or misleading. Thankfully, several of us in the community were successfully able to lobby for JS engines to improve this error message so it more accurately tells you what's wrong!</p></td></tr></tbody></table><p>That error message is quite indicative of what's wrong: <code>studentName</code> exists on line 1, but it's not been initialized, so it cannot be used yet. Let's try this:</p><pre><code>studentName = \"Suzy\";   // let's try to initialize it!\n// ReferenceError\n\nconsole.log(studentName);\n\nlet studentName;</code></pre><p>Oops. We still get the <code>ReferenceError</code>, but now on the first line where we're trying to assign to (aka, initialize!) this so-called \"uninitialized\" variable <code>studentName</code>. What's the deal!?</p><p>The real question is, how do we initialize an uninitialized variable? For <code>let</code>/<code>const</code>, the <strong>only way</strong> to do so is with an assignment attached to a declaration statement. An assignment by itself is insufficient! Consider:</p><pre><code>let studentName = \"Suzy\";\nconsole.log(studentName);   // Suzy</code></pre><p>Here, we are initializing the <code>studentName</code> (in this case, to <code>\"Suzy\"</code> instead of <code>undefined</code>) by way of the <code>let</code> declaration statement form that's coupled with an assignment.</p><p>Alternatively:</p><pre><code>// ..\n\nlet studentName;\n// or:\n// let studentName = undefined;\n\n// ..\n\nstudentName = \"Suzy\";\n\nconsole.log(studentName);\n// Suzy</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>That's interesting! Recall from earlier, we said that <code>var studentName;</code> is <em>not</em> the same as <code>var studentName = undefined;</code>, but here with <code>let</code>, they behave the same. The difference comes down to the fact that <code>var studentName</code> automatically initializes at the top of the scope, where <code>let studentName</code> does not.</p></td></tr></tbody></table><p>Remember that we've asserted a few times so far that <em>Compiler</em> ends up removing any <code>var</code>/<code>let</code>/<code>const</code> declarators, replacing them with the instructions at the top of each scope to register the appropriate identifiers.</p><p>So if we analyze what's going on here, we see that an additional nuance is that <em>Compiler</em> is also adding an instruction in the middle of the program, at the point where the variable <code>studentName</code> was declared, to handle that declaration's auto-initialization. We cannot use the variable at any point prior to that initialization occuring. The same goes for <code>const</code> as it does for <code>let</code>.</p><p>The term coined by TC39 to refer to this <em>period of time</em> from the entering of a scope to where the auto-initialization of the variable occurs is: Temporal Dead Zone (TDZ).</p><p>The TDZ is the time window where a variable exists but is still uninitialized, and therefore cannot be accessed in any way. Only the execution of the instructions left by <em>Compiler</em> at the point of the original declaration can do that initialization. After that moment, the TDZ is done, and the variable is free to be used for the rest of the scope.</p><p>A <code>var</code> also technically has a TDZ, but it's zero in length and thus unobservable to our programs! Only <code>let</code> and <code>const</code> have an observable TDZ.</p><p>By the way, \"temporal\" in TDZ does indeed refer to <em>time</em> not <em>position in code</em>. Consider:</p><pre><code>askQuestion();\n// ReferenceError\n\nlet studentName = \"Suzy\";\n\nfunction askQuestion() {\n    console.log(`${ studentName }, do you know?`);\n}</code></pre><p>Even though positionally the <code>console.log(..)</code> referencing <code>studentName</code> comes <em>after</em> the <code>let studentName</code> declaration, timing wise the <code>askQuestion()</code> function is invoked <em>before</em> the <code>let</code> statement is encountered, while <code>studentName</code> is still in its TDZ! Hence the error.</p><p>There's a common misconception that TDZ means <code>let</code> and <code>const</code> do not hoist. This is an inaccurate, or at least slightly misleading, claim. They definitely hoist.</p><p>The actual difference is that <code>let</code>/<code>const</code> declarations do not automatically initialize at the beginning of the scope, the way <code>var</code> does. The <em>debate</em> then is if the auto-initialization is <em>part of</em> hoisting, or not? I think auto-registration of a variable at the top of the scope (i.e., what I call \"hoisting\") and auto-initialization at the top of the scope (to <code>undefined</code>) are distinct operations and shouldn't be lumped together under the single term \"hoisting.\"</p><p>We've already seen that <code>let</code> and <code>const</code> don't auto-initialize at the top of the scope. But let's prove that <code>let</code> and <code>const</code> <em>do</em> hoist (auto-register at the top of the scope), courtesy of our friend shadowing (see \"Shadowing\" in Chapter 3):</p><pre><code>var studentName = \"Kyle\";\n\n{\n    console.log(studentName);\n    // ???\n\n    // ..\n\n    let studentName = \"Suzy\";\n\n    console.log(studentName);\n    // Suzy\n}</code></pre><p>What's going to happen with the first <code>console.log(..)</code> statement? If <code>let studentName</code> didn't hoist to the top of the scope, then the first <code>console.log(..)</code> <em>should</em> print <code>\"Kyle\"</code>, right? At that moment, it would seem, only the outer <code>studentName</code> exists, so that's the variable <code>console.log(..)</code> should access and print.</p><p>But instead, the first <code>console.log(..)</code> throws a TDZ error, because in fact, the inner scope's <code>studentName</code> <strong>was</strong> hoisted (auto-registered at the top of the scope). What <strong>didn't</strong> happen (yet!) was the auto-initialization of that inner <code>studentName</code>; it's still uninitialized at that moment, hence the TDZ violation!</p><p>So to summarize, TDZ errors occur because <code>let</code>/<code>const</code> declarations <em>do</em> hoist their declarations to the top of their scopes, but unlike <code>var</code>, they defer the auto-initialization of their variables until the moment in the code's sequencing where the original declaration appeared. This window of time (hint: temporal), whatever its length, is the TDZ.</p><p>How can you avoid TDZ errors?</p><p>My advice: always put your <code>let</code> and <code>const</code> declarations at the top of any scope. Shrink the TDZ window to zero (or near zero) length, and then it'll be moot.</p><p>But why is TDZ even a thing? Why didn't TC39 dictate that <code>let</code>/<code>const</code> auto-initialize the way <code>var</code> does? Just be patient, we'll come back to explore the <em>why</em> of TDZ in Appendix A.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Uninitialized Variables (aka, TDZ)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations, the variable is \"hoisted\" to the top of its scope. But it's also automatically initialized to the ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " value, so that the variable can be used throughout the entire scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However, ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations are not quite the same in this respect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "console.log(studentName);\n// ReferenceError\n\nlet studentName = \"Suzy\";", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The result of this program is that a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " is thrown on the first line. Depending on your JS environment, the error message may say something like: \"Cannot access studentName before initialization.\"", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The error message as seen here used to be much more vague or misleading. Thankfully, several of us in the community were successfully able to lobby for JS engines to improve this error message so it more accurately tells you what's wrong!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "That error message is quite indicative of what's wrong: ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " exists on line 1, but it's not been initialized, so it cannot be used yet. Let's try this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "studentName = \"Suzy\";   // let's try to initialize it!\n// ReferenceError\n\nconsole.log(studentName);\n\nlet studentName;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Oops. We still get the ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but now on the first line where we're trying to assign to (aka, initialize!) this so-called \"uninitialized\" variable ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ". What's the deal!?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The real question is, how do we initialize an uninitialized variable? For ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the ", "type": "text"}, {"text": "only way", "type": "text", "marks": [{"type": "bold"}]}, {"text": " to do so is with an assignment attached to a declaration statement. An assignment by itself is insufficient! Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "let studentName = \"Suzy\";\nconsole.log(studentName);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, we are initializing the ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " (in this case, to ", "type": "text"}, {"text": "\"Suzy\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ") by way of the ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration statement form that's coupled with an assignment.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Alternatively:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// ..\n\nlet studentName;\n// or:\n// let studentName = undefined;\n\n// ..\n\nstudentName = \"Suzy\";\n\nconsole.log(studentName);\n// Suzy", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "That's interesting! Recall from earlier, we said that ", "type": "text"}, {"text": "var studentName;", "type": "text", "marks": [{"type": "code"}]}, {"text": " is ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the same as ", "type": "text"}, {"text": "var studentName = undefined;", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but here with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", they behave the same. The difference comes down to the fact that ", "type": "text"}, {"text": "var studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " automatically initializes at the top of the scope, where ", "type": "text"}, {"text": "let studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " does not.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Remember that we've asserted a few times so far that ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ends up removing any ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarators, replacing them with the instructions at the top of each scope to register the appropriate identifiers.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So if we analyze what's going on here, we see that an additional nuance is that ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is also adding an instruction in the middle of the program, at the point where the variable ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " was declared, to handle that declaration's auto-initialization. We cannot use the variable at any point prior to that initialization occuring. The same goes for ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " as it does for ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The term coined by TC39 to refer to this ", "type": "text"}, {"text": "period of time", "type": "text", "marks": [{"type": "italic"}]}, {"text": " from the entering of a scope to where the auto-initialization of the variable occurs is: Temporal Dead Zone (TDZ).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The TDZ is the time window where a variable exists but is still uninitialized, and therefore cannot be accessed in any way. Only the execution of the instructions left by ", "type": "text"}, {"text": "Compiler", "type": "text", "marks": [{"type": "italic"}]}, {"text": " at the point of the original declaration can do that initialization. After that moment, the TDZ is done, and the variable is free to be used for the rest of the scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " also technically has a TDZ, but it's zero in length and thus unobservable to our programs! Only ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " have an observable TDZ.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By the way, \"temporal\" in TDZ does indeed refer to ", "type": "text"}, {"text": "time", "type": "text", "marks": [{"type": "italic"}]}, {"text": " not ", "type": "text"}, {"text": "position in code", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "askQuestion();\n// ReferenceError\n\nlet studentName = \"Suzy\";\n\nfunction askQuestion() {\n    console.log(`${ studentName }, do you know?`);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even though positionally the ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " referencing ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " comes ", "type": "text"}, {"text": "after", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the ", "type": "text"}, {"text": "let studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration, timing wise the ", "type": "text"}, {"text": "askQuestion()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is invoked ", "type": "text"}, {"text": "before", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement is encountered, while ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is still in its TDZ! Hence the error.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's a common misconception that TDZ means ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " do not hoist. This is an inaccurate, or at least slightly misleading, claim. They definitely hoist.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The actual difference is that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations do not automatically initialize at the beginning of the scope, the way ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " does. The ", "type": "text"}, {"text": "debate", "type": "text", "marks": [{"type": "italic"}]}, {"text": " then is if the auto-initialization is ", "type": "text"}, {"text": "part of", "type": "text", "marks": [{"type": "italic"}]}, {"text": " hoisting, or not? I think auto-registration of a variable at the top of the scope (i.e., what I call \"hoisting\") and auto-initialization at the top of the scope (to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ") are distinct operations and shouldn't be lumped together under the single term \"hoisting.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We've already seen that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " don't auto-initialize at the top of the scope. But let's prove that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "do", "type": "text", "marks": [{"type": "italic"}]}, {"text": " hoist (auto-register at the top of the scope), courtesy of our friend shadowing (see \"Shadowing\" in Chapter 3):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Kyle\";\n\n{\n    console.log(studentName);\n    // ???\n\n    // ..\n\n    let studentName = \"Suzy\";\n\n    console.log(studentName);\n    // Suzy\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What's going to happen with the first ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement? If ", "type": "text"}, {"text": "let studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " didn't hoist to the top of the scope, then the first ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "should", "type": "text", "marks": [{"type": "italic"}]}, {"text": " print ", "type": "text"}, {"text": "\"Kyle\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", right? At that moment, it would seem, only the outer ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " exists, so that's the variable ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " should access and print.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But instead, the first ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " throws a TDZ error, because in fact, the inner scope's ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "was", "type": "text", "marks": [{"type": "bold"}]}, {"text": " hoisted (auto-registered at the top of the scope). What ", "type": "text"}, {"text": "didn't", "type": "text", "marks": [{"type": "bold"}]}, {"text": " happen (yet!) was the auto-initialization of that inner ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": "; it's still uninitialized at that moment, hence the TDZ violation!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So to summarize, TDZ errors occur because ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations ", "type": "text"}, {"text": "do", "type": "text", "marks": [{"type": "italic"}]}, {"text": " hoist their declarations to the top of their scopes, but unlike ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", they defer the auto-initialization of their variables until the moment in the code's sequencing where the original declaration appeared. This window of time (hint: temporal), whatever its length, is the TDZ.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "How can you avoid TDZ errors?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My advice: always put your ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations at the top of any scope. Shrink the TDZ window to zero (or near zero) length, and then it'll be moot.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But why is TDZ even a thing? Why didn't TC39 dictate that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " auto-initialize the way ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " does? Just be patient, we'll come back to explore the ", "type": "text"}, {"text": "why", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of TDZ in Appendix A.", "type": "text"}]}]}, "article_text": "Uninitialized Variables (aka, TDZ)\n\nWith var declarations, the variable is \"hoisted\" to the top of its scope. But it's also automatically initialized to the undefined value, so that the variable can be used throughout the entire scope.\n\nHowever, let and const declarations are not quite the same in this respect.\n\nConsider:\n\nconsole.log(studentName);\n// ReferenceError\n\nlet studentName = \"Suzy\";\n\nThe result of this program is that a ReferenceError is thrown on the first line. Depending on your JS environment, the error message may say something like: \"Cannot access studentName before initialization.\"\n\nNOTE:\n\nThe error message as seen here used to be much more vague or misleading. Thankfully, several of us in the community were successfully able to lobby for JS engines to improve this error message so it more accurately tells you what's wrong!\n\nThat error message is quite indicative of what's wrong: studentName exists on line 1, but it's not been initialized, so it cannot be used yet. Let's try this:\n\nstudentName = \"Suzy\";   // let's try to initialize it!\n// ReferenceError\n\nconsole.log(studentName);\n\nlet studentName;\n\nOops. We still get the ReferenceError, but now on the first line where we're trying to assign to (aka, initialize!) this so-called \"uninitialized\" variable studentName. What's the deal!?\n\nThe real question is, how do we initialize an uninitialized variable? For let/const, the only way to do so is with an assignment attached to a declaration statement. An assignment by itself is insufficient! Consider:\n\nlet studentName = \"Suzy\";\nconsole.log(studentName);   // Suzy\n\nHere, we are initializing the studentName (in this case, to \"Suzy\" instead of undefined) by way of the let declaration statement form that's coupled with an assignment.\n\nAlternatively:\n\n// ..\n\nlet studentName;\n// or:\n// let studentName = undefined;\n\n// ..\n\nstudentName = \"Suzy\";\n\nconsole.log(studentName);\n// Suzy\n\nNOTE:\n\nThat's interesting! Recall from earlier, we said that var studentName; is not the same as var studentName = undefined;, but here with let, they behave the same. The difference comes down to the fact that var studentName automatically initializes at the top of the scope, where let studentName does not.\n\nRemember that we've asserted a few times so far that Compiler ends up removing any var/let/const declarators, replacing them with the instructions at the top of each scope to register the appropriate identifiers.\n\nSo if we analyze what's going on here, we see that an additional nuance is that Compiler is also adding an instruction in the middle of the program, at the point where the variable studentName was declared, to handle that declaration's auto-initialization. We cannot use the variable at any point prior to that initialization occuring. The same goes for const as it does for let.\n\nThe term coined by TC39 to refer to this period of time from the entering of a scope to where the auto-initialization of the variable occurs is: Temporal Dead Zone (TDZ).\n\nThe TDZ is the time window where a variable exists but is still uninitialized, and therefore cannot be accessed in any way. Only the execution of the instructions left by Compiler at the point of the original declaration can do that initialization. After that moment, the TDZ is done, and the variable is free to be used for the rest of the scope.\n\nA var also technically has a TDZ, but it's zero in length and thus unobservable to our programs! Only let and const have an observable TDZ.\n\nBy the way, \"temporal\" in TDZ does indeed refer to time not position in code. Consider:\n\naskQuestion();\n// ReferenceError\n\nlet studentName = \"Suzy\";\n\nfunction askQuestion() {\n    console.log(`${ studentName }, do you know?`);\n}\n\nEven though positionally the console.log(..) referencing studentName comes after the let studentName declaration, timing wise the askQuestion() function is invoked before the let statement is encountered, while studentName is still in its TDZ! Hence the error.\n\nThere's a common misconception that TDZ means let and const do not hoist. This is an inaccurate, or at least slightly misleading, claim. They definitely hoist.\n\nThe actual difference is that let/const declarations do not automatically initialize at the beginning of the scope, the way var does. The debate then is if the auto-initialization is part of hoisting, or not? I think auto-registration of a variable at the top of the scope (i.e., what I call \"hoisting\") and auto-initialization at the top of the scope (to undefined) are distinct operations and shouldn't be lumped together under the single term \"hoisting.\"\n\nWe've already seen that let and const don't auto-initialize at the top of the scope. But let's prove that let and const do hoist (auto-register at the top of the scope), courtesy of our friend shadowing (see \"Shadowing\" in Chapter 3):\n\nvar studentName = \"Kyle\";\n\n{\n    console.log(studentName);\n    // ???\n\n    // ..\n\n    let studentName = \"Suzy\";\n\n    console.log(studentName);\n    // Suzy\n}\n\nWhat's going to happen with the first console.log(..) statement? If let studentName didn't hoist to the top of the scope, then the first console.log(..) should print \"Kyle\", right? At that moment, it would seem, only the outer studentName exists, so that's the variable console.log(..) should access and print.\n\nBut instead, the first console.log(..) throws a TDZ error, because in fact, the inner scope's studentName was hoisted (auto-registered at the top of the scope). What didn't happen (yet!) was the auto-initialization of that inner studentName; it's still uninitialized at that moment, hence the TDZ violation!\n\nSo to summarize, TDZ errors occur because let/const declarations do hoist their declarations to the top of their scopes, but unlike var, they defer the auto-initialization of their variables until the moment in the code's sequencing where the original declaration appeared. This window of time (hint: temporal), whatever its length, is the TDZ.\n\nHow can you avoid TDZ errors?\n\nMy advice: always put your let and const declarations at the top of any scope. Shrink the TDZ window to zero (or near zero) length, and then it'll be moot.\n\nBut why is TDZ even a thing? Why didn't TC39 dictate that let/const auto-initialize the way var does? Just be patient, we'll come back to explore the why of TDZ in Appendix A."}, "id": 209}, {"data": {"uuid": "3660d981-1392-42ce-9054-aa05312126d7", "user": 1, "title": "Finally Initialized", "author": "Kyle Simpson", "created_on": "2023-06-09 01:24:14.730506+00:00", "updated_on": "2023-06-09 01:24:32.050276+00:00", "article_html": "<h2>Finally Initialized</h2><p>Working with variables has much more nuance than it seems at first glance. <em>Hoisting</em>, <em>(re)declaration</em>, and the <em>TDZ</em> are common sources of confusion for developers, especially those who have worked in other languages before coming to JS. Before moving on, make sure your mental model is fully grounded on these aspects of JS scope and variables.</p><p>Hoisting is generally cited as an explicit mechanism of the JS engine, but it's really more a metaphor to describe the various ways JS handles variable declarations during compilation. But even as a metaphor, hoisting offers useful structure for thinking about the life-cycle of a variable\u2014when it's created, when it's available to use, when it goes away.</p><p>Declaration and re-declaration of variables tend to cause confusion when thought of as runtime operations. But if you shift to compile-time thinking for these operations, the quirks and <em>shadows</em> diminish.</p><p>The TDZ (temporal dead zone) error is strange and frustrating when encountered. Fortunately, TDZ is relatively straightforward to avoid if you're always careful to place <code>let</code>/<code>const</code> declarations at the top of any scope.</p><p>As you successfully navigate these twists and turns of variable scope, the next chapter will lay out the factors that guide our decisions to place our declarations in various scopes, especially nested blocks.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Finally Initialized", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Working with variables has much more nuance than it seems at first glance. ", "type": "text"}, {"text": "Hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", ", "type": "text"}, {"text": "(re)declaration", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and the ", "type": "text"}, {"text": "TDZ", "type": "text", "marks": [{"type": "italic"}]}, {"text": " are common sources of confusion for developers, especially those who have worked in other languages before coming to JS. Before moving on, make sure your mental model is fully grounded on these aspects of JS scope and variables.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Hoisting is generally cited as an explicit mechanism of the JS engine, but it's really more a metaphor to describe the various ways JS handles variable declarations during compilation. But even as a metaphor, hoisting offers useful structure for thinking about the life-cycle of a variable\u2014when it's created, when it's available to use, when it goes away.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Declaration and re-declaration of variables tend to cause confusion when thought of as runtime operations. But if you shift to compile-time thinking for these operations, the quirks and ", "type": "text"}, {"text": "shadows", "type": "text", "marks": [{"type": "italic"}]}, {"text": " diminish.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The TDZ (temporal dead zone) error is strange and frustrating when encountered. Fortunately, TDZ is relatively straightforward to avoid if you're always careful to place ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations at the top of any scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As you successfully navigate these twists and turns of variable scope, the next chapter will lay out the factors that guide our decisions to place our declarations in various scopes, especially nested blocks.", "type": "text"}]}]}, "article_text": "Finally Initialized\n\nWorking with variables has much more nuance than it seems at first glance. Hoisting, (re)declaration, and the TDZ are common sources of confusion for developers, especially those who have worked in other languages before coming to JS. Before moving on, make sure your mental model is fully grounded on these aspects of JS scope and variables.\n\nHoisting is generally cited as an explicit mechanism of the JS engine, but it's really more a metaphor to describe the various ways JS handles variable declarations during compilation. But even as a metaphor, hoisting offers useful structure for thinking about the life-cycle of a variable\u2014when it's created, when it's available to use, when it goes away.\n\nDeclaration and re-declaration of variables tend to cause confusion when thought of as runtime operations. But if you shift to compile-time thinking for these operations, the quirks and shadows diminish.\n\nThe TDZ (temporal dead zone) error is strange and frustrating when encountered. Fortunately, TDZ is relatively straightforward to avoid if you're always careful to place let/const declarations at the top of any scope.\n\nAs you successfully navigate these twists and turns of variable scope, the next chapter will lay out the factors that guide our decisions to place our declarations in various scopes, especially nested blocks."}, "id": 210}]}, {"data": {"uuid": "09458c11-09d3-4a4c-844c-3d42aaa59699", "user": 1, "title": "Chapter 6: Limiting Scope Exposure", "author": "Kyle Simpson", "created_on": "2023-06-09 01:25:08.326369+00:00", "updated_on": "2023-06-09 01:25:23.845578+00:00", "article_html": "<h1>Chapter 6: Limiting Scope Exposure</h1><p>So far our focus has been explaining the mechanics of how scopes and variables work. With that foundation now firmly in place, our attention raises to a higher level of thinking: decisions and patterns we apply across the whole program.</p><p>To begin, we're going to look at how and why we should be using different levels of scope (functions and blocks) to organize our program's variables, specifically to reduce scope over-exposure.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 6: Limiting Scope Exposure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So far our focus has been explaining the mechanics of how scopes and variables work. With that foundation now firmly in place, our attention raises to a higher level of thinking: decisions and patterns we apply across the whole program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To begin, we're going to look at how and why we should be using different levels of scope (functions and blocks) to organize our program's variables, specifically to reduce scope over-exposure.", "type": "text"}]}]}, "article_text": "Chapter 6: Limiting Scope Exposure\n\nSo far our focus has been explaining the mechanics of how scopes and variables work. With that foundation now firmly in place, our attention raises to a higher level of thinking: decisions and patterns we apply across the whole program.\n\nTo begin, we're going to look at how and why we should be using different levels of scope (functions and blocks) to organize our program's variables, specifically to reduce scope over-exposure."}, "id": 211, "children": [{"data": {"uuid": "74f12be4-cfca-412d-8bba-e52b3fb4c512", "user": 1, "title": "Least Exposure", "author": "Kyle Simpson", "created_on": "2023-06-09 01:25:41.676549+00:00", "updated_on": "2023-06-09 01:26:10.488130+00:00", "article_html": "<h2>Least Exposure</h2><p>It makes sense that functions define their own scopes. But why do we need blocks to create scopes as well?</p><p>Software engineering articulates a fundamental discipline, typically applied to software security, called \"The Principle of Least Privilege\" (POLP). <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md#user-content-fn-POLP-2970b66c68ce8ab442002de97957fe23\"><sup>1</sup></a> And a variation of this principle that applies to our current discussion is typically labeled as \"Least Exposure\" (POLE).</p><p>POLP expresses a defensive posture to software architecture: components of the system should be designed to function with least privilege, least access, least exposure. If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint, because a compromise or failure of one piece has a minimized impact on the rest of the system.</p><p>If POLP focuses on system-level component design, the POLE <em>Exposure</em> variant focuses on a lower level; we'll apply it to how scopes interact with each other.</p><p>In following POLE, what do we want to minimize the exposure of? Simply: the variables registered in each scope.</p><p>Think of it this way: why shouldn't you just place all the variables of your program out in the global scope? That probably immediately feels like a bad idea, but it's worth considering why that is. When variables used by one part of the program are exposed to another part of the program, via scope, there are three main hazards that often arise:</p><ul><li><p><strong>Naming Collisions</strong>: if you use a common and useful variable/function name in two different parts of the program, but the identifier comes from one shared scope (like the global scope), then name collision occurs, and it's very likely that bugs will occur as one part uses the variable/function in a way the other part doesn't expect.</p><p>For example, imagine if all your loops used a single global <code>i</code> index variable, and then it happens that one loop in a function is running during an iteration of a loop from another function, and now the shared <code>i</code> variable gets an unexpected value.</p></li><li><p><strong>Unexpected Behavior</strong>: if you expose variables/functions whose usage is otherwise <em>private</em> to a piece of the program, it allows other developers to use them in ways you didn't intend, which can violate expected behavior and cause bugs.</p><p>For example, if your part of the program assumes an array contains all numbers, but someone else's code accesses and modifies the array to include booleans and strings, your code may then misbehave in unexpected ways.</p><p>Worse, exposure of <em>private</em> details invites those with mal-intent to try to work around limitations you have imposed, to do things with your part of the software that shouldn't be allowed.</p></li><li><p><strong>Unintended Dependency</strong>: if you expose variables/functions unnecessarily, it invites other developers to use and depend on those otherwise <em>private</em> pieces. While that doesn't break your program today, it creates a refactoring hazard in the future, because now you cannot as easily refactor that variable or function without potentially breaking other parts of the software that you don't control.</p><p>For example, if your code relies on an array of numbers, and you later decide it's better to use some other data structure instead of an array, you now must take on the liability of adjusting other affected parts of the software.</p></li></ul><p>POLE, as applied to variable/function scoping, essentially says, default to exposing the bare minimum necessary, keeping everything else as private as possible. Declare variables in as small and deeply nested of scopes as possible, rather than placing everything in the global (or even outer function) scope.</p><p>If you design your software accordingly, you have a much greater chance of avoiding (or at least minimizing) these three hazards.</p><p>Consider:</p><pre><code>function diff(x,y) {\n    if (x &gt; y) {\n        let tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n\ndiff(3,7);      // 4\ndiff(7,5);      // 2</code></pre><p>In this <code>diff(..)</code> function, we want to ensure that <code>y</code> is greater than or equal to <code>x</code>, so that when we subtract (<code>y - x</code>), the result is <code>0</code> or larger. If <code>x</code> is initially larger (the result would be negative!), we swap <code>x</code> and <code>y</code> using a <code>tmp</code> variable, to keep the result positive.</p><p>In this simple example, it doesn't seem to matter whether <code>tmp</code> is inside the <code>if</code> block or whether it belongs at the function level\u2014it certainly shouldn't be a global variable! However, following the POLE principle, <code>tmp</code> should be as hidden in scope as possible. So we block scope <code>tmp</code> (using <code>let</code>) to the <code>if</code> block.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Least Exposure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It makes sense that functions define their own scopes. But why do we need blocks to create scopes as well?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Software engineering articulates a fundamental discipline, typically applied to software security, called \"The Principle of Least Privilege\" (POLP). ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md#user-content-fn-POLP-2970b66c68ce8ab442002de97957fe23", "class": null, "target": "_blank"}}, {"type": "superscript"}]}, {"text": " And a variation of this principle that applies to our current discussion is typically labeled as \"Least Exposure\" (POLE).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "POLP expresses a defensive posture to software architecture: components of the system should be designed to function with least privilege, least access, least exposure. If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint, because a compromise or failure of one piece has a minimized impact on the rest of the system.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If POLP focuses on system-level component design, the POLE ", "type": "text"}, {"text": "Exposure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " variant focuses on a lower level; we'll apply it to how scopes interact with each other.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In following POLE, what do we want to minimize the exposure of? Simply: the variables registered in each scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Think of it this way: why shouldn't you just place all the variables of your program out in the global scope? That probably immediately feels like a bad idea, but it's worth considering why that is. When variables used by one part of the program are exposed to another part of the program, via scope, there are three main hazards that often arise:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Naming Collisions", "type": "text", "marks": [{"type": "bold"}]}, {"text": ": if you use a common and useful variable/function name in two different parts of the program, but the identifier comes from one shared scope (like the global scope), then name collision occurs, and it's very likely that bugs will occur as one part uses the variable/function in a way the other part doesn't expect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, imagine if all your loops used a single global ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " index variable, and then it happens that one loop in a function is running during an iteration of a loop from another function, and now the shared ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable gets an unexpected value.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Unexpected Behavior", "type": "text", "marks": [{"type": "bold"}]}, {"text": ": if you expose variables/functions whose usage is otherwise ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to a piece of the program, it allows other developers to use them in ways you didn't intend, which can violate expected behavior and cause bugs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, if your part of the program assumes an array contains all numbers, but someone else's code accesses and modifies the array to include booleans and strings, your code may then misbehave in unexpected ways.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Worse, exposure of ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " details invites those with mal-intent to try to work around limitations you have imposed, to do things with your part of the software that shouldn't be allowed.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Unintended Dependency", "type": "text", "marks": [{"type": "bold"}]}, {"text": ": if you expose variables/functions unnecessarily, it invites other developers to use and depend on those otherwise ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " pieces. While that doesn't break your program today, it creates a refactoring hazard in the future, because now you cannot as easily refactor that variable or function without potentially breaking other parts of the software that you don't control.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, if your code relies on an array of numbers, and you later decide it's better to use some other data structure instead of an array, you now must take on the liability of adjusting other affected parts of the software.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "POLE, as applied to variable/function scoping, essentially says, default to exposing the bare minimum necessary, keeping everything else as private as possible. Declare variables in as small and deeply nested of scopes as possible, rather than placing everything in the global (or even outer function) scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you design your software accordingly, you have a much greater chance of avoiding (or at least minimizing) these three hazards.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function diff(x,y) {\n    if (x > y) {\n        let tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n\ndiff(3,7);      // 4\ndiff(7,5);      // 2", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this ", "type": "text"}, {"text": "diff(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, we want to ensure that ", "type": "text"}, {"text": "y", "type": "text", "marks": [{"type": "code"}]}, {"text": " is greater than or equal to ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so that when we subtract (", "type": "text"}, {"text": "y - x", "type": "text", "marks": [{"type": "code"}]}, {"text": "), the result is ", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": " or larger. If ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": " is initially larger (the result would be negative!), we swap ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "y", "type": "text", "marks": [{"type": "code"}]}, {"text": " using a ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable, to keep the result positive.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this simple example, it doesn't seem to matter whether ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " is inside the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " block or whether it belongs at the function level\u2014it certainly shouldn't be a global variable! However, following the POLE principle, ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " should be as hidden in scope as possible. So we block scope ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " (using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ") to the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " block.", "type": "text"}]}]}, "article_text": "Least Exposure\n\nIt makes sense that functions define their own scopes. But why do we need blocks to create scopes as well?\n\nSoftware engineering articulates a fundamental discipline, typically applied to software security, called \"The Principle of Least Privilege\" (POLP). 1 And a variation of this principle that applies to our current discussion is typically labeled as \"Least Exposure\" (POLE).\n\nPOLP expresses a defensive posture to software architecture: components of the system should be designed to function with least privilege, least access, least exposure. If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint, because a compromise or failure of one piece has a minimized impact on the rest of the system.\n\nIf POLP focuses on system-level component design, the POLE Exposure variant focuses on a lower level; we'll apply it to how scopes interact with each other.\n\nIn following POLE, what do we want to minimize the exposure of? Simply: the variables registered in each scope.\n\nThink of it this way: why shouldn't you just place all the variables of your program out in the global scope? That probably immediately feels like a bad idea, but it's worth considering why that is. When variables used by one part of the program are exposed to another part of the program, via scope, there are three main hazards that often arise:\n\nNaming Collisions: if you use a common and useful variable/function name in two different parts of the program, but the identifier comes from one shared scope (like the global scope), then name collision occurs, and it's very likely that bugs will occur as one part uses the variable/function in a way the other part doesn't expect.\n\nFor example, imagine if all your loops used a single global i index variable, and then it happens that one loop in a function is running during an iteration of a loop from another function, and now the shared i variable gets an unexpected value.\n\nUnexpected Behavior: if you expose variables/functions whose usage is otherwise private to a piece of the program, it allows other developers to use them in ways you didn't intend, which can violate expected behavior and cause bugs.\n\nFor example, if your part of the program assumes an array contains all numbers, but someone else's code accesses and modifies the array to include booleans and strings, your code may then misbehave in unexpected ways.\n\nWorse, exposure of private details invites those with mal-intent to try to work around limitations you have imposed, to do things with your part of the software that shouldn't be allowed.\n\nUnintended Dependency: if you expose variables/functions unnecessarily, it invites other developers to use and depend on those otherwise private pieces. While that doesn't break your program today, it creates a refactoring hazard in the future, because now you cannot as easily refactor that variable or function without potentially breaking other parts of the software that you don't control.\n\nFor example, if your code relies on an array of numbers, and you later decide it's better to use some other data structure instead of an array, you now must take on the liability of adjusting other affected parts of the software.\n\nPOLE, as applied to variable/function scoping, essentially says, default to exposing the bare minimum necessary, keeping everything else as private as possible. Declare variables in as small and deeply nested of scopes as possible, rather than placing everything in the global (or even outer function) scope.\n\nIf you design your software accordingly, you have a much greater chance of avoiding (or at least minimizing) these three hazards.\n\nConsider:\n\nfunction diff(x,y) {\n    if (x > y) {\n        let tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n\ndiff(3,7);      // 4\ndiff(7,5);      // 2\n\nIn this diff(..) function, we want to ensure that y is greater than or equal to x, so that when we subtract (y - x), the result is 0 or larger. If x is initially larger (the result would be negative!), we swap x and y using a tmp variable, to keep the result positive.\n\nIn this simple example, it doesn't seem to matter whether tmp is inside the if block or whether it belongs at the function level\u2014it certainly shouldn't be a global variable! However, following the POLE principle, tmp should be as hidden in scope as possible. So we block scope tmp (using let) to the if block."}, "id": 212}, {"data": {"uuid": "d517be19-de77-4f76-b49d-a70faf673a4e", "user": 1, "title": "Hiding in Plain (Function) Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 01:26:27.265363+00:00", "updated_on": "2023-06-09 01:26:51.670160+00:00", "article_html": "<h2>Hiding in Plain (Function) Scope</h2><p>It should now be clear why it's important to hide our variable and function declarations in the lowest (most deeply nested) scopes possible. But how do we do so?</p><p>We've already seen the <code>let</code> and <code>const</code> keywords, which are block scoped declarators; we'll come back to them in more detail shortly. But first, what about hiding <code>var</code> or <code>function</code> declarations in scopes? That can easily be done by wrapping a <code>function</code> scope around a declaration.</p><p>Let's consider an example where <code>function</code> scoping can be useful.</p><p>The mathematical operation \"factorial\" (notated as \"6!\") is the multiplication of a given integer against all successively lower integers down to <code>1</code>\u2014actually, you can stop at <code>2</code> since multiplying <code>1</code> does nothing. In other words, \"6!\" is the same as \"6 <em> 5!\", which is the same as \"6 </em> 5 * 4!\", and so on. Because of the nature of the math involved, once any given integer's factorial (like \"4!\") has been calculated, we shouldn't need to do that work again, as it'll always be the same answer.</p><p>So if you naively calculate factorial for <code>6</code>, then later want to calculate factorial for <code>7</code>, you might unnecessarily re-calculate the factorials of all the integers from 2 up to 6. If you're willing to trade memory for speed, you can solve that wasted computation by caching each integer's factorial as it's calculated:</p><pre><code>var cache = {};\n\nfunction factorial(x) {\n    if (x &lt; 2) return 1;\n    if (!(x in cache)) {\n        cache[x] = x * factorial(x - 1);\n    }\n    return cache[x];\n}\n\nfactorial(6);\n// 720\n\ncache;\n// {\n//     \"2\": 2,\n//     \"3\": 6,\n//     \"4\": 24,\n//     \"5\": 120,\n//     \"6\": 720\n// }\n\nfactorial(7);\n// 5040</code></pre><p>We're storing all the computed factorials in <code>cache</code> so that across multiple calls to <code>factorial(..)</code>, the previous computations remain. But the <code>cache</code> variable is pretty obviously a <em>private</em> detail of how <code>factorial(..)</code> works, not something that should be exposed in an outer scope\u2014especially not the global scope.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p><code>factorial(..)</code> here is recursive\u2014a call to itself is made from inside\u2014but that's just for brevity of code sake; a non-recursive implementation would yield the same scoping analysis with respect to <code>cache</code>.</p></td></tr></tbody></table><p>However, fixing this over-exposure issue is not as simple as hiding the <code>cache</code> variable inside <code>factorial(..)</code>, as it might seem. Since we need <code>cache</code> to survive multiple calls, it must be located in a scope outside that function. So what can we do?</p><p>Define another middle scope (between the outer/global scope and the inside of <code>factorial(..)</code>) for <code>cache</code> to be located:</p><pre><code>// outer/global scope\n\nfunction hideTheCache() {\n    // \"middle scope\", where we hide `cache`\n    var cache = {};\n\n    return factorial;\n\n    // **********************\n\n    function factorial(x) {\n        // inner scope\n        if (x &lt; 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n}\n\nvar factorial = hideTheCache();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040</code></pre><p>The <code>hideTheCache()</code> function serves no other purpose than to create a scope for <code>cache</code> to persist in across multiple calls to <code>factorial(..)</code>. But for <code>factorial(..)</code> to have access to <code>cache</code>, we have to define <code>factorial(..)</code> inside that same scope. Then we return the function reference, as a value from <code>hideTheCache()</code>, and store it in an outer scope variable, also named <code>factorial</code>. Now as we call <code>factorial(..)</code> (multiple times!), its persistent <code>cache</code> stays hidden yet accessible only to <code>factorial(..)</code>!</p><p>OK, but... it's going to be tedious to define (and name!) a <code>hideTheCache(..)</code> function scope each time such a need for variable/function hiding occurs, especially since we'll likely want to avoid name collisions with this function by giving each occurrence a unique name. Ugh.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The illustrated technique\u2014caching a function's computed output to optimize performance when repeated calls of the same inputs are expected\u2014is quite common in the Functional Programming (FP) world, canonically referred to as \"memoization\"; this caching relies on closure (see Chapter 7). Also, there are memory usage concerns (addressed in \"A Word About Memory\" in Appendix B). FP libraries will usually provide an optimized and vetted utility for memoization of functions, which would take the place of <code>hideTheCache(..)</code> here. Memoization is beyond the <em>scope</em> (pun intended!) of our discussion, but see my <em>Functional-Light JavaScript</em> book for more information.</p></td></tr></tbody></table><p>Rather than defining a new and uniquely named function each time one of those scope-only-for-the-purpose-of-hiding-a-variable situations occurs, a perhaps better solution is to use a function expression:</p><pre><code>var factorial = (function hideTheCache() {\n    var cache = {};\n\n    function factorial(x) {\n        if (x &lt; 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n\n    return factorial;\n})();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040</code></pre><p>Wait! This is still using a function to create the scope for hiding <code>cache</code>, and in this case, the function is still named <code>hideTheCache</code>, so how does that solve anything?</p><p>Recall from \"Function Name Scope\" (in Chapter 3), what happens to the name identifier from a <code>function</code> expression. Since <code>hideTheCache(..)</code> is defined as a <code>function</code> expression instead of a <code>function</code> declaration, its name is in its own scope\u2014essentially the same scope as <code>cache</code>\u2014rather than in the outer/global scope.</p><p>That means we can name every single occurrence of such a function expression the exact same name, and never have any collision. More appropriately, we can name each occurrence semantically based on whatever it is we're trying to hide, and not worry that whatever name we choose is going to collide with any other <code>function</code> expression scope in the program.</p><p>In fact, we <em>could</em> just leave off the name entirely\u2014thus defining an \"anonymous <code>function</code> expression\" instead. But Appendix A will discuss the importance of names even for such scope-only functions.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Hiding in Plain (Function) Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It should now be clear why it's important to hide our variable and function declarations in the lowest (most deeply nested) scopes possible. But how do we do so?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We've already seen the ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " keywords, which are block scoped declarators; we'll come back to them in more detail shortly. But first, what about hiding ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations in scopes? That can easily be done by wrapping a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " scope around a declaration.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's consider an example where ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " scoping can be useful.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The mathematical operation \"factorial\" (notated as \"6!\") is the multiplication of a given integer against all successively lower integers down to ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": "\u2014actually, you can stop at ", "type": "text"}, {"text": "2", "type": "text", "marks": [{"type": "code"}]}, {"text": " since multiplying ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": " does nothing. In other words, \"6!\" is the same as \"6 ", "type": "text"}, {"text": " 5!\", which is the same as \"6 ", "type": "text", "marks": [{"type": "italic"}]}, {"text": " 5 * 4!\", and so on. Because of the nature of the math involved, once any given integer's factorial (like \"4!\") has been calculated, we shouldn't need to do that work again, as it'll always be the same answer.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So if you naively calculate factorial for ", "type": "text"}, {"text": "6", "type": "text", "marks": [{"type": "code"}]}, {"text": ", then later want to calculate factorial for ", "type": "text"}, {"text": "7", "type": "text", "marks": [{"type": "code"}]}, {"text": ", you might unnecessarily re-calculate the factorials of all the integers from 2 up to 6. If you're willing to trade memory for speed, you can solve that wasted computation by caching each integer's factorial as it's calculated:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var cache = {};\n\nfunction factorial(x) {\n    if (x < 2) return 1;\n    if (!(x in cache)) {\n        cache[x] = x * factorial(x - 1);\n    }\n    return cache[x];\n}\n\nfactorial(6);\n// 720\n\ncache;\n// {\n//     \"2\": 2,\n//     \"3\": 6,\n//     \"4\": 24,\n//     \"5\": 120,\n//     \"6\": 720\n// }\n\nfactorial(7);\n// 5040", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We're storing all the computed factorials in ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " so that across multiple calls to ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the previous computations remain. But the ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable is pretty obviously a ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " detail of how ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " works, not something that should be exposed in an outer scope\u2014especially not the global scope.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " here is recursive\u2014a call to itself is made from inside\u2014but that's just for brevity of code sake; a non-recursive implementation would yield the same scoping analysis with respect to ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "However, fixing this over-exposure issue is not as simple as hiding the ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable inside ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", as it might seem. Since we need ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " to survive multiple calls, it must be located in a scope outside that function. So what can we do?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Define another middle scope (between the outer/global scope and the inside of ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ") for ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " to be located:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer/global scope\n\nfunction hideTheCache() {\n    // \"middle scope\", where we hide `cache`\n    var cache = {};\n\n    return factorial;\n\n    // **********************\n\n    function factorial(x) {\n        // inner scope\n        if (x < 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n}\n\nvar factorial = hideTheCache();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "hideTheCache()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function serves no other purpose than to create a scope for ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " to persist in across multiple calls to ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But for ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " to have access to ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we have to define ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside that same scope. Then we return the function reference, as a value from ", "type": "text"}, {"text": "hideTheCache()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and store it in an outer scope variable, also named ", "type": "text"}, {"text": "factorial", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Now as we call ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (multiple times!), its persistent ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " stays hidden yet accessible only to ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "OK, but... it's going to be tedious to define (and name!) a ", "type": "text"}, {"text": "hideTheCache(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function scope each time such a need for variable/function hiding occurs, especially since we'll likely want to avoid name collisions with this function by giving each occurrence a unique name. Ugh.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The illustrated technique\u2014caching a function's computed output to optimize performance when repeated calls of the same inputs are expected\u2014is quite common in the Functional Programming (FP) world, canonically referred to as \"memoization\"; this caching relies on closure (see Chapter 7). Also, there are memory usage concerns (addressed in \"A Word About Memory\" in Appendix B). FP libraries will usually provide an optimized and vetted utility for memoization of functions, which would take the place of ", "type": "text"}, {"text": "hideTheCache(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " here. Memoization is beyond the ", "type": "text"}, {"text": "scope", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (pun intended!) of our discussion, but see my ", "type": "text"}, {"text": "Functional-Light JavaScript", "type": "text", "marks": [{"type": "italic"}]}, {"text": " book for more information.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Rather than defining a new and uniquely named function each time one of those scope-only-for-the-purpose-of-hiding-a-variable situations occurs, a perhaps better solution is to use a function expression:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var factorial = (function hideTheCache() {\n    var cache = {};\n\n    function factorial(x) {\n        if (x < 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n\n    return factorial;\n})();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Wait! This is still using a function to create the scope for hiding ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and in this case, the function is still named ", "type": "text"}, {"text": "hideTheCache", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so how does that solve anything?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall from \"Function Name Scope\" (in Chapter 3), what happens to the name identifier from a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression. Since ", "type": "text"}, {"text": "hideTheCache(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is defined as a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression instead of a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration, its name is in its own scope\u2014essentially the same scope as ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": "\u2014rather than in the outer/global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That means we can name every single occurrence of such a function expression the exact same name, and never have any collision. More appropriately, we can name each occurrence semantically based on whatever it is we're trying to hide, and not worry that whatever name we choose is going to collide with any other ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression scope in the program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In fact, we ", "type": "text"}, {"text": "could", "type": "text", "marks": [{"type": "italic"}]}, {"text": " just leave off the name entirely\u2014thus defining an \"anonymous ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression\" instead. But Appendix A will discuss the importance of names even for such scope-only functions.", "type": "text"}]}]}, "article_text": "Hiding in Plain (Function) Scope\n\nIt should now be clear why it's important to hide our variable and function declarations in the lowest (most deeply nested) scopes possible. But how do we do so?\n\nWe've already seen the let and const keywords, which are block scoped declarators; we'll come back to them in more detail shortly. But first, what about hiding var or function declarations in scopes? That can easily be done by wrapping a function scope around a declaration.\n\nLet's consider an example where function scoping can be useful.\n\nThe mathematical operation \"factorial\" (notated as \"6!\") is the multiplication of a given integer against all successively lower integers down to 1\u2014actually, you can stop at 2 since multiplying 1 does nothing. In other words, \"6!\" is the same as \"6  5!\", which is the same as \"6  5 * 4!\", and so on. Because of the nature of the math involved, once any given integer's factorial (like \"4!\") has been calculated, we shouldn't need to do that work again, as it'll always be the same answer.\n\nSo if you naively calculate factorial for 6, then later want to calculate factorial for 7, you might unnecessarily re-calculate the factorials of all the integers from 2 up to 6. If you're willing to trade memory for speed, you can solve that wasted computation by caching each integer's factorial as it's calculated:\n\nvar cache = {};\n\nfunction factorial(x) {\n    if (x < 2) return 1;\n    if (!(x in cache)) {\n        cache[x] = x * factorial(x - 1);\n    }\n    return cache[x];\n}\n\nfactorial(6);\n// 720\n\ncache;\n// {\n//     \"2\": 2,\n//     \"3\": 6,\n//     \"4\": 24,\n//     \"5\": 120,\n//     \"6\": 720\n// }\n\nfactorial(7);\n// 5040\n\nWe're storing all the computed factorials in cache so that across multiple calls to factorial(..), the previous computations remain. But the cache variable is pretty obviously a private detail of how factorial(..) works, not something that should be exposed in an outer scope\u2014especially not the global scope.\n\nNOTE:\n\nfactorial(..) here is recursive\u2014a call to itself is made from inside\u2014but that's just for brevity of code sake; a non-recursive implementation would yield the same scoping analysis with respect to cache.\n\nHowever, fixing this over-exposure issue is not as simple as hiding the cache variable inside factorial(..), as it might seem. Since we need cache to survive multiple calls, it must be located in a scope outside that function. So what can we do?\n\nDefine another middle scope (between the outer/global scope and the inside of factorial(..)) for cache to be located:\n\n// outer/global scope\n\nfunction hideTheCache() {\n    // \"middle scope\", where we hide `cache`\n    var cache = {};\n\n    return factorial;\n\n    // **********************\n\n    function factorial(x) {\n        // inner scope\n        if (x < 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n}\n\nvar factorial = hideTheCache();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040\n\nThe hideTheCache() function serves no other purpose than to create a scope for cache to persist in across multiple calls to factorial(..). But for factorial(..) to have access to cache, we have to define factorial(..) inside that same scope. Then we return the function reference, as a value from hideTheCache(), and store it in an outer scope variable, also named factorial. Now as we call factorial(..) (multiple times!), its persistent cache stays hidden yet accessible only to factorial(..)!\n\nOK, but... it's going to be tedious to define (and name!) a hideTheCache(..) function scope each time such a need for variable/function hiding occurs, especially since we'll likely want to avoid name collisions with this function by giving each occurrence a unique name. Ugh.\n\nNOTE:\n\nThe illustrated technique\u2014caching a function's computed output to optimize performance when repeated calls of the same inputs are expected\u2014is quite common in the Functional Programming (FP) world, canonically referred to as \"memoization\"; this caching relies on closure (see Chapter 7). Also, there are memory usage concerns (addressed in \"A Word About Memory\" in Appendix B). FP libraries will usually provide an optimized and vetted utility for memoization of functions, which would take the place of hideTheCache(..) here. Memoization is beyond the scope (pun intended!) of our discussion, but see my Functional-Light JavaScript book for more information.\n\nRather than defining a new and uniquely named function each time one of those scope-only-for-the-purpose-of-hiding-a-variable situations occurs, a perhaps better solution is to use a function expression:\n\nvar factorial = (function hideTheCache() {\n    var cache = {};\n\n    function factorial(x) {\n        if (x < 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n\n    return factorial;\n})();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040\n\nWait! This is still using a function to create the scope for hiding cache, and in this case, the function is still named hideTheCache, so how does that solve anything?\n\nRecall from \"Function Name Scope\" (in Chapter 3), what happens to the name identifier from a function expression. Since hideTheCache(..) is defined as a function expression instead of a function declaration, its name is in its own scope\u2014essentially the same scope as cache\u2014rather than in the outer/global scope.\n\nThat means we can name every single occurrence of such a function expression the exact same name, and never have any collision. More appropriately, we can name each occurrence semantically based on whatever it is we're trying to hide, and not worry that whatever name we choose is going to collide with any other function expression scope in the program.\n\nIn fact, we could just leave off the name entirely\u2014thus defining an \"anonymous function expression\" instead. But Appendix A will discuss the importance of names even for such scope-only functions."}, "id": 213, "children": [{"data": {"uuid": "14057f65-a265-405e-b29a-c12ae4d37075", "user": 1, "title": "Invoking Function Expressions Immediately", "author": "Kyle Simpson", "created_on": "2023-06-09 01:27:53.670006+00:00", "updated_on": "2023-06-09 01:28:20.366289+00:00", "article_html": "<h3>Invoking Function Expressions Immediately</h3><p>There's another important bit in the previous factorial recursive program that's easy to miss: the line at the end of the <code>function</code> expression that contains <code>})();</code>.</p><p>Notice that we surrounded the entire <code>function</code> expression in a set of <code>( .. )</code>, and then on the end, we added that second <code>()</code> parentheses set; that's actually calling the <code>function</code> expression we just defined. Moreover, in this case, the first set of surrounding <code>( .. )</code> around the function expression is not strictly necessary (more on that in a moment), but we used them for readability sake anyway.</p><p>So, in other words, we're defining a <code>function</code> expression that's then immediately invoked. This common pattern has a (very creative!) name: Immediately Invoked Function Expression (IIFE).</p><p>An IIFE is useful when we want to create a scope to hide variables/functions. Since it's an expression, it can be used in <strong>any</strong> place in a JS program where an expression is allowed. An IIFE can be named, as with <code>hideTheCache()</code>, or (much more commonly!) unnamed/anonymous. And it can be standalone or, as before, part of another statement\u2014<code>hideTheCache()</code> returns the <code>factorial()</code> function reference which is then <code>=</code> assigned to the variable <code>factorial</code>.</p><p>For comparison, here's an example of a standalone IIFE:</p><pre><code>// outer scope\n\n(function(){\n    // inner hidden scope\n})();\n\n// more outer scope</code></pre><p>Unlike earlier with <code>hideTheCache()</code>, where the outer surrounding <code>(..)</code> were noted as being an optional stylistic choice, for a standalone IIFE they're <strong>required</strong>; they distinguish the <code>function</code> as an expression, not a statement. For consistency, however, always surround an IIFE <code>function</code> with <code>( .. )</code>.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Technically, the surrounding <code>( .. )</code> aren't the only syntactic way to ensure the <code>function</code> in an IIFE is treated by the JS parser as a function expression. We'll look at some other options in Appendix A.</p></td></tr></tbody></table><h4>Function Boundaries</h4><p>Beware that using an IIFE to define a scope can have some unintended consequences, depending on the code around it. Because an IIFE is a full function, the function boundary alters the behavior of certain statements/constructs.</p><p>For example, a <code>return</code> statement in some piece of code would change its meaning if an IIFE is wrapped around it, because now the <code>return</code> would refer to the IIFE's function. Non-arrow function IIFEs also change the binding of a <code>this</code> keyword\u2014more on that in the <em>Objects &amp; Classes</em> book. And statements like <code>break</code> and <code>continue</code> won't operate across an IIFE function boundary to control an outer loop or block.</p><p>So, if the code you need to wrap a scope around has <code>return</code>, <code>this</code>, <code>break</code>, or <code>continue</code> in it, an IIFE is probably not the best approach. In that case, you might look to create the scope with a block instead of a function.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Invoking Function Expressions Immediately", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's another important bit in the previous factorial recursive program that's easy to miss: the line at the end of the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression that contains ", "type": "text"}, {"text": "})();", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice that we surrounded the entire ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression in a set of ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and then on the end, we added that second ", "type": "text"}, {"text": "()", "type": "text", "marks": [{"type": "code"}]}, {"text": " parentheses set; that's actually calling the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression we just defined. Moreover, in this case, the first set of surrounding ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": " around the function expression is not strictly necessary (more on that in a moment), but we used them for readability sake anyway.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So, in other words, we're defining a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression that's then immediately invoked. This common pattern has a (very creative!) name: Immediately Invoked Function Expression (IIFE).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An IIFE is useful when we want to create a scope to hide variables/functions. Since it's an expression, it can be used in ", "type": "text"}, {"text": "any", "type": "text", "marks": [{"type": "bold"}]}, {"text": " place in a JS program where an expression is allowed. An IIFE can be named, as with ", "type": "text"}, {"text": "hideTheCache()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", or (much more commonly!) unnamed/anonymous. And it can be standalone or, as before, part of another statement\u2014", "type": "text"}, {"text": "hideTheCache()", "type": "text", "marks": [{"type": "code"}]}, {"text": " returns the ", "type": "text"}, {"text": "factorial()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function reference which is then ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": " assigned to the variable ", "type": "text"}, {"text": "factorial", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For comparison, here's an example of a standalone IIFE:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer scope\n\n(function(){\n    // inner hidden scope\n})();\n\n// more outer scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Unlike earlier with ", "type": "text"}, {"text": "hideTheCache()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", where the outer surrounding ", "type": "text"}, {"text": "(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " were noted as being an optional stylistic choice, for a standalone IIFE they're ", "type": "text"}, {"text": "required", "type": "text", "marks": [{"type": "bold"}]}, {"text": "; they distinguish the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " as an expression, not a statement. For consistency, however, always surround an IIFE ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " with ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Technically, the surrounding ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": " aren't the only syntactic way to ensure the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " in an IIFE is treated by the JS parser as a function expression. We'll look at some other options in Appendix A.", "type": "text"}]}]}]}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Function Boundaries", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Beware that using an IIFE to define a scope can have some unintended consequences, depending on the code around it. Because an IIFE is a full function, the function boundary alters the behavior of certain statements/constructs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, a ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement in some piece of code would change its meaning if an IIFE is wrapped around it, because now the ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " would refer to the IIFE's function. Non-arrow function IIFEs also change the binding of a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword\u2014more on that in the ", "type": "text"}, {"text": "Objects & Classes", "type": "text", "marks": [{"type": "italic"}]}, {"text": " book. And statements like ", "type": "text"}, {"text": "break", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "continue", "type": "text", "marks": [{"type": "code"}]}, {"text": " won't operate across an IIFE function boundary to control an outer loop or block.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So, if the code you need to wrap a scope around has ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "break", "type": "text", "marks": [{"type": "code"}]}, {"text": ", or ", "type": "text"}, {"text": "continue", "type": "text", "marks": [{"type": "code"}]}, {"text": " in it, an IIFE is probably not the best approach. In that case, you might look to create the scope with a block instead of a function.", "type": "text"}]}]}, "article_text": "Invoking Function Expressions Immediately\n\nThere's another important bit in the previous factorial recursive program that's easy to miss: the line at the end of the function expression that contains })();.\n\nNotice that we surrounded the entire function expression in a set of ( .. ), and then on the end, we added that second () parentheses set; that's actually calling the function expression we just defined. Moreover, in this case, the first set of surrounding ( .. ) around the function expression is not strictly necessary (more on that in a moment), but we used them for readability sake anyway.\n\nSo, in other words, we're defining a function expression that's then immediately invoked. This common pattern has a (very creative!) name: Immediately Invoked Function Expression (IIFE).\n\nAn IIFE is useful when we want to create a scope to hide variables/functions. Since it's an expression, it can be used in any place in a JS program where an expression is allowed. An IIFE can be named, as with hideTheCache(), or (much more commonly!) unnamed/anonymous. And it can be standalone or, as before, part of another statement\u2014hideTheCache() returns the factorial() function reference which is then = assigned to the variable factorial.\n\nFor comparison, here's an example of a standalone IIFE:\n\n// outer scope\n\n(function(){\n    // inner hidden scope\n})();\n\n// more outer scope\n\nUnlike earlier with hideTheCache(), where the outer surrounding (..) were noted as being an optional stylistic choice, for a standalone IIFE they're required; they distinguish the function as an expression, not a statement. For consistency, however, always surround an IIFE function with ( .. ).\n\nNOTE:\n\nTechnically, the surrounding ( .. ) aren't the only syntactic way to ensure the function in an IIFE is treated by the JS parser as a function expression. We'll look at some other options in Appendix A.\n\nFunction Boundaries\n\nBeware that using an IIFE to define a scope can have some unintended consequences, depending on the code around it. Because an IIFE is a full function, the function boundary alters the behavior of certain statements/constructs.\n\nFor example, a return statement in some piece of code would change its meaning if an IIFE is wrapped around it, because now the return would refer to the IIFE's function. Non-arrow function IIFEs also change the binding of a this keyword\u2014more on that in the Objects & Classes book. And statements like break and continue won't operate across an IIFE function boundary to control an outer loop or block.\n\nSo, if the code you need to wrap a scope around has return, this, break, or continue in it, an IIFE is probably not the best approach. In that case, you might look to create the scope with a block instead of a function."}, "id": 214}]}, {"data": {"uuid": "779f2d50-151a-42d2-bb8b-2dd2131fcf58", "user": 1, "title": "Scoping with Blocks", "author": "Kyle Simpson", "created_on": "2023-06-09 01:28:40.714681+00:00", "updated_on": "2023-06-09 01:29:06.190260+00:00", "article_html": "<h2>Scoping with Blocks</h2><p>You should by this point feel fairly comfortable with the merits of creating scopes to limit identifier exposure.</p><p>So far, we looked at doing this via <code>function</code> (i.e., IIFE) scope. But let's now consider using <code>let</code> declarations with nested blocks. In general, any <code>{ .. }</code> curly-brace pair which is a statement will act as a block, but <strong>not necessarily</strong> as a scope.</p><p>A block only becomes a scope if necessary, to contain its block-scoped declarations (i.e., <code>let</code> or <code>const</code>). Consider:</p><pre><code>{\n    // not necessarily a scope (yet)\n\n    // ..\n\n    // now we know the block needs to be a scope\n    let thisIsNowAScope = true;\n\n    for (let i = 0; i &lt; 5; i++) {\n        // this is also a scope, activated each\n        // iteration\n        if (i % 2 == 0) {\n            // this is just a block, not a scope\n            console.log(i);\n        }\n    }\n}\n// 0 2 4</code></pre><p>Not all <code>{ .. }</code> curly-brace pairs create blocks (and thus are eligible to become scopes):</p><ul><li><p>Object literals use <code>{ .. }</code> curly-brace pairs to delimit their key-value lists, but such object values are <strong>not</strong> scopes.</p></li><li><p><code>class</code> uses <code>{ .. }</code> curly-braces around its body definition, but this is not a block or scope.</p></li><li><p>A <code>function</code> uses <code>{ .. } </code>around its body, but this is not technically a block\u2014it's a single statement for the function body. It <em>is</em>, however, a (function) scope.</p></li><li><p>The <code>{ .. }</code> curly-brace pair on a <code>switch</code> statement (around the set of <code>case</code> clauses) does not define a block/scope.</p></li></ul><p>Other than such non-block examples, a <code>{ .. }</code> curly-brace pair can define a block attached to a statement (like an <code>if</code> or <code>for</code>), or stand alone by itself\u2014see the outermost <code>{ .. }</code> curly brace pair in the previous snippet. An explicit block of this sort\u2014if it has no declarations, it's not actually a scope\u2014serves no operational purpose, though it can still be useful as a semantic signal.</p><p>Explicit standalone <code>{ .. }</code> blocks have always been valid JS syntax, but since they couldn't be a scope prior to ES6's <code>let</code>/<code>const</code>, they are quite rare. However, post ES6, they're starting to catch on a little bit.</p><p>In most languages that support block scoping, an explicit block scope is an extremely common pattern for creating a narrow slice of scope for one or a few variables. So following the POLE principle, we should embrace this pattern more widespread in JS as well; use (explicit) block scoping to narrow the exposure of identifiers to the minimum practical.</p><p>An explicit block scope can be useful even inside of another block (whether the outer block is a scope or not).</p><p>For example:</p><pre><code>if (somethingHappened) {\n    // this is a block, but not a scope\n\n    {\n        // this is both a block and an\n        // explicit scope\n        let msg = somethingHappened.message();\n        notifyOthers(msg);\n    }\n\n    // ..\n\n    recoverFromSomething();\n}</code></pre><p>Here, the <code>{ .. }</code> curly-brace pair <strong>inside</strong> the <code>if</code> statement is an even smaller inner explicit block scope for <code>msg</code>, since that variable is not needed for the entire <code>if</code> block. Most developers would just block-scope <code>msg</code> to the <code>if</code> block and move on. And to be fair, when there's only a few lines to consider, it's a toss-up judgement call. But as code grows, these over-exposure issues become more pronounced.</p><p>So does it matter enough to add the extra <code>{ .. }</code> pair and indentation level? I think you should follow POLE and always (within reason!) define the smallest block for each variable. So I recommend using the extra explicit block scope as shown.</p><p>Recall the discussion of TDZ errors from \"Uninitialized Variables (TDZ)\" (Chapter 5). My suggestion there was: to minimize the risk of TDZ errors with <code>let</code>/<code>const</code> declarations, always put those declarations at the top of their scope.</p><p>If you find yourself placing a <code>let</code> declaration in the middle of a scope, first think, \"Oh, no! TDZ alert!\" If this <code>let</code> declaration isn't needed in the first half of that block, you should use an inner explicit block scope to further narrow its exposure!</p><p>Another example with an explicit block scope:</p><pre><code>function getNextMonthStart(dateStr) {\n    var nextMonth, year;\n\n    {\n        let curMonth;\n        [ , year, curMonth ] = dateStr.match(\n                /(\\d{4})-(\\d{2})-\\d{2}/\n            ) || [];\n        nextMonth = (Number(curMonth) % 12) + 1;\n    }\n\n    if (nextMonth == 1) {\n        year++;\n    }\n\n    return `${ year }-${\n            String(nextMonth).padStart(2,\"0\")\n        }-01`;\n}\ngetNextMonthStart(\"2019-12-25\");   // 2020-01-01</code></pre><p>Let's first identify the scopes and their identifiers:</p><ol><li><p>The outer/global scope has one identifier, the function <code>getNextMonthStart(..)</code>.</p></li><li><p>The function scope for <code>getNextMonthStart(..)</code> has three: <code>dateStr</code> (parameter), <code>nextMonth</code>, and <code>year</code>.</p></li><li><p>The <code>{ .. }</code> curly-brace pair defines an inner block scope that includes one variable: <code>curMonth</code>.</p></li></ol><p>So why put <code>curMonth</code> in an explicit block scope instead of just alongside <code>nextMonth</code> and <code>year</code> in the top-level function scope? Because <code>curMonth</code> is only needed for those first two statements; at the function scope level it's over-exposed.</p><p>This example is small, so the hazards of over-exposing <code>curMonth</code> are pretty limited. But the benefits of the POLE principle are best achieved when you adopt the mindset of minimizing scope exposure by default, as a habit. If you follow the principle consistently even in the small cases, it will serve you more as your programs grow.</p><p>Let's now look at an even more substantial example:</p><pre><code>function sortNamesByLength(names) {\n    var buckets = [];\n\n    for (let firstName of names) {\n        if (buckets[firstName.length] == null) {\n            buckets[firstName.length] = [];\n        }\n        buckets[firstName.length].push(firstName);\n    }\n\n    // a block to narrow the scope\n    {\n        let sortedNames = [];\n\n        for (let bucket of buckets) {\n            if (bucket) {\n                // sort each bucket alphanumerically\n                bucket.sort();\n\n                // append the sorted names to our\n                // running list\n                sortedNames = [\n                    ...sortedNames,\n                    ...bucket\n                ];\n            }\n        }\n\n        return sortedNames;\n    }\n}\n\nsortNamesByLength([\n    \"Sally\",\n    \"Suzy\",\n    \"Frank\",\n    \"John\",\n    \"Jennifer\",\n    \"Scott\"\n]);\n// [ \"John\", \"Suzy\", \"Frank\", \"Sally\",\n//   \"Scott\", \"Jennifer\" ]</code></pre><p>There are six identifiers declared across five different scopes. Could all of these variables have existed in the single outer/global scope? Technically, yes, since they're all uniquely named and thus have no name collisions. But this would be really poor code organization, and would likely lead to both confusion and future bugs.</p><p>We split them out into each inner nested scope as appropriate. Each variable is defined at the innermost scope possible for the program to operate as desired.</p><p><code>sortedNames</code> could have been defined in the top-level function scope, but it's only needed for the second half of this function. To avoid over-exposing that variable in a higher level scope, we again follow POLE and block-scope it in the inner explicit block scope.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Scoping with Blocks", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You should by this point feel fairly comfortable with the merits of creating scopes to limit identifier exposure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So far, we looked at doing this via ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " (i.e., IIFE) scope. But let's now consider using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations with nested blocks. In general, any ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pair which is a statement will act as a block, but ", "type": "text"}, {"text": "not necessarily", "type": "text", "marks": [{"type": "bold"}]}, {"text": " as a scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A block only becomes a scope if necessary, to contain its block-scoped declarations (i.e., ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "). Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "{\n    // not necessarily a scope (yet)\n\n    // ..\n\n    // now we know the block needs to be a scope\n    let thisIsNowAScope = true;\n\n    for (let i = 0; i < 5; i++) {\n        // this is also a scope, activated each\n        // iteration\n        if (i % 2 == 0) {\n            // this is just a block, not a scope\n            console.log(i);\n        }\n    }\n}\n// 0 2 4", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Not all ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pairs create blocks (and thus are eligible to become scopes):", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Object literals use ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pairs to delimit their key-value lists, but such object values are ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " scopes.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " uses ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-braces around its body definition, but this is not a block or scope.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "A ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " uses ", "type": "text"}, {"text": "{ .. } ", "type": "text", "marks": [{"type": "code"}]}, {"text": "around its body, but this is not technically a block\u2014it's a single statement for the function body. It ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", however, a (function) scope.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pair on a ", "type": "text"}, {"text": "switch", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement (around the set of ", "type": "text"}, {"text": "case", "type": "text", "marks": [{"type": "code"}]}, {"text": " clauses) does not define a block/scope.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Other than such non-block examples, a ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pair can define a block attached to a statement (like an ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "), or stand alone by itself\u2014see the outermost ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly brace pair in the previous snippet. An explicit block of this sort\u2014if it has no declarations, it's not actually a scope\u2014serves no operational purpose, though it can still be useful as a semantic signal.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Explicit standalone ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " blocks have always been valid JS syntax, but since they couldn't be a scope prior to ES6's ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", they are quite rare. However, post ES6, they're starting to catch on a little bit.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In most languages that support block scoping, an explicit block scope is an extremely common pattern for creating a narrow slice of scope for one or a few variables. So following the POLE principle, we should embrace this pattern more widespread in JS as well; use (explicit) block scoping to narrow the exposure of identifiers to the minimum practical.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An explicit block scope can be useful even inside of another block (whether the outer block is a scope or not).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "if (somethingHappened) {\n    // this is a block, but not a scope\n\n    {\n        // this is both a block and an\n        // explicit scope\n        let msg = somethingHappened.message();\n        notifyOthers(msg);\n    }\n\n    // ..\n\n    recoverFromSomething();\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, the ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pair ", "type": "text"}, {"text": "inside", "type": "text", "marks": [{"type": "bold"}]}, {"text": " the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement is an even smaller inner explicit block scope for ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": ", since that variable is not needed for the entire ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " block. Most developers would just block-scope ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": " to the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " block and move on. And to be fair, when there's only a few lines to consider, it's a toss-up judgement call. But as code grows, these over-exposure issues become more pronounced.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So does it matter enough to add the extra ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " pair and indentation level? I think you should follow POLE and always (within reason!) define the smallest block for each variable. So I recommend using the extra explicit block scope as shown.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall the discussion of TDZ errors from \"Uninitialized Variables (TDZ)\" (Chapter 5). My suggestion there was: to minimize the risk of TDZ errors with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations, always put those declarations at the top of their scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you find yourself placing a ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration in the middle of a scope, first think, \"Oh, no! TDZ alert!\" If this ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration isn't needed in the first half of that block, you should use an inner explicit block scope to further narrow its exposure!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another example with an explicit block scope:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getNextMonthStart(dateStr) {\n    var nextMonth, year;\n\n    {\n        let curMonth;\n        [ , year, curMonth ] = dateStr.match(\n                /(\\d{4})-(\\d{2})-\\d{2}/\n            ) || [];\n        nextMonth = (Number(curMonth) % 12) + 1;\n    }\n\n    if (nextMonth == 1) {\n        year++;\n    }\n\n    return `${ year }-${\n            String(nextMonth).padStart(2,\"0\")\n        }-01`;\n}\ngetNextMonthStart(\"2019-12-25\");   // 2020-01-01", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's first identify the scopes and their identifiers:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The outer/global scope has one identifier, the function ", "type": "text"}, {"text": "getNextMonthStart(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The function scope for ", "type": "text"}, {"text": "getNextMonthStart(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " has three: ", "type": "text"}, {"text": "dateStr", "type": "text", "marks": [{"type": "code"}]}, {"text": " (parameter), ", "type": "text"}, {"text": "nextMonth", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "year", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " curly-brace pair defines an inner block scope that includes one variable: ", "type": "text"}, {"text": "curMonth", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "So why put ", "type": "text"}, {"text": "curMonth", "type": "text", "marks": [{"type": "code"}]}, {"text": " in an explicit block scope instead of just alongside ", "type": "text"}, {"text": "nextMonth", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "year", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the top-level function scope? Because ", "type": "text"}, {"text": "curMonth", "type": "text", "marks": [{"type": "code"}]}, {"text": " is only needed for those first two statements; at the function scope level it's over-exposed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This example is small, so the hazards of over-exposing ", "type": "text"}, {"text": "curMonth", "type": "text", "marks": [{"type": "code"}]}, {"text": " are pretty limited. But the benefits of the POLE principle are best achieved when you adopt the mindset of minimizing scope exposure by default, as a habit. If you follow the principle consistently even in the small cases, it will serve you more as your programs grow.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's now look at an even more substantial example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function sortNamesByLength(names) {\n    var buckets = [];\n\n    for (let firstName of names) {\n        if (buckets[firstName.length] == null) {\n            buckets[firstName.length] = [];\n        }\n        buckets[firstName.length].push(firstName);\n    }\n\n    // a block to narrow the scope\n    {\n        let sortedNames = [];\n\n        for (let bucket of buckets) {\n            if (bucket) {\n                // sort each bucket alphanumerically\n                bucket.sort();\n\n                // append the sorted names to our\n                // running list\n                sortedNames = [\n                    ...sortedNames,\n                    ...bucket\n                ];\n            }\n        }\n\n        return sortedNames;\n    }\n}\n\nsortNamesByLength([\n    \"Sally\",\n    \"Suzy\",\n    \"Frank\",\n    \"John\",\n    \"Jennifer\",\n    \"Scott\"\n]);\n// [ \"John\", \"Suzy\", \"Frank\", \"Sally\",\n//   \"Scott\", \"Jennifer\" ]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are six identifiers declared across five different scopes. Could all of these variables have existed in the single outer/global scope? Technically, yes, since they're all uniquely named and thus have no name collisions. But this would be really poor code organization, and would likely lead to both confusion and future bugs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We split them out into each inner nested scope as appropriate. Each variable is defined at the innermost scope possible for the program to operate as desired.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "sortedNames", "type": "text", "marks": [{"type": "code"}]}, {"text": " could have been defined in the top-level function scope, but it's only needed for the second half of this function. To avoid over-exposing that variable in a higher level scope, we again follow POLE and block-scope it in the inner explicit block scope.", "type": "text"}]}]}, "article_text": "Scoping with Blocks\n\nYou should by this point feel fairly comfortable with the merits of creating scopes to limit identifier exposure.\n\nSo far, we looked at doing this via function (i.e., IIFE) scope. But let's now consider using let declarations with nested blocks. In general, any { .. } curly-brace pair which is a statement will act as a block, but not necessarily as a scope.\n\nA block only becomes a scope if necessary, to contain its block-scoped declarations (i.e., let or const). Consider:\n\n{\n    // not necessarily a scope (yet)\n\n    // ..\n\n    // now we know the block needs to be a scope\n    let thisIsNowAScope = true;\n\n    for (let i = 0; i < 5; i++) {\n        // this is also a scope, activated each\n        // iteration\n        if (i % 2 == 0) {\n            // this is just a block, not a scope\n            console.log(i);\n        }\n    }\n}\n// 0 2 4\n\nNot all { .. } curly-brace pairs create blocks (and thus are eligible to become scopes):\n\nObject literals use { .. } curly-brace pairs to delimit their key-value lists, but such object values are not scopes.\n\nclass uses { .. } curly-braces around its body definition, but this is not a block or scope.\n\nA function uses { .. } around its body, but this is not technically a block\u2014it's a single statement for the function body. It is, however, a (function) scope.\n\nThe { .. } curly-brace pair on a switch statement (around the set of case clauses) does not define a block/scope.\n\nOther than such non-block examples, a { .. } curly-brace pair can define a block attached to a statement (like an if or for), or stand alone by itself\u2014see the outermost { .. } curly brace pair in the previous snippet. An explicit block of this sort\u2014if it has no declarations, it's not actually a scope\u2014serves no operational purpose, though it can still be useful as a semantic signal.\n\nExplicit standalone { .. } blocks have always been valid JS syntax, but since they couldn't be a scope prior to ES6's let/const, they are quite rare. However, post ES6, they're starting to catch on a little bit.\n\nIn most languages that support block scoping, an explicit block scope is an extremely common pattern for creating a narrow slice of scope for one or a few variables. So following the POLE principle, we should embrace this pattern more widespread in JS as well; use (explicit) block scoping to narrow the exposure of identifiers to the minimum practical.\n\nAn explicit block scope can be useful even inside of another block (whether the outer block is a scope or not).\n\nFor example:\n\nif (somethingHappened) {\n    // this is a block, but not a scope\n\n    {\n        // this is both a block and an\n        // explicit scope\n        let msg = somethingHappened.message();\n        notifyOthers(msg);\n    }\n\n    // ..\n\n    recoverFromSomething();\n}\n\nHere, the { .. } curly-brace pair inside the if statement is an even smaller inner explicit block scope for msg, since that variable is not needed for the entire if block. Most developers would just block-scope msg to the if block and move on. And to be fair, when there's only a few lines to consider, it's a toss-up judgement call. But as code grows, these over-exposure issues become more pronounced.\n\nSo does it matter enough to add the extra { .. } pair and indentation level? I think you should follow POLE and always (within reason!) define the smallest block for each variable. So I recommend using the extra explicit block scope as shown.\n\nRecall the discussion of TDZ errors from \"Uninitialized Variables (TDZ)\" (Chapter 5). My suggestion there was: to minimize the risk of TDZ errors with let/const declarations, always put those declarations at the top of their scope.\n\nIf you find yourself placing a let declaration in the middle of a scope, first think, \"Oh, no! TDZ alert!\" If this let declaration isn't needed in the first half of that block, you should use an inner explicit block scope to further narrow its exposure!\n\nAnother example with an explicit block scope:\n\nfunction getNextMonthStart(dateStr) {\n    var nextMonth, year;\n\n    {\n        let curMonth;\n        [ , year, curMonth ] = dateStr.match(\n                /(\\d{4})-(\\d{2})-\\d{2}/\n            ) || [];\n        nextMonth = (Number(curMonth) % 12) + 1;\n    }\n\n    if (nextMonth == 1) {\n        year++;\n    }\n\n    return `${ year }-${\n            String(nextMonth).padStart(2,\"0\")\n        }-01`;\n}\ngetNextMonthStart(\"2019-12-25\");   // 2020-01-01\n\nLet's first identify the scopes and their identifiers:\n\nThe outer/global scope has one identifier, the function getNextMonthStart(..).\n\nThe function scope for getNextMonthStart(..) has three: dateStr (parameter), nextMonth, and year.\n\nThe { .. } curly-brace pair defines an inner block scope that includes one variable: curMonth.\n\nSo why put curMonth in an explicit block scope instead of just alongside nextMonth and year in the top-level function scope? Because curMonth is only needed for those first two statements; at the function scope level it's over-exposed.\n\nThis example is small, so the hazards of over-exposing curMonth are pretty limited. But the benefits of the POLE principle are best achieved when you adopt the mindset of minimizing scope exposure by default, as a habit. If you follow the principle consistently even in the small cases, it will serve you more as your programs grow.\n\nLet's now look at an even more substantial example:\n\nfunction sortNamesByLength(names) {\n    var buckets = [];\n\n    for (let firstName of names) {\n        if (buckets[firstName.length] == null) {\n            buckets[firstName.length] = [];\n        }\n        buckets[firstName.length].push(firstName);\n    }\n\n    // a block to narrow the scope\n    {\n        let sortedNames = [];\n\n        for (let bucket of buckets) {\n            if (bucket) {\n                // sort each bucket alphanumerically\n                bucket.sort();\n\n                // append the sorted names to our\n                // running list\n                sortedNames = [\n                    ...sortedNames,\n                    ...bucket\n                ];\n            }\n        }\n\n        return sortedNames;\n    }\n}\n\nsortNamesByLength([\n    \"Sally\",\n    \"Suzy\",\n    \"Frank\",\n    \"John\",\n    \"Jennifer\",\n    \"Scott\"\n]);\n// [ \"John\", \"Suzy\", \"Frank\", \"Sally\",\n//   \"Scott\", \"Jennifer\" ]\n\nThere are six identifiers declared across five different scopes. Could all of these variables have existed in the single outer/global scope? Technically, yes, since they're all uniquely named and thus have no name collisions. But this would be really poor code organization, and would likely lead to both confusion and future bugs.\n\nWe split them out into each inner nested scope as appropriate. Each variable is defined at the innermost scope possible for the program to operate as desired.\n\nsortedNames could have been defined in the top-level function scope, but it's only needed for the second half of this function. To avoid over-exposing that variable in a higher level scope, we again follow POLE and block-scope it in the inner explicit block scope."}, "id": 215, "children": [{"data": {"uuid": "b923e09f-04f4-4a18-ad8b-1d5f6aaadf8d", "user": 1, "title": "var and let", "author": "Kyle Simpson", "created_on": "2023-06-09 01:29:32.186159+00:00", "updated_on": "2023-06-09 01:29:57.715106+00:00", "article_html": "<h3><code>var</code> <em>and</em> <code>let</code></h3><p>Next, let's talk about the declaration <code>var buckets</code>. That variable is used across the entire function (except the final <code>return</code> statement). Any variable that is needed across all (or even most) of a function should be declared so that such usage is obvious.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The parameter <code>names</code> isn't used across the whole function, but there's no way limit the scope of a parameter, so it behaves as a function-wide declaration regardless.</p></td></tr></tbody></table><p>So why did we use <code>var</code> instead of <code>let</code> to declare the <code>buckets</code> variable? There's both semantic and technical reasons to choose <code>var</code> here.</p><p>Stylistically, <code>var</code> has always, from the earliest days of JS, signaled \"variable that belongs to a whole function.\" As we asserted in \"Lexical Scope\" (Chapter 1), <code>var</code> attaches to the nearest enclosing function scope, no matter where it appears. That's true even if <code>var</code> appears inside a block:</p><pre><code>function diff(x,y) {\n    if (x &gt; y) {\n        var tmp = x;    // `tmp` is function-scoped\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}</code></pre><p>Even though <code>var</code> is inside a block, its declaration is function-scoped (to <code>diff(..)</code>), not block-scoped.</p><p>While you can declare <code>var</code> inside a block (and still have it be function-scoped), I would recommend against this approach except in a few specific cases (discussed in Appendix A). Otherwise, <code>var</code> should be reserved for use in the top-level scope of a function.</p><p>Why not just use <code>let</code> in that same location? Because <code>var</code> is visually distinct from <code>let</code> and therefore signals clearly, \"this variable is function-scoped.\" Using <code>let</code> in the top-level scope, especially if not in the first few lines of a function, and when all the other declarations in blocks use <code>let</code>, does not visually draw attention to the difference with the function-scoped declaration.</p><p>In other words, I feel <code>var</code> better communicates function-scoped than <code>let</code> does, and <code>let</code> both communicates (and achieves!) block-scoping where <code>var</code> is insufficient. As long as your programs are going to need both function-scoped and block-scoped variables, the most sensible and readable approach is to use both <code>var</code> <em>and</em> <code>let</code> together, each for their own best purpose.</p><p>There are other semantic and operational reasons to choose <code>var</code> or <code>let</code> in different scenarios. We'll explore the case for <code>var</code> <em>and</em> <code>let</code> in more detail in Appendix A.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>My recommendation to use both <code>var</code> <em>and</em> <code>let</code> is clearly controversial and contradicts the majority. It's far more common to hear assertions like, \"var is broken, let fixes it\" and, \"never use var, let is the replacement.\" Those opinions are valid, but they're merely opinions, just like mine. <code>var</code> is not factually broken or deprecated; it has worked since early JS and it will continue to work as long as JS is around.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}]}, {"type": "paragraph", "content": [{"text": "Next, let's talk about the declaration ", "type": "text"}, {"text": "var buckets", "type": "text", "marks": [{"type": "code"}]}, {"text": ". That variable is used across the entire function (except the final ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement). Any variable that is needed across all (or even most) of a function should be declared so that such usage is obvious.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The parameter ", "type": "text"}, {"text": "names", "type": "text", "marks": [{"type": "code"}]}, {"text": " isn't used across the whole function, but there's no way limit the scope of a parameter, so it behaves as a function-wide declaration regardless.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "So why did we use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " to declare the ", "type": "text"}, {"text": "buckets", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable? There's both semantic and technical reasons to choose ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " here.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Stylistically, ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " has always, from the earliest days of JS, signaled \"variable that belongs to a whole function.\" As we asserted in \"Lexical Scope\" (Chapter 1), ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " attaches to the nearest enclosing function scope, no matter where it appears. That's true even if ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " appears inside a block:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function diff(x,y) {\n    if (x > y) {\n        var tmp = x;    // `tmp` is function-scoped\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even though ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is inside a block, its declaration is function-scoped (to ", "type": "text"}, {"text": "diff(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "), not block-scoped.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "While you can declare ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside a block (and still have it be function-scoped), I would recommend against this approach except in a few specific cases (discussed in Appendix A). Otherwise, ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " should be reserved for use in the top-level scope of a function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why not just use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in that same location? Because ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is visually distinct from ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and therefore signals clearly, \"this variable is function-scoped.\" Using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the top-level scope, especially if not in the first few lines of a function, and when all the other declarations in blocks use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", does not visually draw attention to the difference with the function-scoped declaration.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, I feel ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " better communicates function-scoped than ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " does, and ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " both communicates (and achieves!) block-scoping where ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is insufficient. As long as your programs are going to need both function-scoped and block-scoped variables, the most sensible and readable approach is to use both ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " together, each for their own best purpose.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are other semantic and operational reasons to choose ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in different scenarios. We'll explore the case for ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in more detail in Appendix A.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "My recommendation to use both ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is clearly controversial and contradicts the majority. It's far more common to hear assertions like, \"var is broken, let fixes it\" and, \"never use var, let is the replacement.\" Those opinions are valid, but they're merely opinions, just like mine. ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not factually broken or deprecated; it has worked since early JS and it will continue to work as long as JS is around.", "type": "text"}]}]}]}]}]}, "article_text": "var and let\n\nNext, let's talk about the declaration var buckets. That variable is used across the entire function (except the final return statement). Any variable that is needed across all (or even most) of a function should be declared so that such usage is obvious.\n\nNOTE:\n\nThe parameter names isn't used across the whole function, but there's no way limit the scope of a parameter, so it behaves as a function-wide declaration regardless.\n\nSo why did we use var instead of let to declare the buckets variable? There's both semantic and technical reasons to choose var here.\n\nStylistically, var has always, from the earliest days of JS, signaled \"variable that belongs to a whole function.\" As we asserted in \"Lexical Scope\" (Chapter 1), var attaches to the nearest enclosing function scope, no matter where it appears. That's true even if var appears inside a block:\n\nfunction diff(x,y) {\n    if (x > y) {\n        var tmp = x;    // `tmp` is function-scoped\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n\nEven though var is inside a block, its declaration is function-scoped (to diff(..)), not block-scoped.\n\nWhile you can declare var inside a block (and still have it be function-scoped), I would recommend against this approach except in a few specific cases (discussed in Appendix A). Otherwise, var should be reserved for use in the top-level scope of a function.\n\nWhy not just use let in that same location? Because var is visually distinct from let and therefore signals clearly, \"this variable is function-scoped.\" Using let in the top-level scope, especially if not in the first few lines of a function, and when all the other declarations in blocks use let, does not visually draw attention to the difference with the function-scoped declaration.\n\nIn other words, I feel var better communicates function-scoped than let does, and let both communicates (and achieves!) block-scoping where var is insufficient. As long as your programs are going to need both function-scoped and block-scoped variables, the most sensible and readable approach is to use both var and let together, each for their own best purpose.\n\nThere are other semantic and operational reasons to choose var or let in different scenarios. We'll explore the case for var and let in more detail in Appendix A.\n\nWARNING:\n\nMy recommendation to use both var and let is clearly controversial and contradicts the majority. It's far more common to hear assertions like, \"var is broken, let fixes it\" and, \"never use var, let is the replacement.\" Those opinions are valid, but they're merely opinions, just like mine. var is not factually broken or deprecated; it has worked since early JS and it will continue to work as long as JS is around."}, "id": 216}, {"data": {"uuid": "797fc075-f2fb-4c94-8cfb-6acf3a7e996c", "user": 1, "title": "Where To let?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:30:38.075709+00:00", "updated_on": "2023-06-09 01:30:58.044193+00:00", "article_html": "<h3>Where To <code>let</code>?</h3><p>My advice to reserve <code>var</code> for (mostly) only a top-level function scope means that most other declarations should use <code>let</code>. But you may still be wondering how to decide where each declaration in your program belongs?</p><p>POLE already guides you on those decisions, but let's make sure we explicitly state it. The way to decide is not based on which keyword you want to use. The way to decide is to ask, \"What is the most minimal scope exposure that's sufficient for this variable?\"</p><p>Once that is answered, you'll know if a variable belongs in a block scope or the function scope. If you decide initially that a variable should be block-scoped, and later realize it needs to be elevated to be function-scoped, then that dictates a change not only in the location of that variable's declaration, but also the declarator keyword used. The decision-making process really should proceed like that.</p><p>If a declaration belongs in a block scope, use <code>let</code>. If it belongs in the function scope, use <code>var</code> (again, just my opinion).</p><p>But another way to sort of visualize this decision making is to consider the pre-ES6 version of a program. For example, let's recall <code>diff(..)</code> from earlier:</p><pre><code>function diff(x,y) {\n    var tmp;\n\n    if (x &gt; y) {\n        tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}</code></pre><p>In this version of <code>diff(..)</code>, <code>tmp</code> is clearly declared in the function scope. Is that appropriate for <code>tmp</code>? I would argue, no. <code>tmp</code> is only needed for those few statements. It's not needed for the <code>return</code> statement. It should therefore be block-scoped.</p><p>Prior to ES6, we didn't have <code>let</code> so we couldn't <em>actually</em> block-scope it. But we could do the next-best thing in signaling our intent:</p><pre><code>function diff(x,y) {\n    if (x &gt; y) {\n        // `tmp` is still function-scoped, but\n        // the placement here semantically\n        // signals block-scoping\n        var tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}</code></pre><p>Placing the <code>var</code> declaration for <code>tmp</code> inside the <code>if</code> statement signals to the reader of the code that <code>tmp</code> belongs to that block. Even though JS doesn't enforce that scoping, the semantic signal still has benefit for the reader of your code.</p><p>Following this perspective, you can find any <code>var</code> that's inside a block of this sort and switch it to <code>let</code> to enforce the semantic signal already being sent. That's proper usage of <code>let</code> in my opinion.</p><p>Another example that was historically based on <code>var</code> but which should now pretty much always use <code>let</code> is the <code>for</code> loop:</p><pre><code>for (var i = 0; i &lt; 5; i++) {\n    // do something\n}</code></pre><p>No matter where such a loop is defined, the <code>i</code> should basically always be used only inside the loop, in which case POLE dictates it should be declared with <code>let</code> instead of <code>var</code>:</p><pre><code>for (let i = 0; i &lt; 5; i++) {\n    // do something\n}</code></pre><p>Almost the only case where switching a <code>var</code> to a <code>let</code> in this way would \"break\" your code is if you were relying on accessing the loop's iterator (<code>i</code>) outside/after the loop, such as:</p><pre><code>for (var i = 0; i &lt; 5; i++) {\n    if (checkValue(i)) {\n        break;\n    }\n}\n\nif (i &lt; 5) {\n    console.log(\"The loop stopped early!\");\n}</code></pre><p>This usage pattern is not terribly uncommon, but most feel it smells like poor code structure. A preferable approach is to use another outer-scoped variable for that purpose:</p><pre><code>var lastI;\n\nfor (let i = 0; i &lt; 5; i++) {\n    lastI = i;\n    if (checkValue(i)) {\n        break;\n    }\n}\n\nif (lastI &lt; 5) {\n    console.log(\"The loop stopped early!\");\n}</code></pre><p><code>lastI</code> is needed across this whole scope, so it's declared with <code>var</code>. <code>i</code> is only needed in (each) loop iteration, so it's declared with <code>let</code>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Where To ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My advice to reserve ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " for (mostly) only a top-level function scope means that most other declarations should use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But you may still be wondering how to decide where each declaration in your program belongs?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "POLE already guides you on those decisions, but let's make sure we explicitly state it. The way to decide is not based on which keyword you want to use. The way to decide is to ask, \"What is the most minimal scope exposure that's sufficient for this variable?\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Once that is answered, you'll know if a variable belongs in a block scope or the function scope. If you decide initially that a variable should be block-scoped, and later realize it needs to be elevated to be function-scoped, then that dictates a change not only in the location of that variable's declaration, but also the declarator keyword used. The decision-making process really should proceed like that.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If a declaration belongs in a block scope, use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ". If it belongs in the function scope, use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " (again, just my opinion).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But another way to sort of visualize this decision making is to consider the pre-ES6 version of a program. For example, let's recall ", "type": "text"}, {"text": "diff(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " from earlier:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function diff(x,y) {\n    var tmp;\n\n    if (x > y) {\n        tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this version of ", "type": "text"}, {"text": "diff(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " is clearly declared in the function scope. Is that appropriate for ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": "? I would argue, no. ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " is only needed for those few statements. It's not needed for the ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement. It should therefore be block-scoped.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Prior to ES6, we didn't have ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " so we couldn't ", "type": "text"}, {"text": "actually", "type": "text", "marks": [{"type": "italic"}]}, {"text": " block-scope it. But we could do the next-best thing in signaling our intent:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function diff(x,y) {\n    if (x > y) {\n        // `tmp` is still function-scoped, but\n        // the placement here semantically\n        // signals block-scoping\n        var tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Placing the ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration for ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement signals to the reader of the code that ", "type": "text"}, {"text": "tmp", "type": "text", "marks": [{"type": "code"}]}, {"text": " belongs to that block. Even though JS doesn't enforce that scoping, the semantic signal still has benefit for the reader of your code.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Following this perspective, you can find any ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " that's inside a block of this sort and switch it to ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " to enforce the semantic signal already being sent. That's proper usage of ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in my opinion.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another example that was historically based on ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " but which should now pretty much always use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is the ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (var i = 0; i < 5; i++) {\n    // do something\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "No matter where such a loop is defined, the ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " should basically always be used only inside the loop, in which case POLE dictates it should be declared with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (let i = 0; i < 5; i++) {\n    // do something\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Almost the only case where switching a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " to a ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in this way would \"break\" your code is if you were relying on accessing the loop's iterator (", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": ") outside/after the loop, such as:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (var i = 0; i < 5; i++) {\n    if (checkValue(i)) {\n        break;\n    }\n}\n\nif (i < 5) {\n    console.log(\"The loop stopped early!\");\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This usage pattern is not terribly uncommon, but most feel it smells like poor code structure. A preferable approach is to use another outer-scoped variable for that purpose:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var lastI;\n\nfor (let i = 0; i < 5; i++) {\n    lastI = i;\n    if (checkValue(i)) {\n        break;\n    }\n}\n\nif (lastI < 5) {\n    console.log(\"The loop stopped early!\");\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "lastI", "type": "text", "marks": [{"type": "code"}]}, {"text": " is needed across this whole scope, so it's declared with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ". ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " is only needed in (each) loop iteration, so it's declared with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Where To let?\n\nMy advice to reserve var for (mostly) only a top-level function scope means that most other declarations should use let. But you may still be wondering how to decide where each declaration in your program belongs?\n\nPOLE already guides you on those decisions, but let's make sure we explicitly state it. The way to decide is not based on which keyword you want to use. The way to decide is to ask, \"What is the most minimal scope exposure that's sufficient for this variable?\"\n\nOnce that is answered, you'll know if a variable belongs in a block scope or the function scope. If you decide initially that a variable should be block-scoped, and later realize it needs to be elevated to be function-scoped, then that dictates a change not only in the location of that variable's declaration, but also the declarator keyword used. The decision-making process really should proceed like that.\n\nIf a declaration belongs in a block scope, use let. If it belongs in the function scope, use var (again, just my opinion).\n\nBut another way to sort of visualize this decision making is to consider the pre-ES6 version of a program. For example, let's recall diff(..) from earlier:\n\nfunction diff(x,y) {\n    var tmp;\n\n    if (x > y) {\n        tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n\nIn this version of diff(..), tmp is clearly declared in the function scope. Is that appropriate for tmp? I would argue, no. tmp is only needed for those few statements. It's not needed for the return statement. It should therefore be block-scoped.\n\nPrior to ES6, we didn't have let so we couldn't actually block-scope it. But we could do the next-best thing in signaling our intent:\n\nfunction diff(x,y) {\n    if (x > y) {\n        // `tmp` is still function-scoped, but\n        // the placement here semantically\n        // signals block-scoping\n        var tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n\nPlacing the var declaration for tmp inside the if statement signals to the reader of the code that tmp belongs to that block. Even though JS doesn't enforce that scoping, the semantic signal still has benefit for the reader of your code.\n\nFollowing this perspective, you can find any var that's inside a block of this sort and switch it to let to enforce the semantic signal already being sent. That's proper usage of let in my opinion.\n\nAnother example that was historically based on var but which should now pretty much always use let is the for loop:\n\nfor (var i = 0; i < 5; i++) {\n    // do something\n}\n\nNo matter where such a loop is defined, the i should basically always be used only inside the loop, in which case POLE dictates it should be declared with let instead of var:\n\nfor (let i = 0; i < 5; i++) {\n    // do something\n}\n\nAlmost the only case where switching a var to a let in this way would \"break\" your code is if you were relying on accessing the loop's iterator (i) outside/after the loop, such as:\n\nfor (var i = 0; i < 5; i++) {\n    if (checkValue(i)) {\n        break;\n    }\n}\n\nif (i < 5) {\n    console.log(\"The loop stopped early!\");\n}\n\nThis usage pattern is not terribly uncommon, but most feel it smells like poor code structure. A preferable approach is to use another outer-scoped variable for that purpose:\n\nvar lastI;\n\nfor (let i = 0; i < 5; i++) {\n    lastI = i;\n    if (checkValue(i)) {\n        break;\n    }\n}\n\nif (lastI < 5) {\n    console.log(\"The loop stopped early!\");\n}\n\nlastI is needed across this whole scope, so it's declared with var. i is only needed in (each) loop iteration, so it's declared with let."}, "id": 217}, {"data": {"uuid": "a0594cc8-3de4-4cd1-a31d-df14196383d2", "user": 1, "title": "What's the Catch?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:31:16.009629+00:00", "updated_on": "2023-06-09 01:31:30.443151+00:00", "article_html": "<h3>What's the Catch?</h3><p>So far we've asserted that <code>var</code> and parameters are function-scoped, and <code>let</code>/<code>const</code> signal block-scoped declarations. There's one little exception to call out: the <code>catch</code> clause.</p><p>Since the introduction of <code>try..catch</code> back in ES3 (in 1999), the <code>catch</code> clause has used an additional (little-known) block-scoping declaration capability:</p><pre><code>try {\n    doesntExist();\n}\ncatch (err) {\n    console.log(err);\n    // ReferenceError: 'doesntExist' is not defined\n    // ^^^^ message printed from the caught exception\n\n    let onlyHere = true;\n    var outerVariable = true;\n}\n\nconsole.log(outerVariable);     // true\n\nconsole.log(err);\n// ReferenceError: 'err' is not defined\n// ^^^^ this is another thrown (uncaught) exception</code></pre><p>The <code>err</code> variable declared by the <code>catch</code> clause is block-scoped to that block. This <code>catch</code> clause block can hold other block-scoped declarations via <code>let</code>. But a <code>var</code> declaration inside this block still attaches to the outer function/global scope.</p><p>ES2019 (recently, at the time of writing) changed <code>catch</code> clauses so their declaration is optional; if the declaration is omitted, the <code>catch</code> block is no longer (by default) a scope; it's still a block, though!</p><p>So if you need to react to the condition <em>that an exception occurred</em> (so you can gracefully recover), but you don't care about the error value itself, you can omit the <code>catch</code> declaration:</p><pre><code>try {\n    doOptionOne();\n}\ncatch {   // catch-declaration omitted\n    doOptionTwoInstead();\n}</code></pre><p>This is a small but delightful simplification of syntax for a fairly common use case, and may also be slightly more performant in removing an unnecessary scope!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "What's the Catch?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So far we've asserted that ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " and parameters are function-scoped, and ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " signal block-scoped declarations. There's one little exception to call out: the ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since the introduction of ", "type": "text"}, {"text": "try..catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " back in ES3 (in 1999), the ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause has used an additional (little-known) block-scoping declaration capability:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "try {\n    doesntExist();\n}\ncatch (err) {\n    console.log(err);\n    // ReferenceError: 'doesntExist' is not defined\n    // ^^^^ message printed from the caught exception\n\n    let onlyHere = true;\n    var outerVariable = true;\n}\n\nconsole.log(outerVariable);     // true\n\nconsole.log(err);\n// ReferenceError: 'err' is not defined\n// ^^^^ this is another thrown (uncaught) exception", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "err", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable declared by the ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause is block-scoped to that block. This ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause block can hold other block-scoped declarations via ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration inside this block still attaches to the outer function/global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES2019 (recently, at the time of writing) changed ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clauses so their declaration is optional; if the declaration is omitted, the ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " block is no longer (by default) a scope; it's still a block, though!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So if you need to react to the condition ", "type": "text"}, {"text": "that an exception occurred", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (so you can gracefully recover), but you don't care about the error value itself, you can omit the ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "try {\n    doOptionOne();\n}\ncatch {   // catch-declaration omitted\n    doOptionTwoInstead();\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is a small but delightful simplification of syntax for a fairly common use case, and may also be slightly more performant in removing an unnecessary scope!", "type": "text"}]}]}, "article_text": "What's the Catch?\n\nSo far we've asserted that var and parameters are function-scoped, and let/const signal block-scoped declarations. There's one little exception to call out: the catch clause.\n\nSince the introduction of try..catch back in ES3 (in 1999), the catch clause has used an additional (little-known) block-scoping declaration capability:\n\ntry {\n    doesntExist();\n}\ncatch (err) {\n    console.log(err);\n    // ReferenceError: 'doesntExist' is not defined\n    // ^^^^ message printed from the caught exception\n\n    let onlyHere = true;\n    var outerVariable = true;\n}\n\nconsole.log(outerVariable);     // true\n\nconsole.log(err);\n// ReferenceError: 'err' is not defined\n// ^^^^ this is another thrown (uncaught) exception\n\nThe err variable declared by the catch clause is block-scoped to that block. This catch clause block can hold other block-scoped declarations via let. But a var declaration inside this block still attaches to the outer function/global scope.\n\nES2019 (recently, at the time of writing) changed catch clauses so their declaration is optional; if the declaration is omitted, the catch block is no longer (by default) a scope; it's still a block, though!\n\nSo if you need to react to the condition that an exception occurred (so you can gracefully recover), but you don't care about the error value itself, you can omit the catch declaration:\n\ntry {\n    doOptionOne();\n}\ncatch {   // catch-declaration omitted\n    doOptionTwoInstead();\n}\n\nThis is a small but delightful simplification of syntax for a fairly common use case, and may also be slightly more performant in removing an unnecessary scope!"}, "id": 218}]}, {"data": {"uuid": "55643262-2c54-4d98-bfbb-1b79745ef950", "user": 1, "title": "Function Declarations in Blocks (FiB)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:31:48.513006+00:00", "updated_on": "2023-06-09 01:32:15.273928+00:00", "article_html": "<h2>Function Declarations in Blocks (FiB)</h2><p>We've seen now that declarations using <code>let</code> or <code>const</code> are block-scoped, and <code>var</code> declarations are function-scoped. So what about <code>function</code> declarations that appear directly inside blocks? As a feature, this is called \"FiB.\"</p><p>We typically think of <code>function</code> declarations like they're the equivalent of a <code>var</code> declaration. So are they function-scoped like <code>var</code> is?</p><p>No and yes. I know... that's confusing. Let's dig in:</p><pre><code>if (false) {\n    function ask() {\n        console.log(\"Does this run?\");\n    }\n}\nask();</code></pre><p>What do you expect for this program to do? Three reasonable outcomes:</p><ol><li><p>The <code>ask()</code> call might fail with a <code>ReferenceError</code> exception, because the <code>ask</code> identifier is block-scoped to the <code>if</code> block scope and thus isn't available in the outer/global scope.</p></li><li><p>The <code>ask()</code> call might fail with a <code>TypeError</code> exception, because the <code>ask</code> identifier exists, but it's <code>undefined</code> (since the <code>if</code> statement doesn't run) and thus not a callable function.</p></li><li><p>The <code>ask()</code> call might run correctly, printing out the \"Does it run?\" message.</p></li></ol><p>Here's the confusing part: depending on which JS environment you try that code snippet in, you may get different results! This is one of those few crazy areas where existing legacy behavior betrays a predictable outcome.</p><p>The JS specification says that <code>function</code> declarations inside of blocks are block-scoped, so the answer should be (1). However, most browser-based JS engines (including v8, which comes from Chrome but is also used in Node) will behave as (2), meaning the identifier is scoped outside the <code>if</code> block but the function value is not automatically initialized, so it remains <code>undefined</code>.</p><p>Why are browser JS engines allowed to behave contrary to the specification? Because these engines already had certain behaviors around FiB before ES6 introduced block scoping, and there was concern that changing to adhere to the specification might break some existing website JS code. As such, an exception was made in Appendix B of the JS specification, which allows certain deviations for browser JS engines (only!).</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>You wouldn't typically categorize Node as a browser JS environment, since it usually runs on a server. But Node's v8 engine is shared with Chrome (and Edge) browsers. Since v8 is first a browser JS engine, it adopts this Appendix B exception, which then means that the browser exceptions are extended to Node.</p></td></tr></tbody></table><p>One of the most common use cases for placing a <code>function</code> declaration in a block is to conditionally define a function one way or another (like with an <code>if..else</code> statement) depending on some environment state. For example:</p><pre><code>if (typeof Array.isArray != \"undefined\") {\n    function isArray(a) {\n        return Array.isArray(a);\n    }\n}\nelse {\n    function isArray(a) {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    }\n}</code></pre><p>It's tempting to structure code this way for performance reasons, since the <code>typeof Array.isArray</code> check is only performed once, as opposed to defining just one <code>isArray(..)</code> and putting the <code>if</code> statement inside it\u2014the check would then run unnecessarily on every call.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>In addition to the risks of FiB deviations, another problem with conditional-definition of functions is it's harder to debug such a program. If you end up with a bug in the <code>isArray(..)</code> function, you first have to figure out <em>which</em> <code>isArray(..)</code> implementation is actually running! Sometimes, the bug is that the wrong one was applied because the conditional check was incorrect! If you define multiple versions of a function, that program is always harder to reason about and maintain.</p></td></tr></tbody></table><p>In addition to the previous snippets, several other FiB corner cases are lurking; such behaviors in various browsers and non-browser JS environments (JS engines that aren't browser based) will likely vary. For example:</p><pre><code>if (true) {\n    function ask() {\n        console.log(\"Am I called?\");\n    }\n}\n\nif (true) {\n    function ask() {\n        console.log(\"Or what about me?\");\n    }\n}\n\nfor (let i = 0; i &lt; 5; i++) {\n    function ask() {\n        console.log(\"Or is it one of these?\");\n    }\n}\n\nask();\n\nfunction ask() {\n    console.log(\"Wait, maybe, it's this one?\");\n}</code></pre><p>Recall that function hoisting as described in \"When Can I Use a Variable?\" (in Chapter 5) might suggest that the final <code>ask()</code> in this snippet, with \"Wait, maybe...\" as its message, would hoist above the call to <code>ask()</code>. Since it's the last function declaration of that name, it should \"win,\" right? Unfortunately, no.</p><p>It's not my intention to document all these weird corner cases, nor to try to explain why each of them behaves a certain way. That information is, in my opinion, arcane legacy trivia.</p><p>My real concern with FiB is, what advice can I give to ensure your code behaves predictably in all circumstances?</p><p>As far as I'm concerned, the only practical answer to avoiding the vagaries of FiB is to simply avoid FiB entirely. In other words, never place a <code>function</code> declaration directly inside any block. Always place <code>function</code> declarations anywhere in the top-level scope of a function (or in the global scope).</p><p>So for the earlier <code>if..else</code> example, my suggestion is to avoid conditionally defining functions if at all possible. Yes, it may be slightly less performant, but this is the better overall approach:</p><pre><code>function isArray(a) {\n    if (typeof Array.isArray != \"undefined\") {\n        return Array.isArray(a);\n    }\n    else {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    }\n}</code></pre><p>If that performance hit becomes a critical path issue for your application, I suggest you consider this approach:</p><pre><code>var isArray = function isArray(a) {\n    return Array.isArray(a);\n};\n\n// override the definition, if you must\nif (typeof Array.isArray == \"undefined\") {\n    isArray = function isArray(a) {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    };\n}</code></pre><p>It's important to notice that here I'm placing a <code>function</code> <strong>expression</strong>, not a declaration, inside the <code>if</code> statement. That's perfectly fine and valid, for <code>function</code> expressions to appear inside blocks. Our discussion about FiB is about avoiding <code>function</code> <strong>declarations</strong> in blocks.</p><p>Even if you test your program and it works correctly, the small benefit you may derive from using FiB style in your code is far outweighed by the potential risks in the future for confusion by other developers, or variances in how your code runs in other JS environments.</p><p>FiB is not worth it, and should be avoided.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Function Declarations in Blocks (FiB)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We've seen now that declarations using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " are block-scoped, and ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations are function-scoped. So what about ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations that appear directly inside blocks? As a feature, this is called \"FiB.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We typically think of ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations like they're the equivalent of a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration. So are they function-scoped like ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "No and yes. I know... that's confusing. Let's dig in:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "if (false) {\n    function ask() {\n        console.log(\"Does this run?\");\n    }\n}\nask();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What do you expect for this program to do? Three reasonable outcomes:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "ask()", "type": "text", "marks": [{"type": "code"}]}, {"text": " call might fail with a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": " exception, because the ", "type": "text"}, {"text": "ask", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier is block-scoped to the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " block scope and thus isn't available in the outer/global scope.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "ask()", "type": "text", "marks": [{"type": "code"}]}, {"text": " call might fail with a ", "type": "text"}, {"text": "TypeError", "type": "text", "marks": [{"type": "code"}]}, {"text": " exception, because the ", "type": "text"}, {"text": "ask", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier exists, but it's ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " (since the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement doesn't run) and thus not a callable function.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "ask()", "type": "text", "marks": [{"type": "code"}]}, {"text": " call might run correctly, printing out the \"Does it run?\" message.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Here's the confusing part: depending on which JS environment you try that code snippet in, you may get different results! This is one of those few crazy areas where existing legacy behavior betrays a predictable outcome.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The JS specification says that ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations inside of blocks are block-scoped, so the answer should be (1). However, most browser-based JS engines (including v8, which comes from Chrome but is also used in Node) will behave as (2), meaning the identifier is scoped outside the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " block but the function value is not automatically initialized, so it remains ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why are browser JS engines allowed to behave contrary to the specification? Because these engines already had certain behaviors around FiB before ES6 introduced block scoping, and there was concern that changing to adhere to the specification might break some existing website JS code. As such, an exception was made in Appendix B of the JS specification, which allows certain deviations for browser JS engines (only!).", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "You wouldn't typically categorize Node as a browser JS environment, since it usually runs on a server. But Node's v8 engine is shared with Chrome (and Edge) browsers. Since v8 is first a browser JS engine, it adopts this Appendix B exception, which then means that the browser exceptions are extended to Node.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "One of the most common use cases for placing a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration in a block is to conditionally define a function one way or another (like with an ", "type": "text"}, {"text": "if..else", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement) depending on some environment state. For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "if (typeof Array.isArray != \"undefined\") {\n    function isArray(a) {\n        return Array.isArray(a);\n    }\n}\nelse {\n    function isArray(a) {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's tempting to structure code this way for performance reasons, since the ", "type": "text"}, {"text": "typeof Array.isArray", "type": "text", "marks": [{"type": "code"}]}, {"text": " check is only performed once, as opposed to defining just one ", "type": "text"}, {"text": "isArray(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and putting the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement inside it\u2014the check would then run unnecessarily on every call.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "In addition to the risks of FiB deviations, another problem with conditional-definition of functions is it's harder to debug such a program. If you end up with a bug in the ", "type": "text"}, {"text": "isArray(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, you first have to figure out ", "type": "text"}, {"text": "which", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "isArray(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " implementation is actually running! Sometimes, the bug is that the wrong one was applied because the conditional check was incorrect! If you define multiple versions of a function, that program is always harder to reason about and maintain.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "In addition to the previous snippets, several other FiB corner cases are lurking; such behaviors in various browsers and non-browser JS environments (JS engines that aren't browser based) will likely vary. For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "if (true) {\n    function ask() {\n        console.log(\"Am I called?\");\n    }\n}\n\nif (true) {\n    function ask() {\n        console.log(\"Or what about me?\");\n    }\n}\n\nfor (let i = 0; i < 5; i++) {\n    function ask() {\n        console.log(\"Or is it one of these?\");\n    }\n}\n\nask();\n\nfunction ask() {\n    console.log(\"Wait, maybe, it's this one?\");\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall that function hoisting as described in \"When Can I Use a Variable?\" (in Chapter 5) might suggest that the final ", "type": "text"}, {"text": "ask()", "type": "text", "marks": [{"type": "code"}]}, {"text": " in this snippet, with \"Wait, maybe...\" as its message, would hoist above the call to ", "type": "text"}, {"text": "ask()", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Since it's the last function declaration of that name, it should \"win,\" right? Unfortunately, no.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's not my intention to document all these weird corner cases, nor to try to explain why each of them behaves a certain way. That information is, in my opinion, arcane legacy trivia.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My real concern with FiB is, what advice can I give to ensure your code behaves predictably in all circumstances?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As far as I'm concerned, the only practical answer to avoiding the vagaries of FiB is to simply avoid FiB entirely. In other words, never place a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration directly inside any block. Always place ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations anywhere in the top-level scope of a function (or in the global scope).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So for the earlier ", "type": "text"}, {"text": "if..else", "type": "text", "marks": [{"type": "code"}]}, {"text": " example, my suggestion is to avoid conditionally defining functions if at all possible. Yes, it may be slightly less performant, but this is the better overall approach:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function isArray(a) {\n    if (typeof Array.isArray != \"undefined\") {\n        return Array.isArray(a);\n    }\n    else {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If that performance hit becomes a critical path issue for your application, I suggest you consider this approach:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var isArray = function isArray(a) {\n    return Array.isArray(a);\n};\n\n// override the definition, if you must\nif (typeof Array.isArray == \"undefined\") {\n    isArray = function isArray(a) {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    };\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's important to notice that here I'm placing a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "expression", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", not a declaration, inside the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement. That's perfectly fine and valid, for ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions to appear inside blocks. Our discussion about FiB is about avoiding ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "declarations", "type": "text", "marks": [{"type": "bold"}]}, {"text": " in blocks.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even if you test your program and it works correctly, the small benefit you may derive from using FiB style in your code is far outweighed by the potential risks in the future for confusion by other developers, or variances in how your code runs in other JS environments.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "FiB is not worth it, and should be avoided.", "type": "text"}]}]}, "article_text": "Function Declarations in Blocks (FiB)\n\nWe've seen now that declarations using let or const are block-scoped, and var declarations are function-scoped. So what about function declarations that appear directly inside blocks? As a feature, this is called \"FiB.\"\n\nWe typically think of function declarations like they're the equivalent of a var declaration. So are they function-scoped like var is?\n\nNo and yes. I know... that's confusing. Let's dig in:\n\nif (false) {\n    function ask() {\n        console.log(\"Does this run?\");\n    }\n}\nask();\n\nWhat do you expect for this program to do? Three reasonable outcomes:\n\nThe ask() call might fail with a ReferenceError exception, because the ask identifier is block-scoped to the if block scope and thus isn't available in the outer/global scope.\n\nThe ask() call might fail with a TypeError exception, because the ask identifier exists, but it's undefined (since the if statement doesn't run) and thus not a callable function.\n\nThe ask() call might run correctly, printing out the \"Does it run?\" message.\n\nHere's the confusing part: depending on which JS environment you try that code snippet in, you may get different results! This is one of those few crazy areas where existing legacy behavior betrays a predictable outcome.\n\nThe JS specification says that function declarations inside of blocks are block-scoped, so the answer should be (1). However, most browser-based JS engines (including v8, which comes from Chrome but is also used in Node) will behave as (2), meaning the identifier is scoped outside the if block but the function value is not automatically initialized, so it remains undefined.\n\nWhy are browser JS engines allowed to behave contrary to the specification? Because these engines already had certain behaviors around FiB before ES6 introduced block scoping, and there was concern that changing to adhere to the specification might break some existing website JS code. As such, an exception was made in Appendix B of the JS specification, which allows certain deviations for browser JS engines (only!).\n\nNOTE:\n\nYou wouldn't typically categorize Node as a browser JS environment, since it usually runs on a server. But Node's v8 engine is shared with Chrome (and Edge) browsers. Since v8 is first a browser JS engine, it adopts this Appendix B exception, which then means that the browser exceptions are extended to Node.\n\nOne of the most common use cases for placing a function declaration in a block is to conditionally define a function one way or another (like with an if..else statement) depending on some environment state. For example:\n\nif (typeof Array.isArray != \"undefined\") {\n    function isArray(a) {\n        return Array.isArray(a);\n    }\n}\nelse {\n    function isArray(a) {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    }\n}\n\nIt's tempting to structure code this way for performance reasons, since the typeof Array.isArray check is only performed once, as opposed to defining just one isArray(..) and putting the if statement inside it\u2014the check would then run unnecessarily on every call.\n\nWARNING:\n\nIn addition to the risks of FiB deviations, another problem with conditional-definition of functions is it's harder to debug such a program. If you end up with a bug in the isArray(..) function, you first have to figure out which isArray(..) implementation is actually running! Sometimes, the bug is that the wrong one was applied because the conditional check was incorrect! If you define multiple versions of a function, that program is always harder to reason about and maintain.\n\nIn addition to the previous snippets, several other FiB corner cases are lurking; such behaviors in various browsers and non-browser JS environments (JS engines that aren't browser based) will likely vary. For example:\n\nif (true) {\n    function ask() {\n        console.log(\"Am I called?\");\n    }\n}\n\nif (true) {\n    function ask() {\n        console.log(\"Or what about me?\");\n    }\n}\n\nfor (let i = 0; i < 5; i++) {\n    function ask() {\n        console.log(\"Or is it one of these?\");\n    }\n}\n\nask();\n\nfunction ask() {\n    console.log(\"Wait, maybe, it's this one?\");\n}\n\nRecall that function hoisting as described in \"When Can I Use a Variable?\" (in Chapter 5) might suggest that the final ask() in this snippet, with \"Wait, maybe...\" as its message, would hoist above the call to ask(). Since it's the last function declaration of that name, it should \"win,\" right? Unfortunately, no.\n\nIt's not my intention to document all these weird corner cases, nor to try to explain why each of them behaves a certain way. That information is, in my opinion, arcane legacy trivia.\n\nMy real concern with FiB is, what advice can I give to ensure your code behaves predictably in all circumstances?\n\nAs far as I'm concerned, the only practical answer to avoiding the vagaries of FiB is to simply avoid FiB entirely. In other words, never place a function declaration directly inside any block. Always place function declarations anywhere in the top-level scope of a function (or in the global scope).\n\nSo for the earlier if..else example, my suggestion is to avoid conditionally defining functions if at all possible. Yes, it may be slightly less performant, but this is the better overall approach:\n\nfunction isArray(a) {\n    if (typeof Array.isArray != \"undefined\") {\n        return Array.isArray(a);\n    }\n    else {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    }\n}\n\nIf that performance hit becomes a critical path issue for your application, I suggest you consider this approach:\n\nvar isArray = function isArray(a) {\n    return Array.isArray(a);\n};\n\n// override the definition, if you must\nif (typeof Array.isArray == \"undefined\") {\n    isArray = function isArray(a) {\n        return Object.prototype.toString.call(a)\n            == \"[object Array]\";\n    };\n}\n\nIt's important to notice that here I'm placing a function expression, not a declaration, inside the if statement. That's perfectly fine and valid, for function expressions to appear inside blocks. Our discussion about FiB is about avoiding function declarations in blocks.\n\nEven if you test your program and it works correctly, the small benefit you may derive from using FiB style in your code is far outweighed by the potential risks in the future for confusion by other developers, or variances in how your code runs in other JS environments.\n\nFiB is not worth it, and should be avoided."}, "id": 219}, {"data": {"uuid": "2d2108b5-8aef-4a64-92dc-011db021d70d", "user": 1, "title": "Blocked Over", "author": "Kyle Simpson", "created_on": "2023-06-09 01:32:37.142555+00:00", "updated_on": "2023-06-09 01:32:47.660870+00:00", "article_html": "<h2>Blocked Over</h2><p>The point of lexical scoping rules in a programming language is so we can appropriately organize our program's variables, both for operational as well as semantic code communication purposes.</p><p>And one of the most important organizational techniques is to ensure that no variable is over-exposed to unnecessary scopes (POLE). Hopefully you now appreciate block scoping much more deeply than before.</p><p>Hopefully by now you feel like you're standing on much more solid ground with understanding lexical scope. From that base, the next chapter jumps into the weighty topic of closure.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Blocked Over", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The point of lexical scoping rules in a programming language is so we can appropriately organize our program's variables, both for operational as well as semantic code communication purposes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And one of the most important organizational techniques is to ensure that no variable is over-exposed to unnecessary scopes (POLE). Hopefully you now appreciate block scoping much more deeply than before.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Hopefully by now you feel like you're standing on much more solid ground with understanding lexical scope. From that base, the next chapter jumps into the weighty topic of closure.", "type": "text"}]}]}, "article_text": "Blocked Over\n\nThe point of lexical scoping rules in a programming language is so we can appropriately organize our program's variables, both for operational as well as semantic code communication purposes.\n\nAnd one of the most important organizational techniques is to ensure that no variable is over-exposed to unnecessary scopes (POLE). Hopefully you now appreciate block scoping much more deeply than before.\n\nHopefully by now you feel like you're standing on much more solid ground with understanding lexical scope. From that base, the next chapter jumps into the weighty topic of closure."}, "id": 220}]}, {"data": {"uuid": "65b7fe56-f4fd-4aa9-8add-e813929fdb0a", "user": 1, "title": "Chapter 7: Using Closures", "author": "Kyle Simpson", "created_on": "2023-06-09 01:33:22.589838+00:00", "updated_on": "2023-06-09 01:34:09.424811+00:00", "article_html": "<h1>Chapter 7: Using Closures</h1><p>Up to this point, we've focused on the ins and outs of lexical scope, and how that affects the organization and usage of variables in our programs.</p><p>Our attention again shifts broader in abstraction, to the historically somewhat daunting topic of closure. Don't worry! You don't need an advanced computer science degree to make sense of it. Our broad goal in this book is not merely to understand scope, but to more effectively use it in the structure of our programs; closure is central to that effort.</p><p>Recall the main conclusion of Chapter 6: the <em>least exposure</em> principle (POLE) encourages us to use block (and function) scoping to limit the scope exposure of variables. This helps keep code understandable and maintainable, and helps avoid many scoping pitfalls (i.e., name collision, etc.).</p><p>Closure builds on this approach: for variables we need to use over time, instead of placing them in larger outer scopes, we can encapsulate (more narrowly scope) them but still preserve access from inside functions, for broader use. Functions <em>remember</em> these referenced scoped variables via closure.</p><p>We already saw an example of this kind of closure in the previous chapter (<code>factorial(..)</code> in Chapter 6), and you've almost certainly already used it in your own programs. If you've ever written a callback that accesses variables outside its own scope... guess what!? That's closure.</p><p>Closure is one of the most important language characteristics ever invented in programming\u2014it underlies major programming paradigms, including Functional Programming (FP), modules, and even a bit of class-oriented design. Getting comfortable with closure is required for mastering JS and effectively leveraging many important design patterns throughout your code.</p><p>Addressing all aspects of closure requires a daunting mountain of discussion and code throughout this chapter. Make sure to take your time and ensure you're comfortable with each bit before moving onto the next.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 7: Using Closures", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Up to this point, we've focused on the ins and outs of lexical scope, and how that affects the organization and usage of variables in our programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Our attention again shifts broader in abstraction, to the historically somewhat daunting topic of closure. Don't worry! You don't need an advanced computer science degree to make sense of it. Our broad goal in this book is not merely to understand scope, but to more effectively use it in the structure of our programs; closure is central to that effort.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall the main conclusion of Chapter 6: the ", "type": "text"}, {"text": "least exposure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " principle (POLE) encourages us to use block (and function) scoping to limit the scope exposure of variables. This helps keep code understandable and maintainable, and helps avoid many scoping pitfalls (i.e., name collision, etc.).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure builds on this approach: for variables we need to use over time, instead of placing them in larger outer scopes, we can encapsulate (more narrowly scope) them but still preserve access from inside functions, for broader use. Functions ", "type": "text"}, {"text": "remember", "type": "text", "marks": [{"type": "italic"}]}, {"text": " these referenced scoped variables via closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We already saw an example of this kind of closure in the previous chapter (", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " in Chapter 6), and you've almost certainly already used it in your own programs. If you've ever written a callback that accesses variables outside its own scope... guess what!? That's closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is one of the most important language characteristics ever invented in programming\u2014it underlies major programming paradigms, including Functional Programming (FP), modules, and even a bit of class-oriented design. Getting comfortable with closure is required for mastering JS and effectively leveraging many important design patterns throughout your code.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Addressing all aspects of closure requires a daunting mountain of discussion and code throughout this chapter. Make sure to take your time and ensure you're comfortable with each bit before moving onto the next.", "type": "text"}]}]}, "article_text": "Chapter 7: Using Closures\n\nUp to this point, we've focused on the ins and outs of lexical scope, and how that affects the organization and usage of variables in our programs.\n\nOur attention again shifts broader in abstraction, to the historically somewhat daunting topic of closure. Don't worry! You don't need an advanced computer science degree to make sense of it. Our broad goal in this book is not merely to understand scope, but to more effectively use it in the structure of our programs; closure is central to that effort.\n\nRecall the main conclusion of Chapter 6: the least exposure principle (POLE) encourages us to use block (and function) scoping to limit the scope exposure of variables. This helps keep code understandable and maintainable, and helps avoid many scoping pitfalls (i.e., name collision, etc.).\n\nClosure builds on this approach: for variables we need to use over time, instead of placing them in larger outer scopes, we can encapsulate (more narrowly scope) them but still preserve access from inside functions, for broader use. Functions remember these referenced scoped variables via closure.\n\nWe already saw an example of this kind of closure in the previous chapter (factorial(..) in Chapter 6), and you've almost certainly already used it in your own programs. If you've ever written a callback that accesses variables outside its own scope... guess what!? That's closure.\n\nClosure is one of the most important language characteristics ever invented in programming\u2014it underlies major programming paradigms, including Functional Programming (FP), modules, and even a bit of class-oriented design. Getting comfortable with closure is required for mastering JS and effectively leveraging many important design patterns throughout your code.\n\nAddressing all aspects of closure requires a daunting mountain of discussion and code throughout this chapter. Make sure to take your time and ensure you're comfortable with each bit before moving onto the next."}, "id": 221, "children": [{"data": {"uuid": "bdc6fff4-263c-4b10-a5be-b555696e4054", "user": 1, "title": "See the Closure", "author": "Kyle Simpson", "created_on": "2023-06-09 01:33:49.775364+00:00", "updated_on": "2023-06-09 01:35:07.053281+00:00", "article_html": "<h2>See the Closure</h2><p>Closure is originally a mathematical concept, from lambda calculus. But I'm not going to list out math formulas or use a bunch of notation and jargon to define it.</p><p>Instead, I'm going to focus on a practical perspective. We'll start by defining closure in terms of what we can observe in different behavior of our programs, as opposed to if closure was not present in JS. However, later in this chapter, we're going to flip closure around to look at it from an <em>alternative perspective</em>.</p><p>Closure is a behavior of functions and only functions. If you aren't dealing with a function, closure does not apply. An object cannot have closure, nor does a class have closure (though its functions/methods might). Only functions have closure.</p><p>For closure to be observed, a function must be invoked, and specifically it must be invoked in a different branch of the scope chain from where it was originally defined. A function executing in the same scope it was defined would not exhibit any observably different behavior with or without closure being possible; by the observational perspective and definition, that is not closure.</p><p>Let's look at some code, annotated with its relevant scope bubble colors (see Chapter 2):</p><pre><code>// outer/global scope: RED(1)\n\nfunction lookupStudent(studentID) {\n    // function scope: BLUE(2)\n\n    var students = [\n        { id: 14, name: \"Kyle\" },\n        { id: 73, name: \"Suzy\" },\n        { id: 112, name: \"Frank\" },\n        { id: 6, name: \"Sarah\" }\n    ];\n\n    return function greetStudent(greeting){\n        // function scope: GREEN(3)\n\n        var student = students.find(\n            student =&gt; student.id == studentID\n        );\n\n        return `${ greeting }, ${ student.name }!`;\n    };\n}\n\nvar chosenStudents = [\n    lookupStudent(6),\n    lookupStudent(112)\n];\n\n// accessing the function's name:\nchosenStudents[0].name;\n// greetStudent\n\nchosenStudents[0](\"Hello\");\n// Hello, Sarah!\n\nchosenStudents[1](\"Howdy\");\n// Howdy, Frank!</code></pre><p>The first thing to notice about this code is that the <code>lookupStudent(..)</code> outer function creates and returns an inner function called <code>greetStudent(..)</code>. <code>lookupStudent(..)</code> is called twice, producing two separate instances of its inner <code>greetStudent(..)</code> function, both of which are saved into the <code>chosenStudents</code> array.</p><p>We verify that's the case by checking the <code>.name</code> property of the returned function saved in <code>chosenStudents[0]</code>, and it's indeed an instance of the inner <code>greetStudent(..)</code>.</p><p>After each call to <code>lookupStudent(..)</code> finishes, it would seem like all its inner variables would be discarded and GC'd (garbage collected). The inner function is the only thing that seems to be returned and preserved. But here's where the behavior differs in ways we can start to observe.</p><p>While <code>greetStudent(..)</code> does receive a single argument as the parameter named <code>greeting</code>, it also makes reference to both <code>students</code> and <code>studentID</code>, identifiers which come from the enclosing scope of <code>lookupStudent(..)</code>. Each of those references from the inner function to the variable in an outer scope is called a <em>closure</em>. In academic terms, each instance of <code>greetStudent(..)</code> <em>closes over</em> the outer variables <code>students</code> and <code>studentID</code>.</p><p>So what do those closures do here, in a concrete, observable sense?</p><p>Closure allows <code>greetStudent(..)</code> to continue to access those outer variables even after the outer scope is finished (when each call to <code>lookupStudent(..)</code> completes). Instead of the instances of <code>students</code> and <code>studentID</code> being GC'd, they stay around in memory. At a later time when either instance of the <code>greetStudent(..)</code> function is invoked, those variables are still there, holding their current values.</p><p>If JS functions did not have closure, the completion of each <code>lookupStudent(..)</code> call would immediately tear down its scope and GC the <code>students</code> and <code>studentID</code> variables. When we later called one of the <code>greetStudent(..)</code> functions, what would then happen?</p><p>If <code>greetStudent(..)</code> tried to access what it thought was a BLUE(2) marble, but that marble did not actually exist (anymore), the reasonable assumption is we should get a <code>ReferenceError</code>, right?</p><p>But we don't get an error. The fact that the execution of <code>chosenStudents[0](\"Hello\")</code> works and returns us the message \"Hello, Sarah!\", means it was still able to access the <code>students</code> and <code>studentID</code> variables. This is a direct observation of closure!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "See the Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is originally a mathematical concept, from lambda calculus. But I'm not going to list out math formulas or use a bunch of notation and jargon to define it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Instead, I'm going to focus on a practical perspective. We'll start by defining closure in terms of what we can observe in different behavior of our programs, as opposed to if closure was not present in JS. However, later in this chapter, we're going to flip closure around to look at it from an ", "type": "text"}, {"text": "alternative perspective", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is a behavior of functions and only functions. If you aren't dealing with a function, closure does not apply. An object cannot have closure, nor does a class have closure (though its functions/methods might). Only functions have closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For closure to be observed, a function must be invoked, and specifically it must be invoked in a different branch of the scope chain from where it was originally defined. A function executing in the same scope it was defined would not exhibit any observably different behavior with or without closure being possible; by the observational perspective and definition, that is not closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's look at some code, annotated with its relevant scope bubble colors (see Chapter 2):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer/global scope: RED(1)\n\nfunction lookupStudent(studentID) {\n    // function scope: BLUE(2)\n\n    var students = [\n        { id: 14, name: \"Kyle\" },\n        { id: 73, name: \"Suzy\" },\n        { id: 112, name: \"Frank\" },\n        { id: 6, name: \"Sarah\" }\n    ];\n\n    return function greetStudent(greeting){\n        // function scope: GREEN(3)\n\n        var student = students.find(\n            student => student.id == studentID\n        );\n\n        return `${ greeting }, ${ student.name }!`;\n    };\n}\n\nvar chosenStudents = [\n    lookupStudent(6),\n    lookupStudent(112)\n];\n\n// accessing the function's name:\nchosenStudents[0].name;\n// greetStudent\n\nchosenStudents[0](\"Hello\");\n// Hello, Sarah!\n\nchosenStudents[1](\"Howdy\");\n// Howdy, Frank!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first thing to notice about this code is that the ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " outer function creates and returns an inner function called ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is called twice, producing two separate instances of its inner ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, both of which are saved into the ", "type": "text"}, {"text": "chosenStudents", "type": "text", "marks": [{"type": "code"}]}, {"text": " array.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We verify that's the case by checking the ", "type": "text"}, {"text": ".name", "type": "text", "marks": [{"type": "code"}]}, {"text": " property of the returned function saved in ", "type": "text"}, {"text": "chosenStudents[0]", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and it's indeed an instance of the inner ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "After each call to ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " finishes, it would seem like all its inner variables would be discarded and GC'd (garbage collected). The inner function is the only thing that seems to be returned and preserved. But here's where the behavior differs in ways we can start to observe.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "While ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " does receive a single argument as the parameter named ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it also makes reference to both ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ", identifiers which come from the enclosing scope of ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Each of those references from the inner function to the variable in an outer scope is called a ", "type": "text"}, {"text": "closure", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". In academic terms, each instance of ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "closes over", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the outer variables ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So what do those closures do here, in a concrete, observable sense?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure allows ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " to continue to access those outer variables even after the outer scope is finished (when each call to ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " completes). Instead of the instances of ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " being GC'd, they stay around in memory. At a later time when either instance of the ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is invoked, those variables are still there, holding their current values.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If JS functions did not have closure, the completion of each ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call would immediately tear down its scope and GC the ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables. When we later called one of the ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " functions, what would then happen?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " tried to access what it thought was a BLUE(2) marble, but that marble did not actually exist (anymore), the reasonable assumption is we should get a ", "type": "text"}, {"text": "ReferenceError", "type": "text", "marks": [{"type": "code"}]}, {"text": ", right?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But we don't get an error. The fact that the execution of ", "type": "text"}, {"text": "chosenStudents[0](\"Hello\")", "type": "text", "marks": [{"type": "code"}]}, {"text": " works and returns us the message \"Hello, Sarah!\", means it was still able to access the ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables. This is a direct observation of closure!", "type": "text"}]}]}, "article_text": "See the Closure\n\nClosure is originally a mathematical concept, from lambda calculus. But I'm not going to list out math formulas or use a bunch of notation and jargon to define it.\n\nInstead, I'm going to focus on a practical perspective. We'll start by defining closure in terms of what we can observe in different behavior of our programs, as opposed to if closure was not present in JS. However, later in this chapter, we're going to flip closure around to look at it from an alternative perspective.\n\nClosure is a behavior of functions and only functions. If you aren't dealing with a function, closure does not apply. An object cannot have closure, nor does a class have closure (though its functions/methods might). Only functions have closure.\n\nFor closure to be observed, a function must be invoked, and specifically it must be invoked in a different branch of the scope chain from where it was originally defined. A function executing in the same scope it was defined would not exhibit any observably different behavior with or without closure being possible; by the observational perspective and definition, that is not closure.\n\nLet's look at some code, annotated with its relevant scope bubble colors (see Chapter 2):\n\n// outer/global scope: RED(1)\n\nfunction lookupStudent(studentID) {\n    // function scope: BLUE(2)\n\n    var students = [\n        { id: 14, name: \"Kyle\" },\n        { id: 73, name: \"Suzy\" },\n        { id: 112, name: \"Frank\" },\n        { id: 6, name: \"Sarah\" }\n    ];\n\n    return function greetStudent(greeting){\n        // function scope: GREEN(3)\n\n        var student = students.find(\n            student => student.id == studentID\n        );\n\n        return `${ greeting }, ${ student.name }!`;\n    };\n}\n\nvar chosenStudents = [\n    lookupStudent(6),\n    lookupStudent(112)\n];\n\n// accessing the function's name:\nchosenStudents[0].name;\n// greetStudent\n\nchosenStudents[0](\"Hello\");\n// Hello, Sarah!\n\nchosenStudents[1](\"Howdy\");\n// Howdy, Frank!\n\nThe first thing to notice about this code is that the lookupStudent(..) outer function creates and returns an inner function called greetStudent(..). lookupStudent(..) is called twice, producing two separate instances of its inner greetStudent(..) function, both of which are saved into the chosenStudents array.\n\nWe verify that's the case by checking the .name property of the returned function saved in chosenStudents[0], and it's indeed an instance of the inner greetStudent(..).\n\nAfter each call to lookupStudent(..) finishes, it would seem like all its inner variables would be discarded and GC'd (garbage collected). The inner function is the only thing that seems to be returned and preserved. But here's where the behavior differs in ways we can start to observe.\n\nWhile greetStudent(..) does receive a single argument as the parameter named greeting, it also makes reference to both students and studentID, identifiers which come from the enclosing scope of lookupStudent(..). Each of those references from the inner function to the variable in an outer scope is called a closure. In academic terms, each instance of greetStudent(..) closes over the outer variables students and studentID.\n\nSo what do those closures do here, in a concrete, observable sense?\n\nClosure allows greetStudent(..) to continue to access those outer variables even after the outer scope is finished (when each call to lookupStudent(..) completes). Instead of the instances of students and studentID being GC'd, they stay around in memory. At a later time when either instance of the greetStudent(..) function is invoked, those variables are still there, holding their current values.\n\nIf JS functions did not have closure, the completion of each lookupStudent(..) call would immediately tear down its scope and GC the students and studentID variables. When we later called one of the greetStudent(..) functions, what would then happen?\n\nIf greetStudent(..) tried to access what it thought was a BLUE(2) marble, but that marble did not actually exist (anymore), the reasonable assumption is we should get a ReferenceError, right?\n\nBut we don't get an error. The fact that the execution of chosenStudents[0](\"Hello\") works and returns us the message \"Hello, Sarah!\", means it was still able to access the students and studentID variables. This is a direct observation of closure!"}, "id": 222, "children": [{"data": {"uuid": "979c67ec-393e-44fe-a760-c57e0bdb61ad", "user": 1, "title": "Pointed Closure", "author": "Kyle Simpson", "created_on": "2023-06-09 01:35:24.867144+00:00", "updated_on": "2023-06-09 01:36:29.542042+00:00", "article_html": "<h3>Pointed Closure</h3><p>Actually, we glossed over a little detail in the previous discussion which I'm guessing many readers missed!</p><p>Because of how terse the syntax for <code>=&gt;</code> arrow functions is, it's easy to forget that they still create a scope (as asserted in \"Arrow Functions\" in Chapter 3). The <code>student =&gt; student.id == studentID</code> arrow function is creating another scope bubble inside the <code>greetStudent(..)</code> function scope.</p><p>Building on the metaphor of colored buckets and bubbles from Chapter 2, if we were creating a colored diagram for this code, there's a fourth scope at this innermost nesting level, so we'd need a fourth color; perhaps we'd pick ORANGE(4) for that scope:</p><pre><code>var student = students.find(\n    student =&gt;\n        // function scope: ORANGE(4)\n        student.id == studentID\n);</code></pre><p>The BLUE(2) <code>studentID</code> reference is actually inside the ORANGE(4) scope rather than the GREEN(3) scope of <code>greetStudent(..)</code>; also, the <code>student</code> parameter of the arrow function is ORANGE(4), shadowing the GREEN(3) <code>student</code>.</p><p>The consequence here is that this arrow function passed as a callback to the array's <code>find(..)</code> method has to hold the closure over <code>studentID</code>, rather than <code>greetStudent(..)</code> holding that closure. That's not too big of a deal, as everything still works as expected. It's just important not to skip over the fact that even tiny arrow functions can get in on the closure party.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Pointed Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Actually, we glossed over a little detail in the previous discussion which I'm guessing many readers missed!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Because of how terse the syntax for ", "type": "text"}, {"text": "=>", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow functions is, it's easy to forget that they still create a scope (as asserted in \"Arrow Functions\" in Chapter 3). The ", "type": "text"}, {"text": "student => student.id == studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow function is creating another scope bubble inside the ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Building on the metaphor of colored buckets and bubbles from Chapter 2, if we were creating a colored diagram for this code, there's a fourth scope at this innermost nesting level, so we'd need a fourth color; perhaps we'd pick ORANGE(4) for that scope:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var student = students.find(\n    student =>\n        // function scope: ORANGE(4)\n        student.id == studentID\n);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The BLUE(2) ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " reference is actually inside the ORANGE(4) scope rather than the GREEN(3) scope of ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "; also, the ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter of the arrow function is ORANGE(4), shadowing the GREEN(3) ", "type": "text"}, {"text": "student", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The consequence here is that this arrow function passed as a callback to the array's ", "type": "text"}, {"text": "find(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method has to hold the closure over ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": ", rather than ", "type": "text"}, {"text": "greetStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " holding that closure. That's not too big of a deal, as everything still works as expected. It's just important not to skip over the fact that even tiny arrow functions can get in on the closure party.", "type": "text"}]}]}, "article_text": "Pointed Closure\n\nActually, we glossed over a little detail in the previous discussion which I'm guessing many readers missed!\n\nBecause of how terse the syntax for => arrow functions is, it's easy to forget that they still create a scope (as asserted in \"Arrow Functions\" in Chapter 3). The student => student.id == studentID arrow function is creating another scope bubble inside the greetStudent(..) function scope.\n\nBuilding on the metaphor of colored buckets and bubbles from Chapter 2, if we were creating a colored diagram for this code, there's a fourth scope at this innermost nesting level, so we'd need a fourth color; perhaps we'd pick ORANGE(4) for that scope:\n\nvar student = students.find(\n    student =>\n        // function scope: ORANGE(4)\n        student.id == studentID\n);\n\nThe BLUE(2) studentID reference is actually inside the ORANGE(4) scope rather than the GREEN(3) scope of greetStudent(..); also, the student parameter of the arrow function is ORANGE(4), shadowing the GREEN(3) student.\n\nThe consequence here is that this arrow function passed as a callback to the array's find(..) method has to hold the closure over studentID, rather than greetStudent(..) holding that closure. That's not too big of a deal, as everything still works as expected. It's just important not to skip over the fact that even tiny arrow functions can get in on the closure party."}, "id": 223}, {"data": {"uuid": "d02c3168-ca1c-4671-b98b-02000ddb304e", "user": 1, "title": "Adding Up Closures", "author": "Kyle Simpson", "created_on": "2023-06-09 01:36:47.062134+00:00", "updated_on": "2023-06-09 01:37:01.747394+00:00", "article_html": "<h3>Adding Up Closures</h3><p>Let's examine one of the canonical examples often cited for closure:</p><pre><code>function adder(num1) {\n    return function addTo(num2){\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51</code></pre><p>Each instance of the inner <code>addTo(..)</code> function is closing over its own <code>num1</code> variable (with values <code>10</code> and <code>42</code>, respectively), so those <code>num1</code>'s don't go away just because <code>adder(..)</code> finishes. When we later invoke one of those inner <code>addTo(..)</code> instances, such as the <code>add10To(15)</code> call, its closed-over <code>num1</code> variable still exists and still holds the original <code>10</code> value. The operation is thus able to perform <code>10 + 15</code> and return the answer <code>25</code>.</p><p>An important detail might have been too easy to gloss over in that previous paragraph, so let's reinforce it: closure is associated with an instance of a function, rather than its single lexical definition. In the preceding snippet, there's just one inner <code>addTo(..)</code> function defined inside <code>adder(..)</code>, so it might seem like that would imply a single closure.</p><p>But actually, every time the outer <code>adder(..)</code> function runs, a <em>new</em> inner <code>addTo(..)</code> function instance is created, and for each new instance, a new closure. So each inner function instance (labeled <code>add10To(..)</code> and <code>add42To(..)</code> in our program) has its own closure over its own instance of the scope environment from that execution of <code>adder(..)</code>.</p><p>Even though closure is based on lexical scope, which is handled at compile time, closure is observed as a runtime characteristic of function instances.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Adding Up Closures", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's examine one of the canonical examples often cited for closure:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function adder(num1) {\n    return function addTo(num2){\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each instance of the inner ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is closing over its own ", "type": "text"}, {"text": "num1", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable (with values ", "type": "text"}, {"text": "10", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "42", "type": "text", "marks": [{"type": "code"}]}, {"text": ", respectively), so those ", "type": "text"}, {"text": "num1", "type": "text", "marks": [{"type": "code"}]}, {"text": "'s don't go away just because ", "type": "text"}, {"text": "adder(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " finishes. When we later invoke one of those inner ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " instances, such as the ", "type": "text"}, {"text": "add10To(15)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call, its closed-over ", "type": "text"}, {"text": "num1", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable still exists and still holds the original ", "type": "text"}, {"text": "10", "type": "text", "marks": [{"type": "code"}]}, {"text": " value. The operation is thus able to perform ", "type": "text"}, {"text": "10 + 15", "type": "text", "marks": [{"type": "code"}]}, {"text": " and return the answer ", "type": "text"}, {"text": "25", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An important detail might have been too easy to gloss over in that previous paragraph, so let's reinforce it: closure is associated with an instance of a function, rather than its single lexical definition. In the preceding snippet, there's just one inner ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function defined inside ", "type": "text"}, {"text": "adder(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so it might seem like that would imply a single closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But actually, every time the outer ", "type": "text"}, {"text": "adder(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function runs, a ", "type": "text"}, {"text": "new", "type": "text", "marks": [{"type": "italic"}]}, {"text": " inner ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function instance is created, and for each new instance, a new closure. So each inner function instance (labeled ", "type": "text"}, {"text": "add10To(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "add42To(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " in our program) has its own closure over its own instance of the scope environment from that execution of ", "type": "text"}, {"text": "adder(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even though closure is based on lexical scope, which is handled at compile time, closure is observed as a runtime characteristic of function instances.", "type": "text"}]}]}, "article_text": "Adding Up Closures\n\nLet's examine one of the canonical examples often cited for closure:\n\nfunction adder(num1) {\n    return function addTo(num2){\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51\n\nEach instance of the inner addTo(..) function is closing over its own num1 variable (with values 10 and 42, respectively), so those num1's don't go away just because adder(..) finishes. When we later invoke one of those inner addTo(..) instances, such as the add10To(15) call, its closed-over num1 variable still exists and still holds the original 10 value. The operation is thus able to perform 10 + 15 and return the answer 25.\n\nAn important detail might have been too easy to gloss over in that previous paragraph, so let's reinforce it: closure is associated with an instance of a function, rather than its single lexical definition. In the preceding snippet, there's just one inner addTo(..) function defined inside adder(..), so it might seem like that would imply a single closure.\n\nBut actually, every time the outer adder(..) function runs, a new inner addTo(..) function instance is created, and for each new instance, a new closure. So each inner function instance (labeled add10To(..) and add42To(..) in our program) has its own closure over its own instance of the scope environment from that execution of adder(..).\n\nEven though closure is based on lexical scope, which is handled at compile time, closure is observed as a runtime characteristic of function instances."}, "id": 224}, {"data": {"uuid": "63e14cce-353e-433b-b351-bd596cd4e9c6", "user": 1, "title": "Live Link, Not a Snapshot", "author": "Kyle Simpson", "created_on": "2023-06-09 01:37:21.394318+00:00", "updated_on": "2023-06-09 01:38:14.132857+00:00", "article_html": "<h3>Live Link, Not a Snapshot</h3><p>In both examples from the previous sections, we <strong>read the value from a variable</strong> that was held in a closure. That makes it feel like closure might be a snapshot of a value at some given moment. Indeed, that's a common misconception.</p><p>Closure is actually a live link, preserving access to the full variable itself. We're not limited to merely reading a value; the closed-over variable can be updated (re-assigned) as well! By closing over a variable in a function, we can keep using that variable (read and write) as long as that function reference exists in the program, and from anywhere we want to invoke that function. This is why closure is such a powerful technique used widely across so many areas of programming!</p><p>Figure 4 depicts the function instances and scope links:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig4.png\"><p><em>Fig. 4: Visualizing Closures</em></p><p>As shown in Figure 4, each call to <code>adder(..)</code> creates a new BLUE(2) scope containing a <code>num1</code> variable, as well as a new instance of <code>addTo(..)</code> function as a GREEN(3) scope. Notice that the function instances (<code>addTo10(..)</code> and <code>addTo42(..)</code>) are present in and invoked from the RED(1) scope.</p><p>Now let's examine an example where the closed-over variable is updated:</p><pre><code>function makeCounter() {\n    var count = 0;\n\n    return function getCurrent() {\n        count = count + 1;\n        return count;\n    };\n}\n\nvar hits = makeCounter();\n\n// later\n\nhits();     // 1\n\n// later\n\nhits();     // 2\nhits();     // 3</code></pre><p>The <code>count</code> variable is closed over by the inner <code>getCurrent()</code> function, which keeps it around instead of it being subjected to GC. The <code>hits()</code> function calls access <em>and</em> update this variable, returning an incrementing count each time.</p><p>Though the enclosing scope of a closure is typically from a function, that's not actually required; there only needs to be an inner function present inside an outer scope:</p><pre><code>var hits;\n{   // an outer scope (but not a function)\n    let count = 0;\n    hits = function getCurrent(){\n        count = count + 1;\n        return count;\n    };\n}\nhits();     // 1\nhits();     // 2\nhits();     // 3</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>I deliberately defined <code>getCurrent()</code> as a <code>function</code> expression instead of a <code>function</code> declaration. This isn't about closure, but with the dangerous quirks of FiB (Chapter 6).</p></td></tr></tbody></table><p>Because it's so common to mistake closure as value-oriented instead of variable-oriented, developers sometimes get tripped up trying to use closure to snapshot-preserve a value from some moment in time. Consider:</p><pre><code>var studentName = \"Frank\";\n\nvar greeting = function hello() {\n    // we are closing over `studentName`,\n    // not \"Frank\"\n    console.log(\n        `Hello, ${ studentName }!`\n    );\n}\n\n// later\n\nstudentName = \"Suzy\";\n\n// later\n\ngreeting();\n// Hello, Suzy!</code></pre><p>By defining <code>greeting()</code> (aka, <code>hello()</code>) when <code>studentName</code> holds the value <code>\"Frank\"</code> (before the re-assignment to <code>\"Suzy\"</code>), the mistaken assumption is often that the closure will capture <code>\"Frank\"</code>. But <code>greeting()</code> is closed over the variable <code>studentName</code>, not its value. Whenever <code>greeting()</code> is invoked, the current value of the variable (<code>\"Suzy\"</code>, in this case) is reflected.</p><p>The classic illustration of this mistake is defining functions inside a loop:</p><pre><code>var keeps = [];\n\nfor (var i = 0; i &lt; 3; i++) {\n    keeps[i] = function keepI(){\n        // closure over `i`\n        return i;\n    };\n}\n\nkeeps[0]();   // 3 -- WHY!?\nkeeps[1]();   // 3\nkeeps[2]();   // 3</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>This kind of closure illustration typically uses a <code>setTimeout(..)</code> or some other callback like an event handler, inside the loop. I've simplified the example by storing function references in an array, so that we don't need to consider asynchronous timing in our analysis. The closure principle is the same, regardless.</p></td></tr></tbody></table><p>You might have expected the <code>keeps[0]()</code> invocation to return <code>0</code>, since that function was created during the first iteration of the loop when <code>i</code> was <code>0</code>. But again, that assumption stems from thinking of closure as value-oriented rather than variable-oriented.</p><p>Something about the structure of a <code>for</code>-loop can trick us into thinking that each iteration gets its own new <code>i</code> variable; in fact, this program only has one <code>i</code> since it was declared with <code>var</code>.</p><p>Each saved function returns <code>3</code>, because by the end of the loop, the single <code>i</code> variable in the program has been assigned <code>3</code>. Each of the three functions in the <code>keeps</code> array do have individual closures, but they're all closed over that same shared <code>i</code> variable.</p><p>Of course, a single variable can only ever hold one value at any given moment. So if you want to preserve multiple values, you need a different variable for each.</p><p>How could we do that in the loop snippet? Let's create a new variable for each iteration:</p><pre><code>var keeps = [];\n\nfor (var i = 0; i &lt; 3; i++) {\n    // new `j` created each iteration, which gets\n    // a copy of the value of `i` at this moment\n    let j = i;\n\n    // the `i` here isn't being closed over, so\n    // it's fine to immediately use its current\n    // value in each loop iteration\n    keeps[i] = function keepEachJ(){\n        // close over `j`, not `i`!\n        return j;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2</code></pre><p>Each function is now closed over a separate (new) variable from each iteration, even though all of them are named <code>j</code>. And each <code>j</code> gets a copy of the value of <code>i</code> at that point in the loop iteration; that <code>j</code> never gets re-assigned. So all three functions now return their expected values: <code>0</code>, <code>1</code>, and <code>2</code>!</p><p>Again remember, even if we were using asynchrony in this program, such as passing each inner <code>keepEachJ()</code> function into <code>setTimeout(..)</code> or some event handler subscription, the same kind of closure behavior would still be observed.</p><p>Recall the \"Loops\" section in Chapter 5, which illustrates how a <code>let</code> declaration in a <code>for</code> loop actually creates not just one variable for the loop, but actually creates a new variable for <em>each iteration</em> of the loop. That trick/quirk is exactly what we need for our loop closures:</p><pre><code>var keeps = [];\n\nfor (let i = 0; i &lt; 3; i++) {\n    // the `let i` gives us a new `i` for\n    // each iteration, automatically!\n    keeps[i] = function keepEachI(){\n        return i;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2</code></pre><p>Since we're using <code>let</code>, three <code>i</code>'s are created, one for each loop, so each of the three closures <em>just work</em> as expected.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Live Link, Not a Snapshot", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In both examples from the previous sections, we ", "type": "text"}, {"text": "read the value from a variable", "type": "text", "marks": [{"type": "bold"}]}, {"text": " that was held in a closure. That makes it feel like closure might be a snapshot of a value at some given moment. Indeed, that's a common misconception.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is actually a live link, preserving access to the full variable itself. We're not limited to merely reading a value; the closed-over variable can be updated (re-assigned) as well! By closing over a variable in a function, we can keep using that variable (read and write) as long as that function reference exists in the program, and from anywhere we want to invoke that function. This is why closure is such a powerful technique used widely across so many areas of programming!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Figure 4 depicts the function instances and scope links:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig4.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 4: Visualizing Closures", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "paragraph", "content": [{"text": "As shown in Figure 4, each call to ", "type": "text"}, {"text": "adder(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " creates a new BLUE(2) scope containing a ", "type": "text"}, {"text": "num1", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable, as well as a new instance of ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function as a GREEN(3) scope. Notice that the function instances (", "type": "text"}, {"text": "addTo10(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "addTo42(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ") are present in and invoked from the RED(1) scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now let's examine an example where the closed-over variable is updated:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function makeCounter() {\n    var count = 0;\n\n    return function getCurrent() {\n        count = count + 1;\n        return count;\n    };\n}\n\nvar hits = makeCounter();\n\n// later\n\nhits();     // 1\n\n// later\n\nhits();     // 2\nhits();     // 3", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "count", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable is closed over by the inner ", "type": "text"}, {"text": "getCurrent()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, which keeps it around instead of it being subjected to GC. The ", "type": "text"}, {"text": "hits()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function calls access ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " update this variable, returning an incrementing count each time.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though the enclosing scope of a closure is typically from a function, that's not actually required; there only needs to be an inner function present inside an outer scope:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var hits;\n{   // an outer scope (but not a function)\n    let count = 0;\n    hits = function getCurrent(){\n        count = count + 1;\n        return count;\n    };\n}\nhits();     // 1\nhits();     // 2\nhits();     // 3", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "I deliberately defined ", "type": "text"}, {"text": "getCurrent()", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression instead of a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration. This isn't about closure, but with the dangerous quirks of FiB (Chapter 6).", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Because it's so common to mistake closure as value-oriented instead of variable-oriented, developers sometimes get tripped up trying to use closure to snapshot-preserve a value from some moment in time. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var studentName = \"Frank\";\n\nvar greeting = function hello() {\n    // we are closing over `studentName`,\n    // not \"Frank\"\n    console.log(\n        `Hello, ${ studentName }!`\n    );\n}\n\n// later\n\nstudentName = \"Suzy\";\n\n// later\n\ngreeting();\n// Hello, Suzy!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By defining ", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": " (aka, ", "type": "text"}, {"text": "hello()", "type": "text", "marks": [{"type": "code"}]}, {"text": ") when ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " holds the value ", "type": "text"}, {"text": "\"Frank\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " (before the re-assignment to ", "type": "text"}, {"text": "\"Suzy\"", "type": "text", "marks": [{"type": "code"}]}, {"text": "), the mistaken assumption is often that the closure will capture ", "type": "text"}, {"text": "\"Frank\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But ", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": " is closed over the variable ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": ", not its value. Whenever ", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": " is invoked, the current value of the variable (", "type": "text"}, {"text": "\"Suzy\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", in this case) is reflected.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The classic illustration of this mistake is defining functions inside a loop:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keeps = [];\n\nfor (var i = 0; i < 3; i++) {\n    keeps[i] = function keepI(){\n        // closure over `i`\n        return i;\n    };\n}\n\nkeeps[0]();   // 3 -- WHY!?\nkeeps[1]();   // 3\nkeeps[2]();   // 3", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "This kind of closure illustration typically uses a ", "type": "text"}, {"text": "setTimeout(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " or some other callback like an event handler, inside the loop. I've simplified the example by storing function references in an array, so that we don't need to consider asynchronous timing in our analysis. The closure principle is the same, regardless.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "You might have expected the ", "type": "text"}, {"text": "keeps[0]()", "type": "text", "marks": [{"type": "code"}]}, {"text": " invocation to return ", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": ", since that function was created during the first iteration of the loop when ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " was ", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But again, that assumption stems from thinking of closure as value-oriented rather than variable-oriented.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Something about the structure of a ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": "-loop can trick us into thinking that each iteration gets its own new ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable; in fact, this program only has one ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " since it was declared with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each saved function returns ", "type": "text"}, {"text": "3", "type": "text", "marks": [{"type": "code"}]}, {"text": ", because by the end of the loop, the single ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable in the program has been assigned ", "type": "text"}, {"text": "3", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Each of the three functions in the ", "type": "text"}, {"text": "keeps", "type": "text", "marks": [{"type": "code"}]}, {"text": " array do have individual closures, but they're all closed over that same shared ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Of course, a single variable can only ever hold one value at any given moment. So if you want to preserve multiple values, you need a different variable for each.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "How could we do that in the loop snippet? Let's create a new variable for each iteration:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keeps = [];\n\nfor (var i = 0; i < 3; i++) {\n    // new `j` created each iteration, which gets\n    // a copy of the value of `i` at this moment\n    let j = i;\n\n    // the `i` here isn't being closed over, so\n    // it's fine to immediately use its current\n    // value in each loop iteration\n    keeps[i] = function keepEachJ(){\n        // close over `j`, not `i`!\n        return j;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each function is now closed over a separate (new) variable from each iteration, even though all of them are named ", "type": "text"}, {"text": "j", "type": "text", "marks": [{"type": "code"}]}, {"text": ". And each ", "type": "text"}, {"text": "j", "type": "text", "marks": [{"type": "code"}]}, {"text": " gets a copy of the value of ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " at that point in the loop iteration; that ", "type": "text"}, {"text": "j", "type": "text", "marks": [{"type": "code"}]}, {"text": " never gets re-assigned. So all three functions now return their expected values: ", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "2", "type": "text", "marks": [{"type": "code"}]}, {"text": "!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Again remember, even if we were using asynchrony in this program, such as passing each inner ", "type": "text"}, {"text": "keepEachJ()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function into ", "type": "text"}, {"text": "setTimeout(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " or some event handler subscription, the same kind of closure behavior would still be observed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall the \"Loops\" section in Chapter 5, which illustrates how a ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration in a ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop actually creates not just one variable for the loop, but actually creates a new variable for ", "type": "text"}, {"text": "each iteration", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of the loop. That trick/quirk is exactly what we need for our loop closures:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var keeps = [];\n\nfor (let i = 0; i < 3; i++) {\n    // the `let i` gives us a new `i` for\n    // each iteration, automatically!\n    keeps[i] = function keepEachI(){\n        return i;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since we're using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", three ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": "'s are created, one for each loop, so each of the three closures ", "type": "text"}, {"text": "just work", "type": "text", "marks": [{"type": "italic"}]}, {"text": " as expected.", "type": "text"}]}]}, "article_text": "Live Link, Not a Snapshot\n\nIn both examples from the previous sections, we read the value from a variable that was held in a closure. That makes it feel like closure might be a snapshot of a value at some given moment. Indeed, that's a common misconception.\n\nClosure is actually a live link, preserving access to the full variable itself. We're not limited to merely reading a value; the closed-over variable can be updated (re-assigned) as well! By closing over a variable in a function, we can keep using that variable (read and write) as long as that function reference exists in the program, and from anywhere we want to invoke that function. This is why closure is such a powerful technique used widely across so many areas of programming!\n\nFigure 4 depicts the function instances and scope links:\n\nFig. 4: Visualizing Closures\n\nAs shown in Figure 4, each call to adder(..) creates a new BLUE(2) scope containing a num1 variable, as well as a new instance of addTo(..) function as a GREEN(3) scope. Notice that the function instances (addTo10(..) and addTo42(..)) are present in and invoked from the RED(1) scope.\n\nNow let's examine an example where the closed-over variable is updated:\n\nfunction makeCounter() {\n    var count = 0;\n\n    return function getCurrent() {\n        count = count + 1;\n        return count;\n    };\n}\n\nvar hits = makeCounter();\n\n// later\n\nhits();     // 1\n\n// later\n\nhits();     // 2\nhits();     // 3\n\nThe count variable is closed over by the inner getCurrent() function, which keeps it around instead of it being subjected to GC. The hits() function calls access and update this variable, returning an incrementing count each time.\n\nThough the enclosing scope of a closure is typically from a function, that's not actually required; there only needs to be an inner function present inside an outer scope:\n\nvar hits;\n{   // an outer scope (but not a function)\n    let count = 0;\n    hits = function getCurrent(){\n        count = count + 1;\n        return count;\n    };\n}\nhits();     // 1\nhits();     // 2\nhits();     // 3\n\nNOTE:\n\nI deliberately defined getCurrent() as a function expression instead of a function declaration. This isn't about closure, but with the dangerous quirks of FiB (Chapter 6).\n\nBecause it's so common to mistake closure as value-oriented instead of variable-oriented, developers sometimes get tripped up trying to use closure to snapshot-preserve a value from some moment in time. Consider:\n\nvar studentName = \"Frank\";\n\nvar greeting = function hello() {\n    // we are closing over `studentName`,\n    // not \"Frank\"\n    console.log(\n        `Hello, ${ studentName }!`\n    );\n}\n\n// later\n\nstudentName = \"Suzy\";\n\n// later\n\ngreeting();\n// Hello, Suzy!\n\nBy defining greeting() (aka, hello()) when studentName holds the value \"Frank\" (before the re-assignment to \"Suzy\"), the mistaken assumption is often that the closure will capture \"Frank\". But greeting() is closed over the variable studentName, not its value. Whenever greeting() is invoked, the current value of the variable (\"Suzy\", in this case) is reflected.\n\nThe classic illustration of this mistake is defining functions inside a loop:\n\nvar keeps = [];\n\nfor (var i = 0; i < 3; i++) {\n    keeps[i] = function keepI(){\n        // closure over `i`\n        return i;\n    };\n}\n\nkeeps[0]();   // 3 -- WHY!?\nkeeps[1]();   // 3\nkeeps[2]();   // 3\n\nNOTE:\n\nThis kind of closure illustration typically uses a setTimeout(..) or some other callback like an event handler, inside the loop. I've simplified the example by storing function references in an array, so that we don't need to consider asynchronous timing in our analysis. The closure principle is the same, regardless.\n\nYou might have expected the keeps[0]() invocation to return 0, since that function was created during the first iteration of the loop when i was 0. But again, that assumption stems from thinking of closure as value-oriented rather than variable-oriented.\n\nSomething about the structure of a for-loop can trick us into thinking that each iteration gets its own new i variable; in fact, this program only has one i since it was declared with var.\n\nEach saved function returns 3, because by the end of the loop, the single i variable in the program has been assigned 3. Each of the three functions in the keeps array do have individual closures, but they're all closed over that same shared i variable.\n\nOf course, a single variable can only ever hold one value at any given moment. So if you want to preserve multiple values, you need a different variable for each.\n\nHow could we do that in the loop snippet? Let's create a new variable for each iteration:\n\nvar keeps = [];\n\nfor (var i = 0; i < 3; i++) {\n    // new `j` created each iteration, which gets\n    // a copy of the value of `i` at this moment\n    let j = i;\n\n    // the `i` here isn't being closed over, so\n    // it's fine to immediately use its current\n    // value in each loop iteration\n    keeps[i] = function keepEachJ(){\n        // close over `j`, not `i`!\n        return j;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2\n\nEach function is now closed over a separate (new) variable from each iteration, even though all of them are named j. And each j gets a copy of the value of i at that point in the loop iteration; that j never gets re-assigned. So all three functions now return their expected values: 0, 1, and 2!\n\nAgain remember, even if we were using asynchrony in this program, such as passing each inner keepEachJ() function into setTimeout(..) or some event handler subscription, the same kind of closure behavior would still be observed.\n\nRecall the \"Loops\" section in Chapter 5, which illustrates how a let declaration in a for loop actually creates not just one variable for the loop, but actually creates a new variable for each iteration of the loop. That trick/quirk is exactly what we need for our loop closures:\n\nvar keeps = [];\n\nfor (let i = 0; i < 3; i++) {\n    // the `let i` gives us a new `i` for\n    // each iteration, automatically!\n    keeps[i] = function keepEachI(){\n        return i;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2\n\nSince we're using let, three i's are created, one for each loop, so each of the three closures just work as expected."}, "id": 225}, {"data": {"uuid": "7811d8c6-1fce-4ac0-94be-513aa74815db", "user": 1, "title": "Common Closures: Ajax and Events", "author": "Kyle Simpson", "created_on": "2023-06-09 01:38:37.954344+00:00", "updated_on": "2023-06-09 01:38:56.261104+00:00", "article_html": "<h3>Common Closures: Ajax and Events</h3><p>Closure is most commonly encountered with callbacks:</p><pre><code>function lookupStudentRecord(studentID) {\n    ajax(\n        `https://some.api/student/${ studentID }`,\n        function onRecord(record) {\n            console.log(\n                `${ record.name } (${ studentID })`\n            );\n        }\n    );\n}\n\nlookupStudentRecord(114);\n// Frank (114)</code></pre><p>The <code>onRecord(..)</code> callback is going to be invoked at some point in the future, after the response from the Ajax call comes back. This invocation will happen from the internals of the <code>ajax(..)</code> utility, wherever that comes from. Furthermore, when that happens, the <code>lookupStudentRecord(..)</code> call will long since have completed.</p><p>Why then is <code>studentID</code> still around and accessible to the callback? Closure.</p><p>Event handlers are another common usage of closure:</p><pre><code>function listenForClicks(btn,label) {\n    btn.addEventListener(\"click\",function onClick(){\n        console.log(\n            `The ${ label } button was clicked!`\n        );\n    });\n}\n\nvar submitBtn = document.getElementById(\"submit-btn\");\n\nlistenForClicks(submitBtn,\"Checkout\");</code></pre><p>The <code>label</code> parameter is closed over by the <code>onClick(..)</code> event handler callback. When the button is clicked, <code>label</code> still exists to be used. This is closure.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Common Closures: Ajax and Events", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is most commonly encountered with callbacks:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function lookupStudentRecord(studentID) {\n    ajax(\n        `https://some.api/student/${ studentID }`,\n        function onRecord(record) {\n            console.log(\n                `${ record.name } (${ studentID })`\n            );\n        }\n    );\n}\n\nlookupStudentRecord(114);\n// Frank (114)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "onRecord(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " callback is going to be invoked at some point in the future, after the response from the Ajax call comes back. This invocation will happen from the internals of the ", "type": "text"}, {"text": "ajax(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility, wherever that comes from. Furthermore, when that happens, the ", "type": "text"}, {"text": "lookupStudentRecord(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call will long since have completed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why then is ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " still around and accessible to the callback? Closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Event handlers are another common usage of closure:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function listenForClicks(btn,label) {\n    btn.addEventListener(\"click\",function onClick(){\n        console.log(\n            `The ${ label } button was clicked!`\n        );\n    });\n}\n\nvar submitBtn = document.getElementById(\"submit-btn\");\n\nlistenForClicks(submitBtn,\"Checkout\");", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "label", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter is closed over by the ", "type": "text"}, {"text": "onClick(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " event handler callback. When the button is clicked, ", "type": "text"}, {"text": "label", "type": "text", "marks": [{"type": "code"}]}, {"text": " still exists to be used. This is closure.", "type": "text"}]}]}, "article_text": "Common Closures: Ajax and Events\n\nClosure is most commonly encountered with callbacks:\n\nfunction lookupStudentRecord(studentID) {\n    ajax(\n        `https://some.api/student/${ studentID }`,\n        function onRecord(record) {\n            console.log(\n                `${ record.name } (${ studentID })`\n            );\n        }\n    );\n}\n\nlookupStudentRecord(114);\n// Frank (114)\n\nThe onRecord(..) callback is going to be invoked at some point in the future, after the response from the Ajax call comes back. This invocation will happen from the internals of the ajax(..) utility, wherever that comes from. Furthermore, when that happens, the lookupStudentRecord(..) call will long since have completed.\n\nWhy then is studentID still around and accessible to the callback? Closure.\n\nEvent handlers are another common usage of closure:\n\nfunction listenForClicks(btn,label) {\n    btn.addEventListener(\"click\",function onClick(){\n        console.log(\n            `The ${ label } button was clicked!`\n        );\n    });\n}\n\nvar submitBtn = document.getElementById(\"submit-btn\");\n\nlistenForClicks(submitBtn,\"Checkout\");\n\nThe label parameter is closed over by the onClick(..) event handler callback. When the button is clicked, label still exists to be used. This is closure."}, "id": 226}, {"data": {"uuid": "b52337a7-cff4-49dd-9a72-cae0907bb6bb", "user": 1, "title": "What If I Can't See It?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:39:17.083286+00:00", "updated_on": "2023-06-09 01:39:42.968028+00:00", "article_html": "<h3>What If I Can't See It?</h3><p>You've probably heard this common adage:</p><blockquote><p>If a tree falls in the forest but nobody is around to hear it, does it make a sound?</p></blockquote><p>It's a silly bit of philosophical gymnastics. Of course from a scientific perspective, sound waves are created. But the real point: <em>does it matter</em> if the sound happens?</p><p>Remember, the emphasis in our definition of closure is observability. If a closure exists (in a technical, implementation, or academic sense) but it cannot be observed in our programs, <em>does it matter?</em> No.</p><p>To reinforce this point, let's look at some examples that are <em>not</em> observably based on closure.</p><p>For example, invoking a function that makes use of lexical scope lookup:</p><pre><code>function say(myName) {\n    var greeting = \"Hello\";\n    output();\n\n    function output() {\n        console.log(\n            `${ greeting }, ${ myName }!`\n        );\n    }\n}\n\nsay(\"Kyle\");\n// Hello, Kyle!</code></pre><p>The inner function <code>output()</code> accesses the variables <code>greeting</code> and <code>myName</code> from its enclosing scope. But the invocation of <code>output()</code> happens in that same scope, where of course <code>greeting</code> and <code>myName</code> are still available; that's just lexical scope, not closure.</p><p>Any lexically scoped language whose functions didn't support closure would still behave this same way.</p><p>In fact, global scope variables essentially cannot be (observably) closed over, because they're always accessible from everywhere. No function can ever be invoked in any part of the scope chain that is not a descendant of the global scope.</p><p>Consider:</p><pre><code>var students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getFirstStudent() {\n    return function firstStudent(){\n        return students[0].name;\n    };\n}\n\nvar student = getFirstStudent();\n\nstudent();\n// Kyle</code></pre><p>The inner <code>firstStudent()</code> function does reference <code>students</code>, which is a variable outside its own scope. But since <code>students</code> happens to be from the global scope, no matter where that function is invoked in the program, its ability to access <code>students</code> is nothing more special than normal lexical scope.</p><p>All function invocations can access global variables, regardless of whether closure is supported by the language or not. Global variables don't need to be closed over.</p><p>Variables that are merely present but never accessed don't result in closure:</p><pre><code>function lookupStudent(studentID) {\n    return function nobody(){\n        var msg = \"Nobody's here yet.\";\n        console.log(msg);\n    };\n}\n\nvar student = lookupStudent(112);\n\nstudent();\n// Nobody's here yet.</code></pre><p>The inner function <code>nobody()</code> doesn't close over any outer variables\u2014it only uses its own variable <code>msg</code>. Even though <code>studentID</code> is present in the enclosing scope, <code>studentID</code> is not referred to by <code>nobody()</code>. The JS engine doesn't need to keep <code>studentID</code> around after <code>lookupStudent(..)</code> has finished running, so GC wants to clean up that memory!</p><p>Whether JS functions support closure or not, this program would behave the same. Therefore, no observed closure here.</p><p>If there's no function invocation, closure can't be observed:</p><pre><code>function greetStudent(studentName) {\n    return function greeting(){\n        console.log(\n            `Hello, ${ studentName }!`\n        );\n    };\n}\n\ngreetStudent(\"Kyle\");\n\n// nothing else happens</code></pre><p>This one's tricky, because the outer function definitely does get invoked. But the inner function is the one that <em>could</em> have had closure, and yet it's never invoked; the returned function here is just thrown away. So even if technically the JS engine created closure for a brief moment, it was not observed in any meaningful way in this program.</p><p>A tree may have fallen... but we didn't hear it, so we don't care.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "What If I Can't See It?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You've probably heard this common adage:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "If a tree falls in the forest but nobody is around to hear it, does it make a sound?", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "It's a silly bit of philosophical gymnastics. Of course from a scientific perspective, sound waves are created. But the real point: ", "type": "text"}, {"text": "does it matter", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if the sound happens?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember, the emphasis in our definition of closure is observability. If a closure exists (in a technical, implementation, or academic sense) but it cannot be observed in our programs, ", "type": "text"}, {"text": "does it matter?", "type": "text", "marks": [{"type": "italic"}]}, {"text": " No.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To reinforce this point, let's look at some examples that are ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " observably based on closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, invoking a function that makes use of lexical scope lookup:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function say(myName) {\n    var greeting = \"Hello\";\n    output();\n\n    function output() {\n        console.log(\n            `${ greeting }, ${ myName }!`\n        );\n    }\n}\n\nsay(\"Kyle\");\n// Hello, Kyle!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The inner function ", "type": "text"}, {"text": "output()", "type": "text", "marks": [{"type": "code"}]}, {"text": " accesses the variables ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " from its enclosing scope. But the invocation of ", "type": "text"}, {"text": "output()", "type": "text", "marks": [{"type": "code"}]}, {"text": " happens in that same scope, where of course ", "type": "text"}, {"text": "greeting", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " are still available; that's just lexical scope, not closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Any lexically scoped language whose functions didn't support closure would still behave this same way.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In fact, global scope variables essentially cannot be (observably) closed over, because they're always accessible from everywhere. No function can ever be invoked in any part of the scope chain that is not a descendant of the global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getFirstStudent() {\n    return function firstStudent(){\n        return students[0].name;\n    };\n}\n\nvar student = getFirstStudent();\n\nstudent();\n// Kyle", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The inner ", "type": "text"}, {"text": "firstStudent()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function does reference ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which is a variable outside its own scope. But since ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " happens to be from the global scope, no matter where that function is invoked in the program, its ability to access ", "type": "text"}, {"text": "students", "type": "text", "marks": [{"type": "code"}]}, {"text": " is nothing more special than normal lexical scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All function invocations can access global variables, regardless of whether closure is supported by the language or not. Global variables don't need to be closed over.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Variables that are merely present but never accessed don't result in closure:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function lookupStudent(studentID) {\n    return function nobody(){\n        var msg = \"Nobody's here yet.\";\n        console.log(msg);\n    };\n}\n\nvar student = lookupStudent(112);\n\nstudent();\n// Nobody's here yet.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The inner function ", "type": "text"}, {"text": "nobody()", "type": "text", "marks": [{"type": "code"}]}, {"text": " doesn't close over any outer variables\u2014it only uses its own variable ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Even though ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " is present in the enclosing scope, ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not referred to by ", "type": "text"}, {"text": "nobody()", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The JS engine doesn't need to keep ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " around after ", "type": "text"}, {"text": "lookupStudent(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " has finished running, so GC wants to clean up that memory!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Whether JS functions support closure or not, this program would behave the same. Therefore, no observed closure here.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If there's no function invocation, closure can't be observed:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function greetStudent(studentName) {\n    return function greeting(){\n        console.log(\n            `Hello, ${ studentName }!`\n        );\n    };\n}\n\ngreetStudent(\"Kyle\");\n\n// nothing else happens", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This one's tricky, because the outer function definitely does get invoked. But the inner function is the one that ", "type": "text"}, {"text": "could", "type": "text", "marks": [{"type": "italic"}]}, {"text": " have had closure, and yet it's never invoked; the returned function here is just thrown away. So even if technically the JS engine created closure for a brief moment, it was not observed in any meaningful way in this program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A tree may have fallen... but we didn't hear it, so we don't care.", "type": "text"}]}]}, "article_text": "What If I Can't See It?\n\nYou've probably heard this common adage:\n\nIf a tree falls in the forest but nobody is around to hear it, does it make a sound?\n\nIt's a silly bit of philosophical gymnastics. Of course from a scientific perspective, sound waves are created. But the real point: does it matter if the sound happens?\n\nRemember, the emphasis in our definition of closure is observability. If a closure exists (in a technical, implementation, or academic sense) but it cannot be observed in our programs, does it matter? No.\n\nTo reinforce this point, let's look at some examples that are not observably based on closure.\n\nFor example, invoking a function that makes use of lexical scope lookup:\n\nfunction say(myName) {\n    var greeting = \"Hello\";\n    output();\n\n    function output() {\n        console.log(\n            `${ greeting }, ${ myName }!`\n        );\n    }\n}\n\nsay(\"Kyle\");\n// Hello, Kyle!\n\nThe inner function output() accesses the variables greeting and myName from its enclosing scope. But the invocation of output() happens in that same scope, where of course greeting and myName are still available; that's just lexical scope, not closure.\n\nAny lexically scoped language whose functions didn't support closure would still behave this same way.\n\nIn fact, global scope variables essentially cannot be (observably) closed over, because they're always accessible from everywhere. No function can ever be invoked in any part of the scope chain that is not a descendant of the global scope.\n\nConsider:\n\nvar students = [\n    { id: 14, name: \"Kyle\" },\n    { id: 73, name: \"Suzy\" },\n    { id: 112, name: \"Frank\" },\n    { id: 6, name: \"Sarah\" }\n];\n\nfunction getFirstStudent() {\n    return function firstStudent(){\n        return students[0].name;\n    };\n}\n\nvar student = getFirstStudent();\n\nstudent();\n// Kyle\n\nThe inner firstStudent() function does reference students, which is a variable outside its own scope. But since students happens to be from the global scope, no matter where that function is invoked in the program, its ability to access students is nothing more special than normal lexical scope.\n\nAll function invocations can access global variables, regardless of whether closure is supported by the language or not. Global variables don't need to be closed over.\n\nVariables that are merely present but never accessed don't result in closure:\n\nfunction lookupStudent(studentID) {\n    return function nobody(){\n        var msg = \"Nobody's here yet.\";\n        console.log(msg);\n    };\n}\n\nvar student = lookupStudent(112);\n\nstudent();\n// Nobody's here yet.\n\nThe inner function nobody() doesn't close over any outer variables\u2014it only uses its own variable msg. Even though studentID is present in the enclosing scope, studentID is not referred to by nobody(). The JS engine doesn't need to keep studentID around after lookupStudent(..) has finished running, so GC wants to clean up that memory!\n\nWhether JS functions support closure or not, this program would behave the same. Therefore, no observed closure here.\n\nIf there's no function invocation, closure can't be observed:\n\nfunction greetStudent(studentName) {\n    return function greeting(){\n        console.log(\n            `Hello, ${ studentName }!`\n        );\n    };\n}\n\ngreetStudent(\"Kyle\");\n\n// nothing else happens\n\nThis one's tricky, because the outer function definitely does get invoked. But the inner function is the one that could have had closure, and yet it's never invoked; the returned function here is just thrown away. So even if technically the JS engine created closure for a brief moment, it was not observed in any meaningful way in this program.\n\nA tree may have fallen... but we didn't hear it, so we don't care."}, "id": 227}, {"data": {"uuid": "7249a0f1-3304-433d-bd26-f1bc2d18dafd", "user": 1, "title": "Observable Definition", "author": "Kyle Simpson", "created_on": "2023-06-09 01:40:00.884199+00:00", "updated_on": "2023-06-09 01:40:19.695406+00:00", "article_html": "<h3>Observable Definition</h3><p>We're now ready to define closure:</p><blockquote><p>Closure is observed when a function uses variable(s) from outer scope(s) even while running in a scope where those variable(s) wouldn't be accessible.</p></blockquote><p>The key parts of this definition are:</p><ul><li><p>Must be a function involved</p></li><li><p>Must reference at least one variable from an outer scope</p></li><li><p>Must be invoked in a different branch of the scope chain from the variable(s)</p></li></ul><p>This observation-oriented definition means we shouldn't dismiss closure as some indirect, academic trivia. Instead, we should look and plan for the direct, concrete effects closure has on our program behavior.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Observable Definition", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We're now ready to define closure:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Closure is observed when a function uses variable(s) from outer scope(s) even while running in a scope where those variable(s) wouldn't be accessible.", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "The key parts of this definition are:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Must be a function involved", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Must reference at least one variable from an outer scope", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Must be invoked in a different branch of the scope chain from the variable(s)", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "This observation-oriented definition means we shouldn't dismiss closure as some indirect, academic trivia. Instead, we should look and plan for the direct, concrete effects closure has on our program behavior.", "type": "text"}]}]}, "article_text": "Observable Definition\n\nWe're now ready to define closure:\n\nClosure is observed when a function uses variable(s) from outer scope(s) even while running in a scope where those variable(s) wouldn't be accessible.\n\nThe key parts of this definition are:\n\nMust be a function involved\n\nMust reference at least one variable from an outer scope\n\nMust be invoked in a different branch of the scope chain from the variable(s)\n\nThis observation-oriented definition means we shouldn't dismiss closure as some indirect, academic trivia. Instead, we should look and plan for the direct, concrete effects closure has on our program behavior."}, "id": 228}]}, {"data": {"uuid": "54814494-61c1-4840-b906-845f36ec1401", "user": 1, "title": "The Closure Lifecycle and Garbage Collection (GC)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:40:38.639175+00:00", "updated_on": "2023-06-09 01:40:57.095957+00:00", "article_html": "<h2>The Closure Lifecycle and Garbage Collection (GC)</h2><p>Since closure is inherently tied to a function instance, its closure over a variable lasts as long as there is still a reference to that function.</p><p>If ten functions all close over the same variable, and over time nine of these function references are discarded, the lone remaining function reference still preserves that variable. Once that final function reference is discarded, the last closure over that variable is gone, and the variable itself is GC'd.</p><p>This has an important impact on building efficient and performant programs. Closure can unexpectedly prevent the GC of a variable that you're otherwise done with, which leads to run-away memory usage over time. That's why it's important to discard function references (and thus their closures) when they're not needed anymore.</p><p>Consider:</p><pre><code>function manageBtnClickEvents(btn) {\n    var clickHandlers = [];\n\n    return function listener(cb){\n        if (cb) {\n            let clickHandler =\n                function onClick(evt){\n                    console.log(\"clicked!\");\n                    cb(evt);\n                };\n            clickHandlers.push(clickHandler);\n            btn.addEventListener(\n                \"click\",\n                clickHandler\n            );\n        }\n        else {\n            // passing no callback unsubscribes\n            // all click handlers\n            for (let handler of clickHandlers) {\n                btn.removeEventListener(\n                    \"click\",\n                    handler\n                );\n            }\n\n            clickHandlers = [];\n        }\n    };\n}\n\n// var mySubmitBtn = ..\nvar onSubmit = manageBtnClickEvents(mySubmitBtn);\n\nonSubmit(function checkout(evt){\n    // handle checkout\n});\n\nonSubmit(function trackAction(evt){\n    // log action to analytics\n});\n\n// later, unsubscribe all handlers:\nonSubmit();</code></pre><p>In this program, the inner <code>onClick(..)</code> function holds a closure over the passed in <code>cb</code> (the provided event callback). That means the <code>checkout()</code> and <code>trackAction()</code> function expression references are held via closure (and cannot be GC'd) for as long as these event handlers are subscribed.</p><p>When we call <code>onSubmit()</code> with no input on the last line, all event handlers are unsubscribed, and the <code>clickHandlers</code> array is emptied. Once all click handler function references are discarded, the closures of <code>cb</code> references to <code>checkout()</code> and <code>trackAction()</code> are discarded.</p><p>When considering the overall health and efficiency of the program, unsubscribing an event handler when it's no longer needed can be even more important than the initial subscription!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Closure Lifecycle and Garbage Collection (GC)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since closure is inherently tied to a function instance, its closure over a variable lasts as long as there is still a reference to that function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If ten functions all close over the same variable, and over time nine of these function references are discarded, the lone remaining function reference still preserves that variable. Once that final function reference is discarded, the last closure over that variable is gone, and the variable itself is GC'd.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This has an important impact on building efficient and performant programs. Closure can unexpectedly prevent the GC of a variable that you're otherwise done with, which leads to run-away memory usage over time. That's why it's important to discard function references (and thus their closures) when they're not needed anymore.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function manageBtnClickEvents(btn) {\n    var clickHandlers = [];\n\n    return function listener(cb){\n        if (cb) {\n            let clickHandler =\n                function onClick(evt){\n                    console.log(\"clicked!\");\n                    cb(evt);\n                };\n            clickHandlers.push(clickHandler);\n            btn.addEventListener(\n                \"click\",\n                clickHandler\n            );\n        }\n        else {\n            // passing no callback unsubscribes\n            // all click handlers\n            for (let handler of clickHandlers) {\n                btn.removeEventListener(\n                    \"click\",\n                    handler\n                );\n            }\n\n            clickHandlers = [];\n        }\n    };\n}\n\n// var mySubmitBtn = ..\nvar onSubmit = manageBtnClickEvents(mySubmitBtn);\n\nonSubmit(function checkout(evt){\n    // handle checkout\n});\n\nonSubmit(function trackAction(evt){\n    // log action to analytics\n});\n\n// later, unsubscribe all handlers:\nonSubmit();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this program, the inner ", "type": "text"}, {"text": "onClick(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function holds a closure over the passed in ", "type": "text"}, {"text": "cb", "type": "text", "marks": [{"type": "code"}]}, {"text": " (the provided event callback). That means the ", "type": "text"}, {"text": "checkout()", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "trackAction()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function expression references are held via closure (and cannot be GC'd) for as long as these event handlers are subscribed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When we call ", "type": "text"}, {"text": "onSubmit()", "type": "text", "marks": [{"type": "code"}]}, {"text": " with no input on the last line, all event handlers are unsubscribed, and the ", "type": "text"}, {"text": "clickHandlers", "type": "text", "marks": [{"type": "code"}]}, {"text": " array is emptied. Once all click handler function references are discarded, the closures of ", "type": "text"}, {"text": "cb", "type": "text", "marks": [{"type": "code"}]}, {"text": " references to ", "type": "text"}, {"text": "checkout()", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "trackAction()", "type": "text", "marks": [{"type": "code"}]}, {"text": " are discarded.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When considering the overall health and efficiency of the program, unsubscribing an event handler when it's no longer needed can be even more important than the initial subscription!", "type": "text"}]}]}, "article_text": "The Closure Lifecycle and Garbage Collection (GC)\n\nSince closure is inherently tied to a function instance, its closure over a variable lasts as long as there is still a reference to that function.\n\nIf ten functions all close over the same variable, and over time nine of these function references are discarded, the lone remaining function reference still preserves that variable. Once that final function reference is discarded, the last closure over that variable is gone, and the variable itself is GC'd.\n\nThis has an important impact on building efficient and performant programs. Closure can unexpectedly prevent the GC of a variable that you're otherwise done with, which leads to run-away memory usage over time. That's why it's important to discard function references (and thus their closures) when they're not needed anymore.\n\nConsider:\n\nfunction manageBtnClickEvents(btn) {\n    var clickHandlers = [];\n\n    return function listener(cb){\n        if (cb) {\n            let clickHandler =\n                function onClick(evt){\n                    console.log(\"clicked!\");\n                    cb(evt);\n                };\n            clickHandlers.push(clickHandler);\n            btn.addEventListener(\n                \"click\",\n                clickHandler\n            );\n        }\n        else {\n            // passing no callback unsubscribes\n            // all click handlers\n            for (let handler of clickHandlers) {\n                btn.removeEventListener(\n                    \"click\",\n                    handler\n                );\n            }\n\n            clickHandlers = [];\n        }\n    };\n}\n\n// var mySubmitBtn = ..\nvar onSubmit = manageBtnClickEvents(mySubmitBtn);\n\nonSubmit(function checkout(evt){\n    // handle checkout\n});\n\nonSubmit(function trackAction(evt){\n    // log action to analytics\n});\n\n// later, unsubscribe all handlers:\nonSubmit();\n\nIn this program, the inner onClick(..) function holds a closure over the passed in cb (the provided event callback). That means the checkout() and trackAction() function expression references are held via closure (and cannot be GC'd) for as long as these event handlers are subscribed.\n\nWhen we call onSubmit() with no input on the last line, all event handlers are unsubscribed, and the clickHandlers array is emptied. Once all click handler function references are discarded, the closures of cb references to checkout() and trackAction() are discarded.\n\nWhen considering the overall health and efficiency of the program, unsubscribing an event handler when it's no longer needed can be even more important than the initial subscription!"}, "id": 229, "children": [{"data": {"uuid": "8c43eafb-8a40-4435-9d7b-fef40e60771a", "user": 1, "title": "Per Variable or Per Scope?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:41:16.762033+00:00", "updated_on": "2023-06-09 01:41:45.879595+00:00", "article_html": "<h3>Per Variable or Per Scope?</h3><p>Another question we need to tackle: should we think of closure as applied only to the referenced outer variable(s), or does closure preserve the entire scope chain with all its variables?</p><p>In other words, in the previous event subscription snippet, is the inner <code>onClick(..)</code> function closed over only <code>cb</code>, or is it also closed over <code>clickHandler</code>, <code>clickHandlers</code>, and <code>btn</code>?</p><p>Conceptually, closure is <strong>per variable</strong> rather than <em>per scope</em>. Ajax callbacks, event handlers, and all other forms of function closures are typically assumed to close over only what they explicitly reference.</p><p>But the reality is more complicated than that.</p><p>Another program to consider:</p><pre><code>function manageStudentGrades(studentRecords) {\n    var grades = studentRecords.map(getGrade);\n\n    return addGrade;\n\n    // ************************\n\n    function getGrade(record){\n        return record.grade;\n    }\n\n    function sortAndTrimGradesList() {\n        // sort by grades, descending\n        grades.sort(function desc(g1,g2){\n            return g2 - g1;\n        });\n\n        // only keep the top 10 grades\n        grades = grades.slice(0,10);\n    }\n\n    function addGrade(newGrade) {\n        grades.push(newGrade);\n        sortAndTrimGradesList();\n        return grades;\n    }\n}\n\nvar addNextGrade = manageStudentGrades([\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    // ..many more records..\n    { id: 6, name: \"Sarah\", grade: 91 }\n]);\n\n// later\n\naddNextGrade(81);\naddNextGrade(68);\n// [ .., .., ... ]</code></pre><p>The outer function <code>manageStudentGrades(..)</code> takes a list of student records, and returns an <code>addGrade(..)</code> function reference, which we externally label <code>addNextGrade(..)</code>. Each time we call <code>addNextGrade(..)</code> with a new grade, we get back a current list of the top 10 grades, sorted numerically descending (see <code>sortAndTrimGradesList()</code>).</p><p>From the end of the original <code>manageStudentGrades(..)</code> call, and between the multiple <code>addNextGrade(..)</code> calls, the <code>grades</code> variable is preserved inside <code>addGrade(..)</code> via closure; that's how the running list of top grades is maintained. Remember, it's a closure over the variable <code>grades</code> itself, not the array it holds.</p><p>That's not the only closure involved, however. Can you spot other variables being closed over?</p><p>Did you spot that <code>addGrade(..)</code> references <code>sortAndTrimGradesList</code>? That means it's also closed over that identifier, which happens to hold a reference to the <code>sortAndTrimGradesList()</code> function. That second inner function has to stay around so that <code>addGrade(..)</code> can keep calling it, which also means any variables <em>it</em> closes over stick around\u2014though, in this case, nothing extra is closed over there.</p><p>What else is closed over?</p><p>Consider the <code>getGrade</code> variable (and its function); is it closed over? It's referenced in the outer scope of <code>manageStudentGrades(..)</code> in the <code>.map(getGrade)</code> call. But it's not referenced in <code>addGrade(..)</code> or <code>sortAndTrimGradesList()</code>.</p><p>What about the (potentially) large list of student records we pass in as <code>studentRecords</code>? Is that variable closed over? If it is, the array of student records is never getting GC'd, which leads to this program holding onto a larger amount of memory than we might assume. But if we look closely again, none of the inner functions reference <code>studentRecords</code>.</p><p>According to the <em>per variable</em> definition of closure, since <code>getGrade</code> and <code>studentRecords</code> are <em>not</em> referenced by the inner functions, they're not closed over. They should be freely available for GC right after the <code>manageStudentGrades(..)</code> call completes.</p><p>Indeed, try debugging this code in a recent JS engine, like v8 in Chrome, placing a breakpoint inside the <code>addGrade(..)</code> function. You may notice that the inspector <strong>does not</strong> list the <code>studentRecords</code> variable. That's proof, debugging-wise anyway, that the engine does not maintain <code>studentRecords</code> via closure. Phew!</p><p>But how reliable is this observation as proof? Consider this (rather contrived!) program:</p><pre><code>function storeStudentInfo(id,name,grade) {\n    return function getInfo(whichValue){\n        // warning:\n        //   using `eval(..)` is a bad idea!\n        var val = eval(whichValue);\n        return val;\n    };\n}\n\nvar info = storeStudentInfo(73,\"Suzy\",87);\n\ninfo(\"name\");\n// Suzy\n\ninfo(\"grade\");\n// 87</code></pre><p>Notice that the inner function <code>getInfo(..)</code> is not explicitly closed over any of <code>id</code>, <code>name</code>, or <code>grade</code> variables. And yet, calls to <code>info(..)</code> seem to still be able to access the variables, albeit through use of the <code>eval(..)</code> lexical scope cheat (see Chapter 1).</p><p>So all the variables were definitely preserved via closure, despite not being explicitly referenced by the inner function. So does that disprove the <em>per variable</em> assertion in favor of <em>per scope</em>? Depends.</p><p>Many modern JS engines do apply an <em>optimization</em> that removes any variables from a closure scope that aren't explicitly referenced. However, as we see with <code>eval(..)</code>, there are situations where such an optimization cannot be applied, and the closure scope continues to contain all its original variables. In other words, closure must be <em>per scope</em>, implementation wise, and then an optional optimization trims down the scope to only what was closed over (a similar outcome as <em>per variable</em> closure).</p><p>Even as recent as a few years ago, many JS engines did not apply this optimization; it's possible your websites may still run in such browsers, especially on older or lower-end devices. That means it's possible that long-lived closures such as event handlers may be holding onto memory much longer than we would have assumed.</p><p>And the fact that it's an optional optimization in the first place, rather than a requirement of the specification, means that we shouldn't just casually over-assume its applicability.</p><p>In cases where a variable holds a large value (like an object or array) and that variable is present in a closure scope, if you don't need that value anymore and don't want that memory held, it's safer (memory usage) to manually discard the value rather than relying on closure optimization/GC.</p><p>Let's apply a <em>fix</em> to the earlier <code>manageStudentGrades(..)</code> example to ensure the potentially large array held in <code>studentRecords</code> is not caught up in a closure scope unnecessarily:</p><pre><code>function manageStudentGrades(studentRecords) {\n    var grades = studentRecords.map(getGrade);\n\n    // unset `studentRecords` to prevent unwanted\n    // memory retention in the closure\n    studentRecords = null;\n\n    return addGrade;\n    // ..\n}</code></pre><p>We're not removing <code>studentRecords</code> from the closure scope; that we cannot control. We're ensuring that even if <code>studentRecords</code> remains in the closure scope, that variable is no longer referencing the potentially large array of data; the array can be GC'd.</p><p>Again, in many cases JS might automatically optimize the program to the same effect. But it's still a good habit to be careful and explicitly make sure we don't keep any significant amount of device memory tied up any longer than necessary.</p><p>As a matter of fact, we also technically don't need the function <code>getGrade()</code> anymore after the <code>.map(getGrade)</code> call completes. If profiling our application showed this was a critical area of excess memory use, we could possibly eek out a tiny bit more memory by freeing up that reference so its value isn't tied up either. That's likely unnecessary in this toy example, but this is a general technique to keep in mind if you're optimizing the memory footprint of your application.</p><p>The takeaway: it's important to know where closures appear in our programs, and what variables are included. We should manage these closures carefully so we're only holding onto what's minimally needed and not wasting memory.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Per Variable or Per Scope?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another question we need to tackle: should we think of closure as applied only to the referenced outer variable(s), or does closure preserve the entire scope chain with all its variables?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, in the previous event subscription snippet, is the inner ", "type": "text"}, {"text": "onClick(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function closed over only ", "type": "text"}, {"text": "cb", "type": "text", "marks": [{"type": "code"}]}, {"text": ", or is it also closed over ", "type": "text"}, {"text": "clickHandler", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "clickHandlers", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "btn", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Conceptually, closure is ", "type": "text"}, {"text": "per variable", "type": "text", "marks": [{"type": "bold"}]}, {"text": " rather than ", "type": "text"}, {"text": "per scope", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Ajax callbacks, event handlers, and all other forms of function closures are typically assumed to close over only what they explicitly reference.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But the reality is more complicated than that.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another program to consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function manageStudentGrades(studentRecords) {\n    var grades = studentRecords.map(getGrade);\n\n    return addGrade;\n\n    // ************************\n\n    function getGrade(record){\n        return record.grade;\n    }\n\n    function sortAndTrimGradesList() {\n        // sort by grades, descending\n        grades.sort(function desc(g1,g2){\n            return g2 - g1;\n        });\n\n        // only keep the top 10 grades\n        grades = grades.slice(0,10);\n    }\n\n    function addGrade(newGrade) {\n        grades.push(newGrade);\n        sortAndTrimGradesList();\n        return grades;\n    }\n}\n\nvar addNextGrade = manageStudentGrades([\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    // ..many more records..\n    { id: 6, name: \"Sarah\", grade: 91 }\n]);\n\n// later\n\naddNextGrade(81);\naddNextGrade(68);\n// [ .., .., ... ]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The outer function ", "type": "text"}, {"text": "manageStudentGrades(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " takes a list of student records, and returns an ", "type": "text"}, {"text": "addGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function reference, which we externally label ", "type": "text"}, {"text": "addNextGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Each time we call ", "type": "text"}, {"text": "addNextGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " with a new grade, we get back a current list of the top 10 grades, sorted numerically descending (see ", "type": "text"}, {"text": "sortAndTrimGradesList()", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "From the end of the original ", "type": "text"}, {"text": "manageStudentGrades(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call, and between the multiple ", "type": "text"}, {"text": "addNextGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " calls, the ", "type": "text"}, {"text": "grades", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable is preserved inside ", "type": "text"}, {"text": "addGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " via closure; that's how the running list of top grades is maintained. Remember, it's a closure over the variable ", "type": "text"}, {"text": "grades", "type": "text", "marks": [{"type": "code"}]}, {"text": " itself, not the array it holds.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's not the only closure involved, however. Can you spot other variables being closed over?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Did you spot that ", "type": "text"}, {"text": "addGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " references ", "type": "text"}, {"text": "sortAndTrimGradesList", "type": "text", "marks": [{"type": "code"}]}, {"text": "? That means it's also closed over that identifier, which happens to hold a reference to the ", "type": "text"}, {"text": "sortAndTrimGradesList()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function. That second inner function has to stay around so that ", "type": "text"}, {"text": "addGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " can keep calling it, which also means any variables ", "type": "text"}, {"text": "it", "type": "text", "marks": [{"type": "italic"}]}, {"text": " closes over stick around\u2014though, in this case, nothing extra is closed over there.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What else is closed over?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider the ", "type": "text"}, {"text": "getGrade", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable (and its function); is it closed over? It's referenced in the outer scope of ", "type": "text"}, {"text": "manageStudentGrades(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the ", "type": "text"}, {"text": ".map(getGrade)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call. But it's not referenced in ", "type": "text"}, {"text": "addGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "sortAndTrimGradesList()", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about the (potentially) large list of student records we pass in as ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": "? Is that variable closed over? If it is, the array of student records is never getting GC'd, which leads to this program holding onto a larger amount of memory than we might assume. But if we look closely again, none of the inner functions reference ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "According to the ", "type": "text"}, {"text": "per variable", "type": "text", "marks": [{"type": "italic"}]}, {"text": " definition of closure, since ", "type": "text"}, {"text": "getGrade", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " are ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " referenced by the inner functions, they're not closed over. They should be freely available for GC right after the ", "type": "text"}, {"text": "manageStudentGrades(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call completes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Indeed, try debugging this code in a recent JS engine, like v8 in Chrome, placing a breakpoint inside the ", "type": "text"}, {"text": "addGrade(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function. You may notice that the inspector ", "type": "text"}, {"text": "does not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " list the ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable. That's proof, debugging-wise anyway, that the engine does not maintain ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " via closure. Phew!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But how reliable is this observation as proof? Consider this (rather contrived!) program:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function storeStudentInfo(id,name,grade) {\n    return function getInfo(whichValue){\n        // warning:\n        //   using `eval(..)` is a bad idea!\n        var val = eval(whichValue);\n        return val;\n    };\n}\n\nvar info = storeStudentInfo(73,\"Suzy\",87);\n\ninfo(\"name\");\n// Suzy\n\ninfo(\"grade\");\n// 87", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice that the inner function ", "type": "text"}, {"text": "getInfo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not explicitly closed over any of ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": ", or ", "type": "text"}, {"text": "grade", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables. And yet, calls to ", "type": "text"}, {"text": "info(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " seem to still be able to access the variables, albeit through use of the ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " lexical scope cheat (see Chapter 1).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So all the variables were definitely preserved via closure, despite not being explicitly referenced by the inner function. So does that disprove the ", "type": "text"}, {"text": "per variable", "type": "text", "marks": [{"type": "italic"}]}, {"text": " assertion in favor of ", "type": "text"}, {"text": "per scope", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? Depends.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Many modern JS engines do apply an ", "type": "text"}, {"text": "optimization", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that removes any variables from a closure scope that aren't explicitly referenced. However, as we see with ", "type": "text"}, {"text": "eval(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", there are situations where such an optimization cannot be applied, and the closure scope continues to contain all its original variables. In other words, closure must be ", "type": "text"}, {"text": "per scope", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", implementation wise, and then an optional optimization trims down the scope to only what was closed over (a similar outcome as ", "type": "text"}, {"text": "per variable", "type": "text", "marks": [{"type": "italic"}]}, {"text": " closure).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even as recent as a few years ago, many JS engines did not apply this optimization; it's possible your websites may still run in such browsers, especially on older or lower-end devices. That means it's possible that long-lived closures such as event handlers may be holding onto memory much longer than we would have assumed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And the fact that it's an optional optimization in the first place, rather than a requirement of the specification, means that we shouldn't just casually over-assume its applicability.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In cases where a variable holds a large value (like an object or array) and that variable is present in a closure scope, if you don't need that value anymore and don't want that memory held, it's safer (memory usage) to manually discard the value rather than relying on closure optimization/GC.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's apply a ", "type": "text"}, {"text": "fix", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to the earlier ", "type": "text"}, {"text": "manageStudentGrades(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " example to ensure the potentially large array held in ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not caught up in a closure scope unnecessarily:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function manageStudentGrades(studentRecords) {\n    var grades = studentRecords.map(getGrade);\n\n    // unset `studentRecords` to prevent unwanted\n    // memory retention in the closure\n    studentRecords = null;\n\n    return addGrade;\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We're not removing ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " from the closure scope; that we cannot control. We're ensuring that even if ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " remains in the closure scope, that variable is no longer referencing the potentially large array of data; the array can be GC'd.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Again, in many cases JS might automatically optimize the program to the same effect. But it's still a good habit to be careful and explicitly make sure we don't keep any significant amount of device memory tied up any longer than necessary.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As a matter of fact, we also technically don't need the function ", "type": "text"}, {"text": "getGrade()", "type": "text", "marks": [{"type": "code"}]}, {"text": " anymore after the ", "type": "text"}, {"text": ".map(getGrade)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call completes. If profiling our application showed this was a critical area of excess memory use, we could possibly eek out a tiny bit more memory by freeing up that reference so its value isn't tied up either. That's likely unnecessary in this toy example, but this is a general technique to keep in mind if you're optimizing the memory footprint of your application.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The takeaway: it's important to know where closures appear in our programs, and what variables are included. We should manage these closures carefully so we're only holding onto what's minimally needed and not wasting memory.", "type": "text"}]}]}, "article_text": "Per Variable or Per Scope?\n\nAnother question we need to tackle: should we think of closure as applied only to the referenced outer variable(s), or does closure preserve the entire scope chain with all its variables?\n\nIn other words, in the previous event subscription snippet, is the inner onClick(..) function closed over only cb, or is it also closed over clickHandler, clickHandlers, and btn?\n\nConceptually, closure is per variable rather than per scope. Ajax callbacks, event handlers, and all other forms of function closures are typically assumed to close over only what they explicitly reference.\n\nBut the reality is more complicated than that.\n\nAnother program to consider:\n\nfunction manageStudentGrades(studentRecords) {\n    var grades = studentRecords.map(getGrade);\n\n    return addGrade;\n\n    // ************************\n\n    function getGrade(record){\n        return record.grade;\n    }\n\n    function sortAndTrimGradesList() {\n        // sort by grades, descending\n        grades.sort(function desc(g1,g2){\n            return g2 - g1;\n        });\n\n        // only keep the top 10 grades\n        grades = grades.slice(0,10);\n    }\n\n    function addGrade(newGrade) {\n        grades.push(newGrade);\n        sortAndTrimGradesList();\n        return grades;\n    }\n}\n\nvar addNextGrade = manageStudentGrades([\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    // ..many more records..\n    { id: 6, name: \"Sarah\", grade: 91 }\n]);\n\n// later\n\naddNextGrade(81);\naddNextGrade(68);\n// [ .., .., ... ]\n\nThe outer function manageStudentGrades(..) takes a list of student records, and returns an addGrade(..) function reference, which we externally label addNextGrade(..). Each time we call addNextGrade(..) with a new grade, we get back a current list of the top 10 grades, sorted numerically descending (see sortAndTrimGradesList()).\n\nFrom the end of the original manageStudentGrades(..) call, and between the multiple addNextGrade(..) calls, the grades variable is preserved inside addGrade(..) via closure; that's how the running list of top grades is maintained. Remember, it's a closure over the variable grades itself, not the array it holds.\n\nThat's not the only closure involved, however. Can you spot other variables being closed over?\n\nDid you spot that addGrade(..) references sortAndTrimGradesList? That means it's also closed over that identifier, which happens to hold a reference to the sortAndTrimGradesList() function. That second inner function has to stay around so that addGrade(..) can keep calling it, which also means any variables it closes over stick around\u2014though, in this case, nothing extra is closed over there.\n\nWhat else is closed over?\n\nConsider the getGrade variable (and its function); is it closed over? It's referenced in the outer scope of manageStudentGrades(..) in the .map(getGrade) call. But it's not referenced in addGrade(..) or sortAndTrimGradesList().\n\nWhat about the (potentially) large list of student records we pass in as studentRecords? Is that variable closed over? If it is, the array of student records is never getting GC'd, which leads to this program holding onto a larger amount of memory than we might assume. But if we look closely again, none of the inner functions reference studentRecords.\n\nAccording to the per variable definition of closure, since getGrade and studentRecords are not referenced by the inner functions, they're not closed over. They should be freely available for GC right after the manageStudentGrades(..) call completes.\n\nIndeed, try debugging this code in a recent JS engine, like v8 in Chrome, placing a breakpoint inside the addGrade(..) function. You may notice that the inspector does not list the studentRecords variable. That's proof, debugging-wise anyway, that the engine does not maintain studentRecords via closure. Phew!\n\nBut how reliable is this observation as proof? Consider this (rather contrived!) program:\n\nfunction storeStudentInfo(id,name,grade) {\n    return function getInfo(whichValue){\n        // warning:\n        //   using `eval(..)` is a bad idea!\n        var val = eval(whichValue);\n        return val;\n    };\n}\n\nvar info = storeStudentInfo(73,\"Suzy\",87);\n\ninfo(\"name\");\n// Suzy\n\ninfo(\"grade\");\n// 87\n\nNotice that the inner function getInfo(..) is not explicitly closed over any of id, name, or grade variables. And yet, calls to info(..) seem to still be able to access the variables, albeit through use of the eval(..) lexical scope cheat (see Chapter 1).\n\nSo all the variables were definitely preserved via closure, despite not being explicitly referenced by the inner function. So does that disprove the per variable assertion in favor of per scope? Depends.\n\nMany modern JS engines do apply an optimization that removes any variables from a closure scope that aren't explicitly referenced. However, as we see with eval(..), there are situations where such an optimization cannot be applied, and the closure scope continues to contain all its original variables. In other words, closure must be per scope, implementation wise, and then an optional optimization trims down the scope to only what was closed over (a similar outcome as per variable closure).\n\nEven as recent as a few years ago, many JS engines did not apply this optimization; it's possible your websites may still run in such browsers, especially on older or lower-end devices. That means it's possible that long-lived closures such as event handlers may be holding onto memory much longer than we would have assumed.\n\nAnd the fact that it's an optional optimization in the first place, rather than a requirement of the specification, means that we shouldn't just casually over-assume its applicability.\n\nIn cases where a variable holds a large value (like an object or array) and that variable is present in a closure scope, if you don't need that value anymore and don't want that memory held, it's safer (memory usage) to manually discard the value rather than relying on closure optimization/GC.\n\nLet's apply a fix to the earlier manageStudentGrades(..) example to ensure the potentially large array held in studentRecords is not caught up in a closure scope unnecessarily:\n\nfunction manageStudentGrades(studentRecords) {\n    var grades = studentRecords.map(getGrade);\n\n    // unset `studentRecords` to prevent unwanted\n    // memory retention in the closure\n    studentRecords = null;\n\n    return addGrade;\n    // ..\n}\n\nWe're not removing studentRecords from the closure scope; that we cannot control. We're ensuring that even if studentRecords remains in the closure scope, that variable is no longer referencing the potentially large array of data; the array can be GC'd.\n\nAgain, in many cases JS might automatically optimize the program to the same effect. But it's still a good habit to be careful and explicitly make sure we don't keep any significant amount of device memory tied up any longer than necessary.\n\nAs a matter of fact, we also technically don't need the function getGrade() anymore after the .map(getGrade) call completes. If profiling our application showed this was a critical area of excess memory use, we could possibly eek out a tiny bit more memory by freeing up that reference so its value isn't tied up either. That's likely unnecessary in this toy example, but this is a general technique to keep in mind if you're optimizing the memory footprint of your application.\n\nThe takeaway: it's important to know where closures appear in our programs, and what variables are included. We should manage these closures carefully so we're only holding onto what's minimally needed and not wasting memory."}, "id": 230}]}, {"data": {"uuid": "08b5cc25-9f7e-4998-b662-fb03e38d780b", "user": 1, "title": "An Alternative Perspective", "author": "Kyle Simpson", "created_on": "2023-06-09 01:42:01.575112+00:00", "updated_on": "2023-06-09 01:43:11.279266+00:00", "article_html": "<h2>An Alternative Perspective</h2><p>Reviewing our working definition for closure, the assertion is that functions are \"first-class values\" that can be passed around the program, just like any other value. Closure is the link-association that connects that function to the scope/variables outside of itself, no matter where that function goes.</p><p>Let's recall a code example from earlier in this chapter, again with relevant scope bubble colors annotated:</p><pre><code>// outer/global scope: RED(1)\n\nfunction adder(num1) {\n    // function scope: BLUE(2)\n\n    return function addTo(num2){\n        // function scope: GREEN(3)\n\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51</code></pre><p>Our current perspective suggests that wherever a function is passed and invoked, closure preserves a hidden link back to the original scope to facilitate the access to the closed-over variables. Figure 4, repeated here for convenience, illustrates this notion:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig4.png\"><p><em>Fig. 4 (repeat): Visualizing Closures</em></p><p>But there's another way of thinking about closure, and more precisely the nature of functions being <em>passed around</em>, that may help deepen the mental models.</p><p>This alternative model de-emphasizes \"functions as first-class values,\" and instead embraces how functions (like all non-primitive values) are held by reference in JS, and assigned/passed by reference-copy\u2014see Appendix A of the <em>Get Started</em> book for more information.</p><p>Instead of thinking about the inner function instance of <code>addTo(..)</code> moving to the outer RED(1) scope via the <code>return</code> and assignment, we can envision that function instances actually just stay in place in their own scope environment, of course with their scope-chain intact.</p><p>What gets <em>sent</em> to the RED(1) scope is <strong>just a reference</strong> to the in-place function instance, rather than the function instance itself. Figure 5 depicts the inner function instances remaining in place, pointed to by the RED(1) <code>addTo10</code> and <code>addTo42</code> references, respectively:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig5.png\"><p><em>Fig. 5: Visualizing Closures (Alternative)</em></p><p>As shown in Figure 5, each call to <code>adder(..)</code> still creates a new BLUE(2) scope containing a <code>num1</code> variable, as well as an instance of the GREEN(3) <code>addTo(..)</code> scope. But what's different from Figure 4 is, now these GREEN(3) instances remain in place, naturally nested inside of their BLUE(2) scope instances. The <code>addTo10</code> and <code>addTo42</code> references are moved to the RED(1) outer scope, not the function instances themselves.</p><p>When <code>addTo10(15)</code> is called, the <code>addTo(..)</code> function instance (still in place in its original BLUE(2) scope environment) is invoked. Since the function instance itself never moved, of course it still has natural access to its scope chain. Same with the <code>addTo42(9)</code> call\u2014nothing special here beyond lexical scope.</p><p>So what then <em>is</em> closure, if not the <em>magic</em> that lets a function maintain a link to its original scope chain even as that function moves around in other scopes? In this alternative model, functions stay in place and keep accessing their original scope chain just like they always could.</p><p>Closure instead describes the <em>magic</em> of <strong>keeping alive a function instance</strong>, along with its whole scope environment and chain, for as long as there's at least one reference to that function instance floating around in any other part of the program.</p><p>That definition of closure is less observational and a bit less familiar-sounding compared to the traditional academic perspective. But it's nonetheless still useful, because the benefit is that we simplify explanation of closure to a straightforward combination of references and in-place function instances.</p><p>The previous model (Figure 4) is not <em>wrong</em> at describing closure in JS. It's just more conceptually inspired, an academic perspective on closure. By contrast, the alternative model (Figure 5) could be described as a bit more implementation focused, how JS actually works.</p><p>Both perspectives/models are useful in understanding closure, but the reader may find one a little easier to hold than the other. Whichever you choose, the observable outcomes in our program are the same.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>This alternative model for closure does affect whether we classify synchronous callbacks as examples of closure or not. More on this nuance in Appendix A.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "An Alternative Perspective", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Reviewing our working definition for closure, the assertion is that functions are \"first-class values\" that can be passed around the program, just like any other value. Closure is the link-association that connects that function to the scope/variables outside of itself, no matter where that function goes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's recall a code example from earlier in this chapter, again with relevant scope bubble colors annotated:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer/global scope: RED(1)\n\nfunction adder(num1) {\n    // function scope: BLUE(2)\n\n    return function addTo(num2){\n        // function scope: GREEN(3)\n\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Our current perspective suggests that wherever a function is passed and invoked, closure preserves a hidden link back to the original scope to facilitate the access to the closed-over variables. Figure 4, repeated here for convenience, illustrates this notion:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig4.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 4 (repeat): Visualizing Closures", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "paragraph", "content": [{"text": "But there's another way of thinking about closure, and more precisely the nature of functions being ", "type": "text"}, {"text": "passed around", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", that may help deepen the mental models.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This alternative model de-emphasizes \"functions as first-class values,\" and instead embraces how functions (like all non-primitive values) are held by reference in JS, and assigned/passed by reference-copy\u2014see Appendix A of the ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " book for more information.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Instead of thinking about the inner function instance of ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " moving to the outer RED(1) scope via the ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " and assignment, we can envision that function instances actually just stay in place in their own scope environment, of course with their scope-chain intact.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What gets ", "type": "text"}, {"text": "sent", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to the RED(1) scope is ", "type": "text"}, {"text": "just a reference", "type": "text", "marks": [{"type": "bold"}]}, {"text": " to the in-place function instance, rather than the function instance itself. Figure 5 depicts the inner function instances remaining in place, pointed to by the RED(1) ", "type": "text"}, {"text": "addTo10", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "addTo42", "type": "text", "marks": [{"type": "code"}]}, {"text": " references, respectively:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig5.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 5: Visualizing Closures (Alternative)", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "paragraph", "content": [{"text": "As shown in Figure 5, each call to ", "type": "text"}, {"text": "adder(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " still creates a new BLUE(2) scope containing a ", "type": "text"}, {"text": "num1", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable, as well as an instance of the GREEN(3) ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " scope. But what's different from Figure 4 is, now these GREEN(3) instances remain in place, naturally nested inside of their BLUE(2) scope instances. The ", "type": "text"}, {"text": "addTo10", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "addTo42", "type": "text", "marks": [{"type": "code"}]}, {"text": " references are moved to the RED(1) outer scope, not the function instances themselves.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When ", "type": "text"}, {"text": "addTo10(15)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is called, the ", "type": "text"}, {"text": "addTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function instance (still in place in its original BLUE(2) scope environment) is invoked. Since the function instance itself never moved, of course it still has natural access to its scope chain. Same with the ", "type": "text"}, {"text": "addTo42(9)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call\u2014nothing special here beyond lexical scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So what then ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " closure, if not the ", "type": "text"}, {"text": "magic", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that lets a function maintain a link to its original scope chain even as that function moves around in other scopes? In this alternative model, functions stay in place and keep accessing their original scope chain just like they always could.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure instead describes the ", "type": "text"}, {"text": "magic", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of ", "type": "text"}, {"text": "keeping alive a function instance", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", along with its whole scope environment and chain, for as long as there's at least one reference to that function instance floating around in any other part of the program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That definition of closure is less observational and a bit less familiar-sounding compared to the traditional academic perspective. But it's nonetheless still useful, because the benefit is that we simplify explanation of closure to a straightforward combination of references and in-place function instances.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The previous model (Figure 4) is not ", "type": "text"}, {"text": "wrong", "type": "text", "marks": [{"type": "italic"}]}, {"text": " at describing closure in JS. It's just more conceptually inspired, an academic perspective on closure. By contrast, the alternative model (Figure 5) could be described as a bit more implementation focused, how JS actually works.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Both perspectives/models are useful in understanding closure, but the reader may find one a little easier to hold than the other. Whichever you choose, the observable outcomes in our program are the same.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "This alternative model for closure does affect whether we classify synchronous callbacks as examples of closure or not. More on this nuance in Appendix A.", "type": "text"}]}]}]}]}]}, "article_text": "An Alternative Perspective\n\nReviewing our working definition for closure, the assertion is that functions are \"first-class values\" that can be passed around the program, just like any other value. Closure is the link-association that connects that function to the scope/variables outside of itself, no matter where that function goes.\n\nLet's recall a code example from earlier in this chapter, again with relevant scope bubble colors annotated:\n\n// outer/global scope: RED(1)\n\nfunction adder(num1) {\n    // function scope: BLUE(2)\n\n    return function addTo(num2){\n        // function scope: GREEN(3)\n\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51\n\nOur current perspective suggests that wherever a function is passed and invoked, closure preserves a hidden link back to the original scope to facilitate the access to the closed-over variables. Figure 4, repeated here for convenience, illustrates this notion:\n\nFig. 4 (repeat): Visualizing Closures\n\nBut there's another way of thinking about closure, and more precisely the nature of functions being passed around, that may help deepen the mental models.\n\nThis alternative model de-emphasizes \"functions as first-class values,\" and instead embraces how functions (like all non-primitive values) are held by reference in JS, and assigned/passed by reference-copy\u2014see Appendix A of the Get Started book for more information.\n\nInstead of thinking about the inner function instance of addTo(..) moving to the outer RED(1) scope via the return and assignment, we can envision that function instances actually just stay in place in their own scope environment, of course with their scope-chain intact.\n\nWhat gets sent to the RED(1) scope is just a reference to the in-place function instance, rather than the function instance itself. Figure 5 depicts the inner function instances remaining in place, pointed to by the RED(1) addTo10 and addTo42 references, respectively:\n\nFig. 5: Visualizing Closures (Alternative)\n\nAs shown in Figure 5, each call to adder(..) still creates a new BLUE(2) scope containing a num1 variable, as well as an instance of the GREEN(3) addTo(..) scope. But what's different from Figure 4 is, now these GREEN(3) instances remain in place, naturally nested inside of their BLUE(2) scope instances. The addTo10 and addTo42 references are moved to the RED(1) outer scope, not the function instances themselves.\n\nWhen addTo10(15) is called, the addTo(..) function instance (still in place in its original BLUE(2) scope environment) is invoked. Since the function instance itself never moved, of course it still has natural access to its scope chain. Same with the addTo42(9) call\u2014nothing special here beyond lexical scope.\n\nSo what then is closure, if not the magic that lets a function maintain a link to its original scope chain even as that function moves around in other scopes? In this alternative model, functions stay in place and keep accessing their original scope chain just like they always could.\n\nClosure instead describes the magic of keeping alive a function instance, along with its whole scope environment and chain, for as long as there's at least one reference to that function instance floating around in any other part of the program.\n\nThat definition of closure is less observational and a bit less familiar-sounding compared to the traditional academic perspective. But it's nonetheless still useful, because the benefit is that we simplify explanation of closure to a straightforward combination of references and in-place function instances.\n\nThe previous model (Figure 4) is not wrong at describing closure in JS. It's just more conceptually inspired, an academic perspective on closure. By contrast, the alternative model (Figure 5) could be described as a bit more implementation focused, how JS actually works.\n\nBoth perspectives/models are useful in understanding closure, but the reader may find one a little easier to hold than the other. Whichever you choose, the observable outcomes in our program are the same.\n\nNOTE:\n\nThis alternative model for closure does affect whether we classify synchronous callbacks as examples of closure or not. More on this nuance in Appendix A."}, "id": 231}, {"data": {"uuid": "fa8b93cc-f1f7-49f5-867b-1a7288d5657c", "user": 1, "title": "Why Closure?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:43:30.872505+00:00", "updated_on": "2023-06-09 01:43:58.294475+00:00", "article_html": "<h2>Why Closure?</h2><p>Now that we have a well-rounded sense of what closure is and how it works, let's explore some ways it can improve the code structure and organization of an example program.</p><p>Imagine you have a button on a page that when clicked, should retrieve and send some data via an Ajax request. Without using closure:</p><pre><code>var APIendpoints = {\n    studentIDs:\n        \"https://some.api/register-students\",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction makeRequest(evt) {\n    var btn = evt.target;\n    var recordKind = btn.dataset.kind;\n    ajax(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n}\n\n// &lt;button data-kind=\"studentIDs\"&gt;\n//    Register Students\n// &lt;/button&gt;\nbtn.addEventListener(\"click\",makeRequest);</code></pre><p>The <code>makeRequest(..)</code> utility only receives an <code>evt</code> object from a click event. From there, it has to retrieve the <code>data-kind</code> attribute from the target button element, and use that value to lookup both a URL for the API endpoint as well as what data should be included in the Ajax request.</p><p>This works OK, but it's unfortunate (inefficient, more confusing) that the event handler has to read a DOM attribute each time it's fired. Why couldn't an event handler <em>remember</em> this value? Let's try using closure to improve the code:</p><pre><code>var APIendpoints = {\n    studentIDs:\n        \"https://some.api/register-students\",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n\n    btn.addEventListener(\n        \"click\",\n        function makeRequest(evt){\n            ajax(\n                APIendpoints[recordKind],\n                data[recordKind]\n            );\n        }\n    );\n}\n\n// &lt;button data-kind=\"studentIDs\"&gt;\n//    Register Students\n// &lt;/button&gt;\n\nsetupButtonHandler(btn);</code></pre><p>With the <code>setupButtonHandler(..)</code> approach, the <code>data-kind</code> attribute is retrieved once and assigned to the <code>recordKind</code> variable at initial setup. <code>recordKind</code> is then closed over by the inner <code>makeRequest(..)</code> click handler, and its value is used on each event firing to look up the URL and data that should be sent.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p><code>evt</code> is still passed to <code>makeRequest(..)</code>, though in this case we're not using it anymore. It's still listed, for consistency with the previous snippet.</p></td></tr></tbody></table><p>By placing <code>recordKind</code> inside <code>setupButtonHandler(..)</code>, we limit the scope exposure of that variable to a more appropriate subset of the program; storing it globally would have been worse for code organization and readability. Closure lets the inner <code>makeRequest()</code> function instance <em>remember</em> this variable and access whenever it's needed.</p><p>Building on this pattern, we could have looked up both the URL and data once, at setup:</p><pre><code>function setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var requestURL = APIendpoints[recordKind];\n    var requestData = data[recordKind];\n\n    btn.addEventListener(\n        \"click\",\n        function makeRequest(evt){\n            ajax(requestURL,requestData);\n        }\n    );\n}</code></pre><p>Now <code>makeRequest(..)</code> is closed over <code>requestURL</code> and <code>requestData</code>, which is a little bit cleaner to understand, and also slightly more performant.</p><p>Two similar techniques from the Functional Programming (FP) paradigm that rely on closure are partial application and currying. Briefly, with these techniques, we alter the <em>shape</em> of functions that require multiple inputs so some inputs are provided up front, and other inputs are provided later; the initial inputs are remembered via closure. Once all inputs have been provided, the underlying action is performed.</p><p>By creating a function instance that encapsulates some information inside (via closure), the function-with-stored-information can later be used directly without needing to re-provide that input. This makes that part of the code cleaner, and also offers the opportunity to label partially applied functions with better semantic names.</p><p>Adapting partial application, we can further improve the preceding code:</p><pre><code>function defineHandler(requestURL,requestData) {\n    return function makeRequest(evt){\n        ajax(requestURL,requestData);\n    };\n}\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var handler = defineHandler(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n    btn.addEventListener(\"click\",handler);\n}</code></pre><p>The <code>requestURL</code> and <code>requestData</code> inputs are provided ahead of time, resulting in the <code>makeRequest(..)</code> partially applied function, which we locally label <code>handler</code>. When the event eventually fires, the final input (<code>evt</code>, even though it's ignored) is passed to <code>handler()</code>, completing its inputs and triggering the underlying Ajax request.</p><p>Behavior-wise, this program is pretty similar to the previous one, with the same type of closure. But by isolating the creation of <code>makeRequest(..)</code> in a separate utility (<code>defineHandler(..)</code>), we make that definition more reusable across the program. We also explicitly limit the closure scope to only the two variables needed.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Why Closure?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now that we have a well-rounded sense of what closure is and how it works, let's explore some ways it can improve the code structure and organization of an example program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Imagine you have a button on a page that when clicked, should retrieve and send some data via an Ajax request. Without using closure:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var APIendpoints = {\n    studentIDs:\n        \"https://some.api/register-students\",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction makeRequest(evt) {\n    var btn = evt.target;\n    var recordKind = btn.dataset.kind;\n    ajax(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n}\n\n// <button data-kind=\"studentIDs\">\n//    Register Students\n// </button>\nbtn.addEventListener(\"click\",makeRequest);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "makeRequest(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility only receives an ", "type": "text"}, {"text": "evt", "type": "text", "marks": [{"type": "code"}]}, {"text": " object from a click event. From there, it has to retrieve the ", "type": "text"}, {"text": "data-kind", "type": "text", "marks": [{"type": "code"}]}, {"text": " attribute from the target button element, and use that value to lookup both a URL for the API endpoint as well as what data should be included in the Ajax request.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This works OK, but it's unfortunate (inefficient, more confusing) that the event handler has to read a DOM attribute each time it's fired. Why couldn't an event handler ", "type": "text"}, {"text": "remember", "type": "text", "marks": [{"type": "italic"}]}, {"text": " this value? Let's try using closure to improve the code:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var APIendpoints = {\n    studentIDs:\n        \"https://some.api/register-students\",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n\n    btn.addEventListener(\n        \"click\",\n        function makeRequest(evt){\n            ajax(\n                APIendpoints[recordKind],\n                data[recordKind]\n            );\n        }\n    );\n}\n\n// <button data-kind=\"studentIDs\">\n//    Register Students\n// </button>\n\nsetupButtonHandler(btn);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With the ", "type": "text"}, {"text": "setupButtonHandler(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " approach, the ", "type": "text"}, {"text": "data-kind", "type": "text", "marks": [{"type": "code"}]}, {"text": " attribute is retrieved once and assigned to the ", "type": "text"}, {"text": "recordKind", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable at initial setup. ", "type": "text"}, {"text": "recordKind", "type": "text", "marks": [{"type": "code"}]}, {"text": " is then closed over by the inner ", "type": "text"}, {"text": "makeRequest(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " click handler, and its value is used on each event firing to look up the URL and data that should be sent.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "evt", "type": "text", "marks": [{"type": "code"}]}, {"text": " is still passed to ", "type": "text"}, {"text": "makeRequest(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", though in this case we're not using it anymore. It's still listed, for consistency with the previous snippet.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "By placing ", "type": "text"}, {"text": "recordKind", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside ", "type": "text"}, {"text": "setupButtonHandler(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we limit the scope exposure of that variable to a more appropriate subset of the program; storing it globally would have been worse for code organization and readability. Closure lets the inner ", "type": "text"}, {"text": "makeRequest()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function instance ", "type": "text"}, {"text": "remember", "type": "text", "marks": [{"type": "italic"}]}, {"text": " this variable and access whenever it's needed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Building on this pattern, we could have looked up both the URL and data once, at setup:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var requestURL = APIendpoints[recordKind];\n    var requestData = data[recordKind];\n\n    btn.addEventListener(\n        \"click\",\n        function makeRequest(evt){\n            ajax(requestURL,requestData);\n        }\n    );\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now ", "type": "text"}, {"text": "makeRequest(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is closed over ", "type": "text"}, {"text": "requestURL", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "requestData", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which is a little bit cleaner to understand, and also slightly more performant.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Two similar techniques from the Functional Programming (FP) paradigm that rely on closure are partial application and currying. Briefly, with these techniques, we alter the ", "type": "text"}, {"text": "shape", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of functions that require multiple inputs so some inputs are provided up front, and other inputs are provided later; the initial inputs are remembered via closure. Once all inputs have been provided, the underlying action is performed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By creating a function instance that encapsulates some information inside (via closure), the function-with-stored-information can later be used directly without needing to re-provide that input. This makes that part of the code cleaner, and also offers the opportunity to label partially applied functions with better semantic names.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Adapting partial application, we can further improve the preceding code:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function defineHandler(requestURL,requestData) {\n    return function makeRequest(evt){\n        ajax(requestURL,requestData);\n    };\n}\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var handler = defineHandler(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n    btn.addEventListener(\"click\",handler);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "requestURL", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "requestData", "type": "text", "marks": [{"type": "code"}]}, {"text": " inputs are provided ahead of time, resulting in the ", "type": "text"}, {"text": "makeRequest(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " partially applied function, which we locally label ", "type": "text"}, {"text": "handler", "type": "text", "marks": [{"type": "code"}]}, {"text": ". When the event eventually fires, the final input (", "type": "text"}, {"text": "evt", "type": "text", "marks": [{"type": "code"}]}, {"text": ", even though it's ignored) is passed to ", "type": "text"}, {"text": "handler()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", completing its inputs and triggering the underlying Ajax request.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Behavior-wise, this program is pretty similar to the previous one, with the same type of closure. But by isolating the creation of ", "type": "text"}, {"text": "makeRequest(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " in a separate utility (", "type": "text"}, {"text": "defineHandler(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "), we make that definition more reusable across the program. We also explicitly limit the closure scope to only the two variables needed.", "type": "text"}]}]}, "article_text": "Why Closure?\n\nNow that we have a well-rounded sense of what closure is and how it works, let's explore some ways it can improve the code structure and organization of an example program.\n\nImagine you have a button on a page that when clicked, should retrieve and send some data via an Ajax request. Without using closure:\n\nvar APIendpoints = {\n    studentIDs:\n        \"https://some.api/register-students\",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction makeRequest(evt) {\n    var btn = evt.target;\n    var recordKind = btn.dataset.kind;\n    ajax(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n}\n\n// <button data-kind=\"studentIDs\">\n//    Register Students\n// </button>\nbtn.addEventListener(\"click\",makeRequest);\n\nThe makeRequest(..) utility only receives an evt object from a click event. From there, it has to retrieve the data-kind attribute from the target button element, and use that value to lookup both a URL for the API endpoint as well as what data should be included in the Ajax request.\n\nThis works OK, but it's unfortunate (inefficient, more confusing) that the event handler has to read a DOM attribute each time it's fired. Why couldn't an event handler remember this value? Let's try using closure to improve the code:\n\nvar APIendpoints = {\n    studentIDs:\n        \"https://some.api/register-students\",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n\n    btn.addEventListener(\n        \"click\",\n        function makeRequest(evt){\n            ajax(\n                APIendpoints[recordKind],\n                data[recordKind]\n            );\n        }\n    );\n}\n\n// <button data-kind=\"studentIDs\">\n//    Register Students\n// </button>\n\nsetupButtonHandler(btn);\n\nWith the setupButtonHandler(..) approach, the data-kind attribute is retrieved once and assigned to the recordKind variable at initial setup. recordKind is then closed over by the inner makeRequest(..) click handler, and its value is used on each event firing to look up the URL and data that should be sent.\n\nNOTE:\n\nevt is still passed to makeRequest(..), though in this case we're not using it anymore. It's still listed, for consistency with the previous snippet.\n\nBy placing recordKind inside setupButtonHandler(..), we limit the scope exposure of that variable to a more appropriate subset of the program; storing it globally would have been worse for code organization and readability. Closure lets the inner makeRequest() function instance remember this variable and access whenever it's needed.\n\nBuilding on this pattern, we could have looked up both the URL and data once, at setup:\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var requestURL = APIendpoints[recordKind];\n    var requestData = data[recordKind];\n\n    btn.addEventListener(\n        \"click\",\n        function makeRequest(evt){\n            ajax(requestURL,requestData);\n        }\n    );\n}\n\nNow makeRequest(..) is closed over requestURL and requestData, which is a little bit cleaner to understand, and also slightly more performant.\n\nTwo similar techniques from the Functional Programming (FP) paradigm that rely on closure are partial application and currying. Briefly, with these techniques, we alter the shape of functions that require multiple inputs so some inputs are provided up front, and other inputs are provided later; the initial inputs are remembered via closure. Once all inputs have been provided, the underlying action is performed.\n\nBy creating a function instance that encapsulates some information inside (via closure), the function-with-stored-information can later be used directly without needing to re-provide that input. This makes that part of the code cleaner, and also offers the opportunity to label partially applied functions with better semantic names.\n\nAdapting partial application, we can further improve the preceding code:\n\nfunction defineHandler(requestURL,requestData) {\n    return function makeRequest(evt){\n        ajax(requestURL,requestData);\n    };\n}\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var handler = defineHandler(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n    btn.addEventListener(\"click\",handler);\n}\n\nThe requestURL and requestData inputs are provided ahead of time, resulting in the makeRequest(..) partially applied function, which we locally label handler. When the event eventually fires, the final input (evt, even though it's ignored) is passed to handler(), completing its inputs and triggering the underlying Ajax request.\n\nBehavior-wise, this program is pretty similar to the previous one, with the same type of closure. But by isolating the creation of makeRequest(..) in a separate utility (defineHandler(..)), we make that definition more reusable across the program. We also explicitly limit the closure scope to only the two variables needed."}, "id": 232}, {"data": {"uuid": "add9f09a-4ee9-43c5-b349-a391cc52d1dc", "user": 1, "title": "Closer to Closure", "author": "Kyle Simpson", "created_on": "2023-06-09 01:44:19.240594+00:00", "updated_on": "2023-06-09 01:44:37.696463+00:00", "article_html": "<h2>Closer to Closure</h2><p>As we close down a dense chapter, take some deep breaths let it all sink in. Seriously, that's a lot of information for anyone to consume!</p><p>We explored two models for mentally tackling closure:</p><ul><li><p>Observational: closure is a function instance remembering its outer variables even as that function is passed to and <strong>invoked in</strong> other scopes.</p></li><li><p>Implementational: closure is a function instance and its scope environment preserved in-place while any references to it are passed around and <strong>invoked from</strong> other scopes.</p></li></ul><p>Summarizing the benefits to our programs:</p><ul><li><p>Closure can improve efficiency by allowing a function instance to remember previously determined information instead of having to compute it each time.</p></li><li><p>Closure can improve code readability, bounding scope-exposure by encapsulating variable(s) inside function instances, while still making sure the information in those variables is accessible for future use. The resultant narrower, more specialized function instances are cleaner to interact with, since the preserved information doesn't need to be passed in every invocation.</p></li></ul><p>Before you move on, take some time to restate this summary <em>in your own words</em>, explaining what closure is and why it's helpful in your programs. The main book text concludes with a final chapter that builds on top of closure with the module pattern.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Closer to Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As we close down a dense chapter, take some deep breaths let it all sink in. Seriously, that's a lot of information for anyone to consume!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We explored two models for mentally tackling closure:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Observational: closure is a function instance remembering its outer variables even as that function is passed to and ", "type": "text"}, {"text": "invoked in", "type": "text", "marks": [{"type": "bold"}]}, {"text": " other scopes.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Implementational: closure is a function instance and its scope environment preserved in-place while any references to it are passed around and ", "type": "text"}, {"text": "invoked from", "type": "text", "marks": [{"type": "bold"}]}, {"text": " other scopes.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Summarizing the benefits to our programs:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure can improve efficiency by allowing a function instance to remember previously determined information instead of having to compute it each time.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure can improve code readability, bounding scope-exposure by encapsulating variable(s) inside function instances, while still making sure the information in those variables is accessible for future use. The resultant narrower, more specialized function instances are cleaner to interact with, since the preserved information doesn't need to be passed in every invocation.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Before you move on, take some time to restate this summary ", "type": "text"}, {"text": "in your own words", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", explaining what closure is and why it's helpful in your programs. The main book text concludes with a final chapter that builds on top of closure with the module pattern.", "type": "text"}]}]}, "article_text": "Closer to Closure\n\nAs we close down a dense chapter, take some deep breaths let it all sink in. Seriously, that's a lot of information for anyone to consume!\n\nWe explored two models for mentally tackling closure:\n\nObservational: closure is a function instance remembering its outer variables even as that function is passed to and invoked in other scopes.\n\nImplementational: closure is a function instance and its scope environment preserved in-place while any references to it are passed around and invoked from other scopes.\n\nSummarizing the benefits to our programs:\n\nClosure can improve efficiency by allowing a function instance to remember previously determined information instead of having to compute it each time.\n\nClosure can improve code readability, bounding scope-exposure by encapsulating variable(s) inside function instances, while still making sure the information in those variables is accessible for future use. The resultant narrower, more specialized function instances are cleaner to interact with, since the preserved information doesn't need to be passed in every invocation.\n\nBefore you move on, take some time to restate this summary in your own words, explaining what closure is and why it's helpful in your programs. The main book text concludes with a final chapter that builds on top of closure with the module pattern."}, "id": 233}]}, {"data": {"uuid": "930d6376-342a-435c-8716-af1658466d3d", "user": 1, "title": "Chapter 8: The Module Pattern", "author": "Kyle Simpson", "created_on": "2023-06-09 01:45:18.805106+00:00", "updated_on": "2023-06-09 01:45:45.617397+00:00", "article_html": "<h1>Chapter 8: The Module Pattern</h1><p>In this chapter, we wrap up the main text of the book by exploring one of the most important code organization patterns in all of programming: the module. As we'll see, modules are inherently built from what we've already covered: the payoff for your efforts in learning lexical scope and closure.</p><p>We've examined every angle of lexical scope, from the breadth of the global scope down through nested block scopes, into the intricacies of the variable lifecycle. Then we leveraged lexical scope to understand the full power of closure.</p><p>Take a moment to reflect on how far you've come in this journey so far; you've taken big steps in getting to know JS more deeply!</p><p>The central theme of this book has been that understanding and mastering scope and closure is key in properly structuring and organizing our code, especially the decisions on where to store information in variables.</p><p>Our goal in this final chapter is to appreciate how modules embody the importance of these topics, elevating them from abstract concepts to concrete, practical improvements in building programs.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 8: The Module Pattern", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this chapter, we wrap up the main text of the book by exploring one of the most important code organization patterns in all of programming: the module. As we'll see, modules are inherently built from what we've already covered: the payoff for your efforts in learning lexical scope and closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We've examined every angle of lexical scope, from the breadth of the global scope down through nested block scopes, into the intricacies of the variable lifecycle. Then we leveraged lexical scope to understand the full power of closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Take a moment to reflect on how far you've come in this journey so far; you've taken big steps in getting to know JS more deeply!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The central theme of this book has been that understanding and mastering scope and closure is key in properly structuring and organizing our code, especially the decisions on where to store information in variables.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Our goal in this final chapter is to appreciate how modules embody the importance of these topics, elevating them from abstract concepts to concrete, practical improvements in building programs.", "type": "text"}]}]}, "article_text": "Chapter 8: The Module Pattern\n\nIn this chapter, we wrap up the main text of the book by exploring one of the most important code organization patterns in all of programming: the module. As we'll see, modules are inherently built from what we've already covered: the payoff for your efforts in learning lexical scope and closure.\n\nWe've examined every angle of lexical scope, from the breadth of the global scope down through nested block scopes, into the intricacies of the variable lifecycle. Then we leveraged lexical scope to understand the full power of closure.\n\nTake a moment to reflect on how far you've come in this journey so far; you've taken big steps in getting to know JS more deeply!\n\nThe central theme of this book has been that understanding and mastering scope and closure is key in properly structuring and organizing our code, especially the decisions on where to store information in variables.\n\nOur goal in this final chapter is to appreciate how modules embody the importance of these topics, elevating them from abstract concepts to concrete, practical improvements in building programs."}, "id": 234, "children": [{"data": {"uuid": "72f6dd1a-2e2c-4a9e-837b-00fb217a33f5", "user": 1, "title": "Encapsulation and Least Exposure (POLE)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:46:10.775945+00:00", "updated_on": "2023-06-09 01:46:39.509224+00:00", "article_html": "<h2>Encapsulation and Least Exposure (POLE)</h2><p>Encapsulation is often cited as a principle of object-oriented (OO) programming, but it's more fundamental and broadly applicable than that. The goal of encapsulation is the bundling or co-location of information (data) and behavior (functions) that together serve a common purpose.</p><p>Independent of any syntax or code mechanisms, the spirit of encapsulation can be realized in something as simple as using separate files to hold bits of the overall program with common purpose. If we bundle everything that powers a list of search results into a single file called \"search-list.js\", we're encapsulating that part of the program.</p><p>The recent trend in modern front-end programming to organize applications around Component architecture pushes encapsulation even further. For many, it feels natural to consolidate everything that constitutes the search results list\u2014even beyond code, including presentational markup and styling\u2014into a single unit of program logic, something tangible we can interact with. And then we label that collection the \"SearchList\" component.</p><p>Another key goal is the control of visibility of certain aspects of the encapsulated data and functionality. Recall from Chapter 6 the <em>least exposure</em> principle (POLE), which seeks to defensively guard against various <em>dangers</em> of scope over-exposure; these affect both variables and functions. In JS, we most often implement visibility control through the mechanics of lexical scope.</p><p>The idea is to group alike program bits together, and selectively limit programmatic access to the parts we consider <em>private</em> details. What's not considered <em>private</em> is then marked as <em>public</em>, accessible to the whole program.</p><p>The natural effect of this effort is better code organization. It's easier to build and maintain software when we know where things are, with clear and obvious boundaries and connection points. It's also easier to maintain quality if we avoid the pitfalls of over-exposed data and functionality.</p><p>These are some of the main benefits of organizing JS programs into modules.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Encapsulation and Least Exposure (POLE)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Encapsulation is often cited as a principle of object-oriented (OO) programming, but it's more fundamental and broadly applicable than that. The goal of encapsulation is the bundling or co-location of information (data) and behavior (functions) that together serve a common purpose.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Independent of any syntax or code mechanisms, the spirit of encapsulation can be realized in something as simple as using separate files to hold bits of the overall program with common purpose. If we bundle everything that powers a list of search results into a single file called \"search-list.js\", we're encapsulating that part of the program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The recent trend in modern front-end programming to organize applications around Component architecture pushes encapsulation even further. For many, it feels natural to consolidate everything that constitutes the search results list\u2014even beyond code, including presentational markup and styling\u2014into a single unit of program logic, something tangible we can interact with. And then we label that collection the \"SearchList\" component.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another key goal is the control of visibility of certain aspects of the encapsulated data and functionality. Recall from Chapter 6 the ", "type": "text"}, {"text": "least exposure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " principle (POLE), which seeks to defensively guard against various ", "type": "text"}, {"text": "dangers", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of scope over-exposure; these affect both variables and functions. In JS, we most often implement visibility control through the mechanics of lexical scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The idea is to group alike program bits together, and selectively limit programmatic access to the parts we consider ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " details. What's not considered ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is then marked as ", "type": "text"}, {"text": "public", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", accessible to the whole program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The natural effect of this effort is better code organization. It's easier to build and maintain software when we know where things are, with clear and obvious boundaries and connection points. It's also easier to maintain quality if we avoid the pitfalls of over-exposed data and functionality.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These are some of the main benefits of organizing JS programs into modules.", "type": "text"}]}]}, "article_text": "Encapsulation and Least Exposure (POLE)\n\nEncapsulation is often cited as a principle of object-oriented (OO) programming, but it's more fundamental and broadly applicable than that. The goal of encapsulation is the bundling or co-location of information (data) and behavior (functions) that together serve a common purpose.\n\nIndependent of any syntax or code mechanisms, the spirit of encapsulation can be realized in something as simple as using separate files to hold bits of the overall program with common purpose. If we bundle everything that powers a list of search results into a single file called \"search-list.js\", we're encapsulating that part of the program.\n\nThe recent trend in modern front-end programming to organize applications around Component architecture pushes encapsulation even further. For many, it feels natural to consolidate everything that constitutes the search results list\u2014even beyond code, including presentational markup and styling\u2014into a single unit of program logic, something tangible we can interact with. And then we label that collection the \"SearchList\" component.\n\nAnother key goal is the control of visibility of certain aspects of the encapsulated data and functionality. Recall from Chapter 6 the least exposure principle (POLE), which seeks to defensively guard against various dangers of scope over-exposure; these affect both variables and functions. In JS, we most often implement visibility control through the mechanics of lexical scope.\n\nThe idea is to group alike program bits together, and selectively limit programmatic access to the parts we consider private details. What's not considered private is then marked as public, accessible to the whole program.\n\nThe natural effect of this effort is better code organization. It's easier to build and maintain software when we know where things are, with clear and obvious boundaries and connection points. It's also easier to maintain quality if we avoid the pitfalls of over-exposed data and functionality.\n\nThese are some of the main benefits of organizing JS programs into modules."}, "id": 235}, {"data": {"uuid": "df417bb9-0c66-48cc-a2a6-d0399e4b57e3", "user": 1, "title": "What Is a Module?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:47:07.067168+00:00", "updated_on": "2023-06-09 01:47:16.936365+00:00", "article_html": "<h2>What Is a Module?</h2><p>A module is a collection of related data and functions (often referred to as methods in this context), characterized by a division between hidden <em>private</em> details and <em>public</em> accessible details, usually called the \"public API.\"</p><p>A module is also stateful: it maintains some information over time, along with functionality to access and update that information.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>A broader concern of the module pattern is fully embracing system-level modularization through loose-coupling and other program architecture techniques. That's a complex topic well beyond the bounds of our discussion, but is worth further study beyond this book.</p></td></tr></tbody></table><p>To get a better sense of what a module is, let's compare some module characteristics to useful code patterns that aren't quite modules.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "What Is a Module?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A module is a collection of related data and functions (often referred to as methods in this context), characterized by a division between hidden ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " details and ", "type": "text"}, {"text": "public", "type": "text", "marks": [{"type": "italic"}]}, {"text": " accessible details, usually called the \"public API.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A module is also stateful: it maintains some information over time, along with functionality to access and update that information.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "A broader concern of the module pattern is fully embracing system-level modularization through loose-coupling and other program architecture techniques. That's a complex topic well beyond the bounds of our discussion, but is worth further study beyond this book.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "To get a better sense of what a module is, let's compare some module characteristics to useful code patterns that aren't quite modules.", "type": "text"}]}]}, "article_text": "What Is a Module?\n\nA module is a collection of related data and functions (often referred to as methods in this context), characterized by a division between hidden private details and public accessible details, usually called the \"public API.\"\n\nA module is also stateful: it maintains some information over time, along with functionality to access and update that information.\n\nNOTE:\n\nA broader concern of the module pattern is fully embracing system-level modularization through loose-coupling and other program architecture techniques. That's a complex topic well beyond the bounds of our discussion, but is worth further study beyond this book.\n\nTo get a better sense of what a module is, let's compare some module characteristics to useful code patterns that aren't quite modules."}, "id": 236, "children": [{"data": {"uuid": "0106e2e8-4c60-4fa5-b6e3-9d5a47c499a8", "user": 1, "title": "Namespaces (Stateless Grouping)", "author": "Kyle", "created_on": "2023-06-09 01:47:35.511587+00:00", "updated_on": "2023-06-09 01:47:54.124139+00:00", "article_html": "<h3>Namespaces (Stateless Grouping)</h3><p>If you group a set of related functions together, without data, then you don't really have the expected encapsulation a module implies. The better term for this grouping of <em>stateless</em> functions is a namespace:</p><pre><code>// namespace, not module\nvar Utils = {\n    cancelEvt(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        evt.stopImmediatePropagation();\n    },\n    wait(ms) {\n        return new Promise(function c(res){\n            setTimeout(res,ms);\n        });\n    },\n    isValidEmail(email) {\n        return /[^@]+@[^@.]+\\.[^@.]+/.test(email);\n    }\n};</code></pre><p><code>Utils</code> here is a useful collection of utilities, yet they're all state-independent functions. Gathering functionality together is generally good practice, but that doesn't make this a module. Rather, we've defined a <code>Utils</code> namespace and organized the functions under it.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Namespaces (Stateless Grouping)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you group a set of related functions together, without data, then you don't really have the expected encapsulation a module implies. The better term for this grouping of ", "type": "text"}, {"text": "stateless", "type": "text", "marks": [{"type": "italic"}]}, {"text": " functions is a namespace:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// namespace, not module\nvar Utils = {\n    cancelEvt(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        evt.stopImmediatePropagation();\n    },\n    wait(ms) {\n        return new Promise(function c(res){\n            setTimeout(res,ms);\n        });\n    },\n    isValidEmail(email) {\n        return /[^@]+@[^@.]+\\.[^@.]+/.test(email);\n    }\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Utils", "type": "text", "marks": [{"type": "code"}]}, {"text": " here is a useful collection of utilities, yet they're all state-independent functions. Gathering functionality together is generally good practice, but that doesn't make this a module. Rather, we've defined a ", "type": "text"}, {"text": "Utils", "type": "text", "marks": [{"type": "code"}]}, {"text": " namespace and organized the functions under it.", "type": "text"}]}]}, "article_text": "Namespaces (Stateless Grouping)\n\nIf you group a set of related functions together, without data, then you don't really have the expected encapsulation a module implies. The better term for this grouping of stateless functions is a namespace:\n\n// namespace, not module\nvar Utils = {\n    cancelEvt(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        evt.stopImmediatePropagation();\n    },\n    wait(ms) {\n        return new Promise(function c(res){\n            setTimeout(res,ms);\n        });\n    },\n    isValidEmail(email) {\n        return /[^@]+@[^@.]+\\.[^@.]+/.test(email);\n    }\n};\n\nUtils here is a useful collection of utilities, yet they're all state-independent functions. Gathering functionality together is generally good practice, but that doesn't make this a module. Rather, we've defined a Utils namespace and organized the functions under it."}, "id": 237}, {"data": {"uuid": "4793aded-b189-4f48-a52b-edc4230958cf", "user": 1, "title": "Data Structures (Stateful Grouping)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:48:08.755712+00:00", "updated_on": "2023-06-09 01:48:26.341927+00:00", "article_html": "<h3>Data Structures (Stateful Grouping)</h3><p>Even if you bundle data and stateful functions together, if you're not limiting the visibility of any of it, then you're stopping short of the POLE aspect of encapsulation; it's not particularly helpful to label that a module.</p><p>Consider:</p><pre><code>// data structure, not module\nvar Student = {\n    records: [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ],\n    getName(studentID) {\n        var student = this.records.find(\n            student =&gt; student.id == studentID\n        );\n        return student.name;\n    }\n};\n\nStudent.getName(73);\n// Suzy</code></pre><p>Since <code>records</code> is publicly accessible data, not hidden behind a public API, <code>Student</code> here isn't really a module.</p><p><code>Student</code> does have the data-and-functionality aspect of encapsulation, but not the visibility-control aspect. It's best to label this an instance of a data structure.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Data Structures (Stateful Grouping)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even if you bundle data and stateful functions together, if you're not limiting the visibility of any of it, then you're stopping short of the POLE aspect of encapsulation; it's not particularly helpful to label that a module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// data structure, not module\nvar Student = {\n    records: [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ],\n    getName(studentID) {\n        var student = this.records.find(\n            student => student.id == studentID\n        );\n        return student.name;\n    }\n};\n\nStudent.getName(73);\n// Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " is publicly accessible data, not hidden behind a public API, ", "type": "text"}, {"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " here isn't really a module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " does have the data-and-functionality aspect of encapsulation, but not the visibility-control aspect. It's best to label this an instance of a data structure.", "type": "text"}]}]}, "article_text": "Data Structures (Stateful Grouping)\n\nEven if you bundle data and stateful functions together, if you're not limiting the visibility of any of it, then you're stopping short of the POLE aspect of encapsulation; it's not particularly helpful to label that a module.\n\nConsider:\n\n// data structure, not module\nvar Student = {\n    records: [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ],\n    getName(studentID) {\n        var student = this.records.find(\n            student => student.id == studentID\n        );\n        return student.name;\n    }\n};\n\nStudent.getName(73);\n// Suzy\n\nSince records is publicly accessible data, not hidden behind a public API, Student here isn't really a module.\n\nStudent does have the data-and-functionality aspect of encapsulation, but not the visibility-control aspect. It's best to label this an instance of a data structure."}, "id": 238}, {"data": {"uuid": "d4f9f64f-d2d0-490c-a4d8-3355a4285020", "user": 1, "title": "Modules (Stateful Access Control)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:48:44.945139+00:00", "updated_on": "2023-06-09 01:49:40.708124+00:00", "article_html": "<h3>Modules (Stateful Access Control)</h3><p>To embody the full spirit of the module pattern, we not only need grouping and state, but also access control through visibility (private vs. public).</p><p>Let's turn <code>Student</code> from the previous section into a module. We'll start with a form I call the \"classic module,\" which was originally referred to as the \"revealing module\" when it first emerged in the early 2000s. Consider:</p><pre><code>var Student = (function defineStudent(){\n    var records = [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ];\n\n    var publicAPI = {\n        getName\n    };\n\n    return publicAPI;\n\n    // ************************\n\n    function getName(studentID) {\n        var student = records.find(\n            student =&gt; student.id == studentID\n        );\n        return student.name;\n    }\n})();\n\nStudent.getName(73);   // Suzy</code></pre><p><code>Student</code> is now an instance of a module. It features a public API with a single method: <code>getName(..)</code>. This method is able to access the private hidden <code>records</code> data.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>I should point out that the explicit student data being hard-coded into this module definition is just for our illustration purposes. A typical module in your program will receive this data from an outside source, typically loaded from databases, JSON data files, Ajax calls, etc. The data is then injected into the module instance typically through method(s) on the module's public API.</p></td></tr></tbody></table><p>How does the classic module format work?</p><p>Notice that the instance of the module is created by the <code>defineStudent()</code> IIFE being executed. This IIFE returns an object (named <code>publicAPI</code>) that has a property on it referencing the inner <code>getName(..)</code> function.</p><p>Naming the object <code>publicAPI</code> is stylistic preference on my part. The object can be named whatever you like (JS doesn't care), or you can just return an object directly without assigning it to any internal named variable. More on this choice in Appendix A.</p><p>From the outside, <code>Student.getName(..)</code> invokes this exposed inner function, which maintains access to the inner <code>records</code> variable via closure.</p><p>You don't <em>have</em> to return an object with a function as one of its properties. You could just return a function directly, in place of the object. That still satisfies all the core bits of a classic module.</p><p>By virtue of how lexical scope works, defining variables and functions inside your outer module definition function makes everything <em>by default</em> private. Only properties added to the public API object returned from the function will be exported for external public use.</p><p>The use of an IIFE implies that our program only ever needs a single central instance of the module, commonly referred to as a \"singleton.\" Indeed, this specific example is simple enough that there's no obvious reason we'd need anything more than just one instance of the <code>Student</code> module.</p><h4>Module Factory (Multiple Instances)</h4><p>But if we did want to define a module that supported multiple instances in our program, we can slightly tweak the code:</p><pre><code>// factory function, not singleton IIFE\nfunction defineStudent() {\n    var records = [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ];\n\n    var publicAPI = {\n        getName\n    };\n\n    return publicAPI;\n\n    // ************************\n\n    function getName(studentID) {\n        var student = records.find(\n            student =&gt; student.id == studentID\n        );\n        return student.name;\n    }\n}\n\nvar fullTime = defineStudent();\nfullTime.getName(73);            // Suzy</code></pre><p>Rather than specifying <code>defineStudent()</code> as an IIFE, we just define it as a normal standalone function, which is commonly referred to in this context as a \"module factory\" function.</p><p>We then call the module factory, producing an instance of the module that we label <code>fullTime</code>. This module instance implies a new instance of the inner scope, and thus a new closure that <code>getName(..)</code> holds over <code>records</code>. <code>fullTime.getName(..)</code> now invokes the method on that specific instance.</p><h4>Classic Module Definition</h4><p>So to clarify what makes something a classic module:</p><ul><li><p>There must be an outer scope, typically from a module factory function running at least once.</p></li><li><p>The module's inner scope must have at least one piece of hidden information that represents state for the module.</p></li><li><p>The module must return on its public API a reference to at least one function that has closure over the hidden module state (so that this state is actually preserved).</p></li></ul><p>You'll likely run across other variations on this classic module approach, which we'll look at in more detail in Appendix A.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Modules (Stateful Access Control)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To embody the full spirit of the module pattern, we not only need grouping and state, but also access control through visibility (private vs. public).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's turn ", "type": "text"}, {"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " from the previous section into a module. We'll start with a form I call the \"classic module,\" which was originally referred to as the \"revealing module\" when it first emerged in the early 2000s. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var Student = (function defineStudent(){\n    var records = [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ];\n\n    var publicAPI = {\n        getName\n    };\n\n    return publicAPI;\n\n    // ************************\n\n    function getName(studentID) {\n        var student = records.find(\n            student => student.id == studentID\n        );\n        return student.name;\n    }\n})();\n\nStudent.getName(73);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " is now an instance of a module. It features a public API with a single method: ", "type": "text"}, {"text": "getName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". This method is able to access the private hidden ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " data.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "I should point out that the explicit student data being hard-coded into this module definition is just for our illustration purposes. A typical module in your program will receive this data from an outside source, typically loaded from databases, JSON data files, Ajax calls, etc. The data is then injected into the module instance typically through method(s) on the module's public API.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "How does the classic module format work?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice that the instance of the module is created by the ", "type": "text"}, {"text": "defineStudent()", "type": "text", "marks": [{"type": "code"}]}, {"text": " IIFE being executed. This IIFE returns an object (named ", "type": "text"}, {"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": ") that has a property on it referencing the inner ", "type": "text"}, {"text": "getName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Naming the object ", "type": "text"}, {"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": " is stylistic preference on my part. The object can be named whatever you like (JS doesn't care), or you can just return an object directly without assigning it to any internal named variable. More on this choice in Appendix A.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "From the outside, ", "type": "text"}, {"text": "Student.getName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " invokes this exposed inner function, which maintains access to the inner ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable via closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You don't ", "type": "text"}, {"text": "have", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to return an object with a function as one of its properties. You could just return a function directly, in place of the object. That still satisfies all the core bits of a classic module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By virtue of how lexical scope works, defining variables and functions inside your outer module definition function makes everything ", "type": "text"}, {"text": "by default", "type": "text", "marks": [{"type": "italic"}]}, {"text": " private. Only properties added to the public API object returned from the function will be exported for external public use.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The use of an IIFE implies that our program only ever needs a single central instance of the module, commonly referred to as a \"singleton.\" Indeed, this specific example is simple enough that there's no obvious reason we'd need anything more than just one instance of the ", "type": "text"}, {"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " module.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Module Factory (Multiple Instances)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But if we did want to define a module that supported multiple instances in our program, we can slightly tweak the code:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// factory function, not singleton IIFE\nfunction defineStudent() {\n    var records = [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ];\n\n    var publicAPI = {\n        getName\n    };\n\n    return publicAPI;\n\n    // ************************\n\n    function getName(studentID) {\n        var student = records.find(\n            student => student.id == studentID\n        );\n        return student.name;\n    }\n}\n\nvar fullTime = defineStudent();\nfullTime.getName(73);            // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Rather than specifying ", "type": "text"}, {"text": "defineStudent()", "type": "text", "marks": [{"type": "code"}]}, {"text": " as an IIFE, we just define it as a normal standalone function, which is commonly referred to in this context as a \"module factory\" function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We then call the module factory, producing an instance of the module that we label ", "type": "text"}, {"text": "fullTime", "type": "text", "marks": [{"type": "code"}]}, {"text": ". This module instance implies a new instance of the inner scope, and thus a new closure that ", "type": "text"}, {"text": "getName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " holds over ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": ". ", "type": "text"}, {"text": "fullTime.getName(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " now invokes the method on that specific instance.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Classic Module Definition", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So to clarify what makes something a classic module:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "There must be an outer scope, typically from a module factory function running at least once.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The module's inner scope must have at least one piece of hidden information that represents state for the module.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The module must return on its public API a reference to at least one function that has closure over the hidden module state (so that this state is actually preserved).", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "You'll likely run across other variations on this classic module approach, which we'll look at in more detail in Appendix A.", "type": "text"}]}]}, "article_text": "Modules (Stateful Access Control)\n\nTo embody the full spirit of the module pattern, we not only need grouping and state, but also access control through visibility (private vs. public).\n\nLet's turn Student from the previous section into a module. We'll start with a form I call the \"classic module,\" which was originally referred to as the \"revealing module\" when it first emerged in the early 2000s. Consider:\n\nvar Student = (function defineStudent(){\n    var records = [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ];\n\n    var publicAPI = {\n        getName\n    };\n\n    return publicAPI;\n\n    // ************************\n\n    function getName(studentID) {\n        var student = records.find(\n            student => student.id == studentID\n        );\n        return student.name;\n    }\n})();\n\nStudent.getName(73);   // Suzy\n\nStudent is now an instance of a module. It features a public API with a single method: getName(..). This method is able to access the private hidden records data.\n\nWARNING:\n\nI should point out that the explicit student data being hard-coded into this module definition is just for our illustration purposes. A typical module in your program will receive this data from an outside source, typically loaded from databases, JSON data files, Ajax calls, etc. The data is then injected into the module instance typically through method(s) on the module's public API.\n\nHow does the classic module format work?\n\nNotice that the instance of the module is created by the defineStudent() IIFE being executed. This IIFE returns an object (named publicAPI) that has a property on it referencing the inner getName(..) function.\n\nNaming the object publicAPI is stylistic preference on my part. The object can be named whatever you like (JS doesn't care), or you can just return an object directly without assigning it to any internal named variable. More on this choice in Appendix A.\n\nFrom the outside, Student.getName(..) invokes this exposed inner function, which maintains access to the inner records variable via closure.\n\nYou don't have to return an object with a function as one of its properties. You could just return a function directly, in place of the object. That still satisfies all the core bits of a classic module.\n\nBy virtue of how lexical scope works, defining variables and functions inside your outer module definition function makes everything by default private. Only properties added to the public API object returned from the function will be exported for external public use.\n\nThe use of an IIFE implies that our program only ever needs a single central instance of the module, commonly referred to as a \"singleton.\" Indeed, this specific example is simple enough that there's no obvious reason we'd need anything more than just one instance of the Student module.\n\nModule Factory (Multiple Instances)\n\nBut if we did want to define a module that supported multiple instances in our program, we can slightly tweak the code:\n\n// factory function, not singleton IIFE\nfunction defineStudent() {\n    var records = [\n        { id: 14, name: \"Kyle\", grade: 86 },\n        { id: 73, name: \"Suzy\", grade: 87 },\n        { id: 112, name: \"Frank\", grade: 75 },\n        { id: 6, name: \"Sarah\", grade: 91 }\n    ];\n\n    var publicAPI = {\n        getName\n    };\n\n    return publicAPI;\n\n    // ************************\n\n    function getName(studentID) {\n        var student = records.find(\n            student => student.id == studentID\n        );\n        return student.name;\n    }\n}\n\nvar fullTime = defineStudent();\nfullTime.getName(73);            // Suzy\n\nRather than specifying defineStudent() as an IIFE, we just define it as a normal standalone function, which is commonly referred to in this context as a \"module factory\" function.\n\nWe then call the module factory, producing an instance of the module that we label fullTime. This module instance implies a new instance of the inner scope, and thus a new closure that getName(..) holds over records. fullTime.getName(..) now invokes the method on that specific instance.\n\nClassic Module Definition\n\nSo to clarify what makes something a classic module:\n\nThere must be an outer scope, typically from a module factory function running at least once.\n\nThe module's inner scope must have at least one piece of hidden information that represents state for the module.\n\nThe module must return on its public API a reference to at least one function that has closure over the hidden module state (so that this state is actually preserved).\n\nYou'll likely run across other variations on this classic module approach, which we'll look at in more detail in Appendix A."}, "id": 239}]}, {"data": {"uuid": "79f1fbcd-cd1d-49b7-91d3-506b6169f265", "user": 1, "title": "Node CommonJS Modules", "author": "Kyle Simpson", "created_on": "2023-06-09 01:50:04.650128+00:00", "updated_on": "2023-06-09 01:50:30.970299+00:00", "article_html": "<h2>Node CommonJS Modules</h2><p>In Chapter 4, we introduced the CommonJS module format used by Node. Unlike the classic module format described earlier, where you could bundle the module factory or IIFE alongside any other code including other modules, CommonJS modules are file-based; one module per file.</p><p>Let's tweak our module example to adhere to that format:</p><pre><code>module.exports.getName = getName;\n\n// ************************\n\nvar records = [\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    { id: 6, name: \"Sarah\", grade: 91 }\n];\n\nfunction getName(studentID) {\n    var student = records.find(\n        student =&gt; student.id == studentID\n    );\n    return student.name;\n}</code></pre><p>The <code>records</code> and <code>getName</code> identifiers are in the top-level scope of this module, but that's not the global scope (as explained in Chapter 4). As such, everything here is <em>by default</em> private to the module.</p><p>To expose something on the public API of a CommonJS module, you add a property to the empty object provided as <code>module.exports</code>. In some older legacy code, you may run across references to just a bare <code>exports</code>, but for code clarity you should always fully qualify that reference with the <code>module.</code> prefix.</p><p>For style purposes, I like to put my \"exports\" at the top and my module implementation at the bottom. But these exports can be placed anywhere. I strongly recommend collecting them all together, either at the top or bottom of your file.</p><p>Some developers have the habit of replacing the default exports object, like this:</p><pre><code>// defining a new object for the API\nmodule.exports = {\n    // ..exports..\n};</code></pre><p>There are some quirks with this approach, including unexpected behavior if multiple such modules circularly depend on each other. As such, I recommend against replacing the object. If you want to assign multiple exports at once, using object literal style definition, you can do this instead:</p><pre><code>Object.assign(module.exports,{\n   // .. exports ..\n});</code></pre><p>What's happening here is defining the <code>{ .. }</code> object literal with your module's public API specified, and then <code>Object.assign(..)</code> is performing a shallow copy of all those properties onto the existing <code>module.exports</code> object, instead of replacing it This is a nice balance of convenience and safer module behavior.</p><p>To include another module instance into your module/program, use Node's <code>require(..)</code> method. Assuming this module is located at \"/path/to/student.js\", this is how we can access it:</p><pre><code>var Student = require(\"/path/to/student.js\");\n\nStudent.getName(73);\n// Suzy</code></pre><p><code>Student</code> now references the public API of our example module.</p><p>CommonJS modules behave as singleton instances, similar to the IIFE module definition style presented before. No matter how many times you <code>require(..)</code> the same module, you just get additional references to the single shared module instance.</p><p><code>require(..)</code> is an all-or-nothing mechanism; it includes a reference of the entire exposed public API of the module. To effectively access only part of the API, the typical approach looks like this:</p><pre><code>var getName = require(\"/path/to/student.js\").getName;\n\n// or alternately:\n\nvar { getName } = require(\"/path/to/student.js\");</code></pre><p>Similar to the classic module format, the publicly exported methods of a CommonJS module's API hold closures over the internal module details. That's how the module singleton state is maintained across the lifetime of your program.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>In Node <code>require(\"student\")</code> statements, non-absolute paths (<code>\"student\"</code>) assume a \".js\" file extension and search \"node_modules\".</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Node CommonJS Modules", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Chapter 4, we introduced the CommonJS module format used by Node. Unlike the classic module format described earlier, where you could bundle the module factory or IIFE alongside any other code including other modules, CommonJS modules are file-based; one module per file.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's tweak our module example to adhere to that format:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "module.exports.getName = getName;\n\n// ************************\n\nvar records = [\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    { id: 6, name: \"Sarah\", grade: 91 }\n];\n\nfunction getName(studentID) {\n    var student = records.find(\n        student => student.id == studentID\n    );\n    return student.name;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "getName", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifiers are in the top-level scope of this module, but that's not the global scope (as explained in Chapter 4). As such, everything here is ", "type": "text"}, {"text": "by default", "type": "text", "marks": [{"type": "italic"}]}, {"text": " private to the module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To expose something on the public API of a CommonJS module, you add a property to the empty object provided as ", "type": "text"}, {"text": "module.exports", "type": "text", "marks": [{"type": "code"}]}, {"text": ". In some older legacy code, you may run across references to just a bare ", "type": "text"}, {"text": "exports", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but for code clarity you should always fully qualify that reference with the ", "type": "text"}, {"text": "module.", "type": "text", "marks": [{"type": "code"}]}, {"text": " prefix.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For style purposes, I like to put my \"exports\" at the top and my module implementation at the bottom. But these exports can be placed anywhere. I strongly recommend collecting them all together, either at the top or bottom of your file.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some developers have the habit of replacing the default exports object, like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// defining a new object for the API\nmodule.exports = {\n    // ..exports..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are some quirks with this approach, including unexpected behavior if multiple such modules circularly depend on each other. As such, I recommend against replacing the object. If you want to assign multiple exports at once, using object literal style definition, you can do this instead:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "Object.assign(module.exports,{\n   // .. exports ..\n});", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What's happening here is defining the ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " object literal with your module's public API specified, and then ", "type": "text"}, {"text": "Object.assign(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is performing a shallow copy of all those properties onto the existing ", "type": "text"}, {"text": "module.exports", "type": "text", "marks": [{"type": "code"}]}, {"text": " object, instead of replacing it This is a nice balance of convenience and safer module behavior.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To include another module instance into your module/program, use Node's ", "type": "text"}, {"text": "require(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method. Assuming this module is located at \"/path/to/student.js\", this is how we can access it:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var Student = require(\"/path/to/student.js\");\n\nStudent.getName(73);\n// Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " now references the public API of our example module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "CommonJS modules behave as singleton instances, similar to the IIFE module definition style presented before. No matter how many times you ", "type": "text"}, {"text": "require(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " the same module, you just get additional references to the single shared module instance.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "require(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is an all-or-nothing mechanism; it includes a reference of the entire exposed public API of the module. To effectively access only part of the API, the typical approach looks like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var getName = require(\"/path/to/student.js\").getName;\n\n// or alternately:\n\nvar { getName } = require(\"/path/to/student.js\");", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Similar to the classic module format, the publicly exported methods of a CommonJS module's API hold closures over the internal module details. That's how the module singleton state is maintained across the lifetime of your program.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "In Node ", "type": "text"}, {"text": "require(\"student\")", "type": "text", "marks": [{"type": "code"}]}, {"text": " statements, non-absolute paths (", "type": "text"}, {"text": "\"student\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ") assume a \".js\" file extension and search \"node_modules\".", "type": "text"}]}]}]}]}]}, "article_text": "Node CommonJS Modules\n\nIn Chapter 4, we introduced the CommonJS module format used by Node. Unlike the classic module format described earlier, where you could bundle the module factory or IIFE alongside any other code including other modules, CommonJS modules are file-based; one module per file.\n\nLet's tweak our module example to adhere to that format:\n\nmodule.exports.getName = getName;\n\n// ************************\n\nvar records = [\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    { id: 6, name: \"Sarah\", grade: 91 }\n];\n\nfunction getName(studentID) {\n    var student = records.find(\n        student => student.id == studentID\n    );\n    return student.name;\n}\n\nThe records and getName identifiers are in the top-level scope of this module, but that's not the global scope (as explained in Chapter 4). As such, everything here is by default private to the module.\n\nTo expose something on the public API of a CommonJS module, you add a property to the empty object provided as module.exports. In some older legacy code, you may run across references to just a bare exports, but for code clarity you should always fully qualify that reference with the module. prefix.\n\nFor style purposes, I like to put my \"exports\" at the top and my module implementation at the bottom. But these exports can be placed anywhere. I strongly recommend collecting them all together, either at the top or bottom of your file.\n\nSome developers have the habit of replacing the default exports object, like this:\n\n// defining a new object for the API\nmodule.exports = {\n    // ..exports..\n};\n\nThere are some quirks with this approach, including unexpected behavior if multiple such modules circularly depend on each other. As such, I recommend against replacing the object. If you want to assign multiple exports at once, using object literal style definition, you can do this instead:\n\nObject.assign(module.exports,{\n   // .. exports ..\n});\n\nWhat's happening here is defining the { .. } object literal with your module's public API specified, and then Object.assign(..) is performing a shallow copy of all those properties onto the existing module.exports object, instead of replacing it This is a nice balance of convenience and safer module behavior.\n\nTo include another module instance into your module/program, use Node's require(..) method. Assuming this module is located at \"/path/to/student.js\", this is how we can access it:\n\nvar Student = require(\"/path/to/student.js\");\n\nStudent.getName(73);\n// Suzy\n\nStudent now references the public API of our example module.\n\nCommonJS modules behave as singleton instances, similar to the IIFE module definition style presented before. No matter how many times you require(..) the same module, you just get additional references to the single shared module instance.\n\nrequire(..) is an all-or-nothing mechanism; it includes a reference of the entire exposed public API of the module. To effectively access only part of the API, the typical approach looks like this:\n\nvar getName = require(\"/path/to/student.js\").getName;\n\n// or alternately:\n\nvar { getName } = require(\"/path/to/student.js\");\n\nSimilar to the classic module format, the publicly exported methods of a CommonJS module's API hold closures over the internal module details. That's how the module singleton state is maintained across the lifetime of your program.\n\nNOTE:\n\nIn Node require(\"student\") statements, non-absolute paths (\"student\") assume a \".js\" file extension and search \"node_modules\"."}, "id": 240}, {"data": {"uuid": "163a19ed-3347-48ed-aa7a-2ce54d080b22", "user": 1, "title": "Modern ES Modules (ESM)", "author": "Kyle Simpson", "created_on": "2023-06-09 01:50:56.545562+00:00", "updated_on": "2023-06-09 01:51:37.196239+00:00", "article_html": "<h2>Modern ES Modules (ESM)</h2><p>The ESM format shares several similarities with the CommonJS format. ESM is file-based, and module instances are singletons, with everything private <em>by default</em>. One notable difference is that ESM files are assumed to be strict-mode, without needing a <code>\"use strict\"</code> pragma at the top. There's no way to define an ESM as non-strict-mode.</p><p>Instead of <code>module.exports</code> in CommonJS, ESM uses an <code>export</code> keyword to expose something on the public API of the module. The <code>import</code> keyword replaces the <code>require(..)</code> statement. Let's adjust \"students.js\" to use the ESM format:</p><pre><code>export { getName };\n\n// ************************\n\nvar records = [\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    { id: 6, name: \"Sarah\", grade: 91 }\n];\n\nfunction getName(studentID) {\n    var student = records.find(\n        student =&gt; student.id == studentID\n    );\n    return student.name;\n}</code></pre><p>The only change here is the <code>export { getName }</code> statement. As before, <code>export</code> statements can appear anywhere throughout the file, though <code>export</code> must be at the top-level scope; it cannot be inside any other block or function.</p><p>ESM offers a fair bit of variation on how the <code>export</code> statements can be specified. For example:</p><pre><code>export function getName(studentID) {\n    // ..\n}</code></pre><p>Even though <code>export</code> appears before the <code>function</code> keyword here, this form is still a <code>function</code> declaration that also happens to be exported. That is, the <code>getName</code> identifier is <em>function hoisted</em> (see Chapter 5), so it's available throughout the whole scope of the module.</p><p>Another allowed variation:</p><pre><code>export default function getName(studentID) {\n    // ..\n}</code></pre><p>This is a so-called \"default export,\" which has different semantics from other exports. In essence, a \"default export\" is a shorthand for consumers of the module when they <code>import</code>, giving them a terser syntax when they only need this single default API member.</p><p>Non-<code>default</code> exports are referred to as \"named exports.\"</p><p>The <code>import</code> keyword\u2014like <code>export</code>, it must be used only at the top level of an ESM outside of any blocks or functions\u2014also has a number of variations in syntax. The first is referred to as \"named import\":</p><pre><code>import { getName } from \"/path/to/students.js\";\n\ngetName(73);   // Suzy</code></pre><p>As you can see, this form imports only the specifically named public API members from a module (skipping anything not named explicitly), and it adds those identifiers to the top-level scope of the current module. This type of import is a familiar style to those used to package imports in languages like Java.</p><p>Multiple API members can be listed inside the <code>{ .. }</code> set, separated with commas. A named import can also be <em>renamed</em> with the <code>as</code> keyword:</p><pre><code>import { getName as getStudentName }\n   from \"/path/to/students.js\";\n\ngetStudentName(73);\n// Suzy</code></pre><p>If <code>getName</code> is a \"default export\" of the module, we can import it like this:</p><pre><code>import getName from \"/path/to/students.js\";\n\ngetName(73);   // Suzy</code></pre><p>The only difference here is dropping the <code>{ }</code> around the import binding. If you want to mix a default import with other named imports:</p><pre><code>import { default as getName, /* .. others .. */ }\n   from \"/path/to/students.js\";\n\ngetName(73);   // Suzy</code></pre><p>By contrast, the other major variation on <code>import</code> is called \"namespace import\":</p><pre><code>import * as Student from \"/path/to/students.js\";\n\nStudent.getName(73);   // Suzy</code></pre><p>As is likely obvious, the <code>*</code> imports everything exported to the API, default and named, and stores it all under the single namespace identifier as specified. This approach most closely matches the form of classic modules for most of JS's history.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>As of the time of this writing, modern browsers have supported ESM for a few years now, but Node's stable'ish support for ESM is fairly recent, and has been evolving for quite a while. The evolution is likely to continue for another year or more; the introduction of ESM to JS back in ES6 created a number of challenging compatibility concerns for Node's interop with CommonJS modules. Consult Node's ESM documentation for all the latest details: <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://nodejs.org/api/esm.html\">https://nodejs.org/api/esm.html</a></p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Modern ES Modules (ESM)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ESM format shares several similarities with the CommonJS format. ESM is file-based, and module instances are singletons, with everything private ", "type": "text"}, {"text": "by default", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". One notable difference is that ESM files are assumed to be strict-mode, without needing a ", "type": "text"}, {"text": "\"use strict\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " pragma at the top. There's no way to define an ESM as non-strict-mode.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Instead of ", "type": "text"}, {"text": "module.exports", "type": "text", "marks": [{"type": "code"}]}, {"text": " in CommonJS, ESM uses an ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword to expose something on the public API of the module. The ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword replaces the ", "type": "text"}, {"text": "require(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement. Let's adjust \"students.js\" to use the ESM format:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "export { getName };\n\n// ************************\n\nvar records = [\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    { id: 6, name: \"Sarah\", grade: 91 }\n];\n\nfunction getName(studentID) {\n    var student = records.find(\n        student => student.id == studentID\n    );\n    return student.name;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The only change here is the ", "type": "text"}, {"text": "export { getName }", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement. As before, ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " statements can appear anywhere throughout the file, though ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " must be at the top-level scope; it cannot be inside any other block or function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ESM offers a fair bit of variation on how the ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " statements can be specified. For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "export function getName(studentID) {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even though ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " appears before the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword here, this form is still a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration that also happens to be exported. That is, the ", "type": "text"}, {"text": "getName", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier is ", "type": "text"}, {"text": "function hoisted", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (see Chapter 5), so it's available throughout the whole scope of the module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another allowed variation:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "export default function getName(studentID) {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is a so-called \"default export,\" which has different semantics from other exports. In essence, a \"default export\" is a shorthand for consumers of the module when they ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": ", giving them a terser syntax when they only need this single default API member.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Non-", "type": "text"}, {"text": "default", "type": "text", "marks": [{"type": "code"}]}, {"text": " exports are referred to as \"named exports.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword\u2014like ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it must be used only at the top level of an ESM outside of any blocks or functions\u2014also has a number of variations in syntax. The first is referred to as \"named import\":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import { getName } from \"/path/to/students.js\";\n\ngetName(73);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As you can see, this form imports only the specifically named public API members from a module (skipping anything not named explicitly), and it adds those identifiers to the top-level scope of the current module. This type of import is a familiar style to those used to package imports in languages like Java.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Multiple API members can be listed inside the ", "type": "text"}, {"text": "{ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " set, separated with commas. A named import can also be ", "type": "text"}, {"text": "renamed", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with the ", "type": "text"}, {"text": "as", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import { getName as getStudentName }\n   from \"/path/to/students.js\";\n\ngetStudentName(73);\n// Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If ", "type": "text"}, {"text": "getName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a \"default export\" of the module, we can import it like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import getName from \"/path/to/students.js\";\n\ngetName(73);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The only difference here is dropping the ", "type": "text"}, {"text": "{ }", "type": "text", "marks": [{"type": "code"}]}, {"text": " around the import binding. If you want to mix a default import with other named imports:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import { default as getName, /* .. others .. */ }\n   from \"/path/to/students.js\";\n\ngetName(73);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By contrast, the other major variation on ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " is called \"namespace import\":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import * as Student from \"/path/to/students.js\";\n\nStudent.getName(73);   // Suzy", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As is likely obvious, the ", "type": "text"}, {"text": "*", "type": "text", "marks": [{"type": "code"}]}, {"text": " imports everything exported to the API, default and named, and stores it all under the single namespace identifier as specified. This approach most closely matches the form of classic modules for most of JS's history.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "As of the time of this writing, modern browsers have supported ESM for a few years now, but Node's stable'ish support for ESM is fairly recent, and has been evolving for quite a while. The evolution is likely to continue for another year or more; the introduction of ESM to JS back in ES6 created a number of challenging compatibility concerns for Node's interop with CommonJS modules. Consult Node's ESM documentation for all the latest details: ", "type": "text"}, {"text": "https://nodejs.org/api/esm.html", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://nodejs.org/api/esm.html", "class": null, "target": "_blank"}}]}]}]}]}]}]}, "article_text": "Modern ES Modules (ESM)\n\nThe ESM format shares several similarities with the CommonJS format. ESM is file-based, and module instances are singletons, with everything private by default. One notable difference is that ESM files are assumed to be strict-mode, without needing a \"use strict\" pragma at the top. There's no way to define an ESM as non-strict-mode.\n\nInstead of module.exports in CommonJS, ESM uses an export keyword to expose something on the public API of the module. The import keyword replaces the require(..) statement. Let's adjust \"students.js\" to use the ESM format:\n\nexport { getName };\n\n// ************************\n\nvar records = [\n    { id: 14, name: \"Kyle\", grade: 86 },\n    { id: 73, name: \"Suzy\", grade: 87 },\n    { id: 112, name: \"Frank\", grade: 75 },\n    { id: 6, name: \"Sarah\", grade: 91 }\n];\n\nfunction getName(studentID) {\n    var student = records.find(\n        student => student.id == studentID\n    );\n    return student.name;\n}\n\nThe only change here is the export { getName } statement. As before, export statements can appear anywhere throughout the file, though export must be at the top-level scope; it cannot be inside any other block or function.\n\nESM offers a fair bit of variation on how the export statements can be specified. For example:\n\nexport function getName(studentID) {\n    // ..\n}\n\nEven though export appears before the function keyword here, this form is still a function declaration that also happens to be exported. That is, the getName identifier is function hoisted (see Chapter 5), so it's available throughout the whole scope of the module.\n\nAnother allowed variation:\n\nexport default function getName(studentID) {\n    // ..\n}\n\nThis is a so-called \"default export,\" which has different semantics from other exports. In essence, a \"default export\" is a shorthand for consumers of the module when they import, giving them a terser syntax when they only need this single default API member.\n\nNon-default exports are referred to as \"named exports.\"\n\nThe import keyword\u2014like export, it must be used only at the top level of an ESM outside of any blocks or functions\u2014also has a number of variations in syntax. The first is referred to as \"named import\":\n\nimport { getName } from \"/path/to/students.js\";\n\ngetName(73);   // Suzy\n\nAs you can see, this form imports only the specifically named public API members from a module (skipping anything not named explicitly), and it adds those identifiers to the top-level scope of the current module. This type of import is a familiar style to those used to package imports in languages like Java.\n\nMultiple API members can be listed inside the { .. } set, separated with commas. A named import can also be renamed with the as keyword:\n\nimport { getName as getStudentName }\n   from \"/path/to/students.js\";\n\ngetStudentName(73);\n// Suzy\n\nIf getName is a \"default export\" of the module, we can import it like this:\n\nimport getName from \"/path/to/students.js\";\n\ngetName(73);   // Suzy\n\nThe only difference here is dropping the { } around the import binding. If you want to mix a default import with other named imports:\n\nimport { default as getName, /* .. others .. */ }\n   from \"/path/to/students.js\";\n\ngetName(73);   // Suzy\n\nBy contrast, the other major variation on import is called \"namespace import\":\n\nimport * as Student from \"/path/to/students.js\";\n\nStudent.getName(73);   // Suzy\n\nAs is likely obvious, the * imports everything exported to the API, default and named, and stores it all under the single namespace identifier as specified. This approach most closely matches the form of classic modules for most of JS's history.\n\nNOTE:\n\nAs of the time of this writing, modern browsers have supported ESM for a few years now, but Node's stable'ish support for ESM is fairly recent, and has been evolving for quite a while. The evolution is likely to continue for another year or more; the introduction of ESM to JS back in ES6 created a number of challenging compatibility concerns for Node's interop with CommonJS modules. Consult Node's ESM documentation for all the latest details: https://nodejs.org/api/esm.html"}, "id": 241}, {"data": {"uuid": "74e6d868-6f47-4da8-b2d4-d309530af2c2", "user": 1, "title": "Exit Scope", "author": "Kyle Simpson", "created_on": "2023-06-09 01:51:57.030521+00:00", "updated_on": "2023-06-09 01:52:14.593399+00:00", "article_html": "<h2>Exit Scope</h2><p>Whether you use the classic module format (browser or Node), CommonJS format (in Node), or ESM format (browser or Node), modules are one of the most effective ways to structure and organize your program's functionality and data.</p><p>The module pattern is the conclusion of our journey in this book of learning how we can use the rules of lexical scope to place variables and functions in proper locations. POLE is the defensive <em>private by default</em> posture we always take, making sure we avoid over-exposure and interact only with the minimal public API surface area necessary.</p><p>And underneath modules, the <em>magic</em> of how all our module state is maintained is closures leveraging the lexical scope system.</p><p>That's it for the main text. Congratulations on quite a journey so far! As I've said numerous times throughout, it's a really good idea to pause, reflect, and practice what we've just discussed.</p><p>When you're comfortable and ready, check out the appendices, which dig deeper into some of the corners of these topics, and also challenge you with some practice exercises to solidify what you've learned.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Exit Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Whether you use the classic module format (browser or Node), CommonJS format (in Node), or ESM format (browser or Node), modules are one of the most effective ways to structure and organize your program's functionality and data.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The module pattern is the conclusion of our journey in this book of learning how we can use the rules of lexical scope to place variables and functions in proper locations. POLE is the defensive ", "type": "text"}, {"text": "private by default", "type": "text", "marks": [{"type": "italic"}]}, {"text": " posture we always take, making sure we avoid over-exposure and interact only with the minimal public API surface area necessary.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And underneath modules, the ", "type": "text"}, {"text": "magic", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of how all our module state is maintained is closures leveraging the lexical scope system.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's it for the main text. Congratulations on quite a journey so far! As I've said numerous times throughout, it's a really good idea to pause, reflect, and practice what we've just discussed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When you're comfortable and ready, check out the appendices, which dig deeper into some of the corners of these topics, and also challenge you with some practice exercises to solidify what you've learned.", "type": "text"}]}]}, "article_text": "Exit Scope\n\nWhether you use the classic module format (browser or Node), CommonJS format (in Node), or ESM format (browser or Node), modules are one of the most effective ways to structure and organize your program's functionality and data.\n\nThe module pattern is the conclusion of our journey in this book of learning how we can use the rules of lexical scope to place variables and functions in proper locations. POLE is the defensive private by default posture we always take, making sure we avoid over-exposure and interact only with the minimal public API surface area necessary.\n\nAnd underneath modules, the magic of how all our module state is maintained is closures leveraging the lexical scope system.\n\nThat's it for the main text. Congratulations on quite a journey so far! As I've said numerous times throughout, it's a really good idea to pause, reflect, and practice what we've just discussed.\n\nWhen you're comfortable and ready, check out the appendices, which dig deeper into some of the corners of these topics, and also challenge you with some practice exercises to solidify what you've learned."}, "id": 242}]}, {"data": {"uuid": "0fa501d7-3779-4c00-b2d2-e8929b64dbe6", "user": 1, "title": "Appendix A: Exploring Further", "author": "Kyle Simpson", "created_on": "2023-06-09 01:52:48.719890+00:00", "updated_on": "2023-06-09 01:54:33.906683+00:00", "article_html": "<h1>Appendix A: Exploring Further</h1><p>We will now explore a number of nuances and edges around many of the topics covered in the main text of this book. This appendix is optional, supporting material.</p><p>Some people find diving too deeply into the nuanced corner cases and varying opinions creates nothing but noise and distraction\u2014supposedly, developers are better served by sticking to the commonly-tread paths. My approach has been criticized as being impractical and counterproductive. I understand and appreciate that perspective, even if I don't necessarily share it.</p><p>I believe it's better to be empowered by knowledge of how things work than to just gloss over details with assumptions and lack of curiosity. Ultimately, you will encounter situations where something bubbles up from a piece you hadn't explored. In other words, you won't get to spend all your time riding on the smooth <em>happy path</em>. Wouldn't you rather be prepared for the inevitable bumps of off-roading?</p><p>These discussions will also be more heavily influenced by my opinions than the main text was, so keep that in mind as you consume and consider what is presented. This appendix is a bit like a collection of mini-blog posts that elaborate on various book topics. It's long and deep in the weeds, so take your time and don't rush through everything here.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Appendix A: Exploring Further", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We will now explore a number of nuances and edges around many of the topics covered in the main text of this book. This appendix is optional, supporting material.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some people find diving too deeply into the nuanced corner cases and varying opinions creates nothing but noise and distraction\u2014supposedly, developers are better served by sticking to the commonly-tread paths. My approach has been criticized as being impractical and counterproductive. I understand and appreciate that perspective, even if I don't necessarily share it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I believe it's better to be empowered by knowledge of how things work than to just gloss over details with assumptions and lack of curiosity. Ultimately, you will encounter situations where something bubbles up from a piece you hadn't explored. In other words, you won't get to spend all your time riding on the smooth ", "type": "text"}, {"text": "happy path", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Wouldn't you rather be prepared for the inevitable bumps of off-roading?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These discussions will also be more heavily influenced by my opinions than the main text was, so keep that in mind as you consume and consider what is presented. This appendix is a bit like a collection of mini-blog posts that elaborate on various book topics. It's long and deep in the weeds, so take your time and don't rush through everything here.", "type": "text"}]}]}, "article_text": "Appendix A: Exploring Further\n\nWe will now explore a number of nuances and edges around many of the topics covered in the main text of this book. This appendix is optional, supporting material.\n\nSome people find diving too deeply into the nuanced corner cases and varying opinions creates nothing but noise and distraction\u2014supposedly, developers are better served by sticking to the commonly-tread paths. My approach has been criticized as being impractical and counterproductive. I understand and appreciate that perspective, even if I don't necessarily share it.\n\nI believe it's better to be empowered by knowledge of how things work than to just gloss over details with assumptions and lack of curiosity. Ultimately, you will encounter situations where something bubbles up from a piece you hadn't explored. In other words, you won't get to spend all your time riding on the smooth happy path. Wouldn't you rather be prepared for the inevitable bumps of off-roading?\n\nThese discussions will also be more heavily influenced by my opinions than the main text was, so keep that in mind as you consume and consider what is presented. This appendix is a bit like a collection of mini-blog posts that elaborate on various book topics. It's long and deep in the weeds, so take your time and don't rush through everything here."}, "id": 243, "children": [{"data": {"uuid": "ce4f813a-494a-44a5-93df-f3b9f287c0ed", "user": 1, "title": "Implied Scopes", "author": "Kyle Simpson", "created_on": "2023-06-09 01:55:01.286755+00:00", "updated_on": "2023-06-09 01:55:24.361883+00:00", "article_html": "<h2>Implied Scopes</h2><p>Scopes are sometimes created in non-obvious places. In practice, these implied scopes don't often impact your program behavior, but it's still useful to know they're happening. Keep an eye out for the following surprising scopes:</p><ul><li><p>Parameter scope</p></li><li><p>Function name scope</p></li></ul><h3></h3><h3>Parameter Scope</h3><p>The conversation metaphor in Chapter 2 implies that function parameters are basically the same as locally declared variables in the function scope. But that's not always true.</p><p>Consider:</p><pre><code>// outer/global scope: RED(1)\n\nfunction getStudentName(studentID) {\n    // function scope: BLUE(2)\n\n    // ..\n}</code></pre><p>Here, <code>studentID</code> is a considered a \"simple\" parameter, so it does behave as a member of the BLUE(2) function scope. But if we change it to be a non-simple parameter, that's no longer technically the case. Parameter forms considered non-simple include parameters with default values, rest parameters (using <code>...</code>), and destructured parameters.</p><p>Consider:</p><pre><code>// outer/global scope: RED(1)\n\nfunction getStudentName(/*BLUE(2)*/ studentID = 0) {\n    // function scope: GREEN(3)\n\n    // ..\n}</code></pre><p>Here, the parameter list essentially becomes its own scope, and the function's scope is then nested inside <em>that</em> scope.</p><p>Why? What difference does it make? The non-simple parameter forms introduce various corner cases, so the parameter list becomes its own scope to more effectively deal with them.</p><p>Consider:</p><pre><code>function getStudentName(studentID = maxID, maxID) {\n    // ..\n}</code></pre><p>Assuming left-to-right operations, the default <code>= maxID</code> for the <code>studentID</code> parameter requires a <code>maxID</code> to already exist (and to have been initialized). This code produces a TDZ error (Chapter 5). The reason is that <code>maxID</code> is declared in the parameter scope, but it's not yet been initialized because of the order of parameters. If the parameter order is flipped, no TDZ error occurs:</p><pre><code>function getStudentName(maxID,studentID = maxID) {\n    // ..\n}</code></pre><p>The complication gets even more <em>in the weeds</em> if we introduce a function expression into the default parameter position, which then can create its own closure (Chapter 7) over parameters in this implied parameter scope:</p><pre><code>function whatsTheDealHere(id,defaultID = () =&gt; id) {\n    id = 5;\n    console.log( defaultID() );\n}\n\nwhatsTheDealHere(3);\n// 5</code></pre><p>That snippet probably makes sense, because the <code>defaultID()</code> arrow function closes over the <code>id</code> parameter/variable, which we then re-assign to <code>5</code>. But now let's introduce a shadowing definition of <code>id</code> in the function scope:</p><pre><code>function whatsTheDealHere(id,defaultID = () =&gt; id) {\n    var id = 5;\n    console.log( defaultID() );\n}\n\nwhatsTheDealHere(3);\n// 3</code></pre><p>Uh oh! The <code>var id = 5</code> is shadowing the <code>id</code> parameter, but the closure of the <code>defaultID()</code> function is over the parameter, not the shadowing variable in the function body. This proves there's a scope bubble around the parameter list.</p><p>But it gets even crazier than that!</p><pre><code>function whatsTheDealHere(id,defaultID = () =&gt; id) {\n    var id;\n\n    console.log(`local variable 'id': ${ id }`);\n    console.log(\n        `parameter 'id' (closure): ${ defaultID() }`\n    );\n\n    console.log(\"reassigning 'id' to 5\");\n    id = 5;\n\n    console.log(`local variable 'id': ${ id }`);\n    console.log(\n        `parameter 'id' (closure): ${ defaultID() }`\n    );\n}\n\nwhatsTheDealHere(3);\n// local variable 'id': 3   &lt;--- Huh!? Weird!\n// parameter 'id' (closure): 3\n// reassigning 'id' to 5\n// local variable 'id': 5\n// parameter 'id' (closure): 3</code></pre><p>The strange bit here is the first console message. At that moment, the shadowing <code>id</code> local variable has just been <code>var id</code> declared, which Chapter 5 asserts is typically auto-initialized to <code>undefined</code> at the top of its scope. Why doesn't it print <code>undefined</code>?</p><p>In this specific corner case (for legacy compat reasons), JS doesn't auto-initialize <code>id</code> to <code>undefined</code>, but rather to the value of the <code>id</code> parameter (<code>3</code>)!</p><p>Though the two <code>id</code>s look at that moment like they're one variable, they're actually still separate (and in separate scopes). The <code>id = 5</code> assignment makes the divergence observable, where the <code>id</code> parameter stays <code>3</code> and the local variable becomes <code>5</code>.</p><p>My advice to avoid getting bitten by these weird nuances:</p><ul><li><p>Never shadow parameters with local variables</p></li><li><p>Avoid using a default parameter function that closes over any of the parameters</p></li></ul><p>At least now you're aware and can be careful about the fact that the parameter list is its own scope if any of the parameters are non-simple.</p><h3></h3><h3>Function Name Scope</h3><p>In the \"Function Name Scope\" section in Chapter 3, I asserted that the name of a function expression is added to the function's own scope. Recall:</p><pre><code>var askQuestion = function ofTheTeacher(){\n    // ..\n};</code></pre><p>It's true that <code>ofTheTeacher</code> is not added to the enclosing scope (where <code>askQuestion</code> is declared), but it's also not <em>just</em> added to the scope of the function, the way you're likely assuming. It's another strange corner case of implied scope.</p><p>The name identifier of a function expression is in its own implied scope, nested between the outer enclosing scope and the main inner function scope.</p><p>If <code>ofTheTeacher</code> was in the function's scope, we'd expect an error here:</p><pre><code>var askQuestion = function ofTheTeacher(){\n    // why is this not a duplicate declaration error?\n    let ofTheTeacher = \"Confused, yet?\";\n};</code></pre><p>The <code>let</code> declaration form does not allow re-declaration (see Chapter 5). But this is perfectly legal shadowing, not re-declaration, because the two <code>ofTheTeacher</code> identifiers are in separate scopes.</p><p>You'll rarely run into any case where the scope of a function's name identifier matters. But again, it's good to know how these mechanisms actually work. To avoid being bitten, never shadow function name identifiers.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Implied Scopes", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Scopes are sometimes created in non-obvious places. In practice, these implied scopes don't often impact your program behavior, but it's still useful to know they're happening. Keep an eye out for the following surprising scopes:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Parameter scope", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Function name scope", "type": "text"}]}]}]}, {"type": "heading", "attrs": {"level": 3}}, {"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Parameter Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The conversation metaphor in Chapter 2 implies that function parameters are basically the same as locally declared variables in the function scope. But that's not always true.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer/global scope: RED(1)\n\nfunction getStudentName(studentID) {\n    // function scope: BLUE(2)\n\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a considered a \"simple\" parameter, so it does behave as a member of the BLUE(2) function scope. But if we change it to be a non-simple parameter, that's no longer technically the case. Parameter forms considered non-simple include parameters with default values, rest parameters (using ", "type": "text"}, {"text": "...", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and destructured parameters.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// outer/global scope: RED(1)\n\nfunction getStudentName(/*BLUE(2)*/ studentID = 0) {\n    // function scope: GREEN(3)\n\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, the parameter list essentially becomes its own scope, and the function's scope is then nested inside ", "type": "text"}, {"text": "that", "type": "text", "marks": [{"type": "italic"}]}, {"text": " scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why? What difference does it make? The non-simple parameter forms introduce various corner cases, so the parameter list becomes its own scope to more effectively deal with them.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudentName(studentID = maxID, maxID) {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Assuming left-to-right operations, the default ", "type": "text"}, {"text": "= maxID", "type": "text", "marks": [{"type": "code"}]}, {"text": " for the ", "type": "text"}, {"text": "studentID", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter requires a ", "type": "text"}, {"text": "maxID", "type": "text", "marks": [{"type": "code"}]}, {"text": " to already exist (and to have been initialized). This code produces a TDZ error (Chapter 5). The reason is that ", "type": "text"}, {"text": "maxID", "type": "text", "marks": [{"type": "code"}]}, {"text": " is declared in the parameter scope, but it's not yet been initialized because of the order of parameters. If the parameter order is flipped, no TDZ error occurs:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudentName(maxID,studentID = maxID) {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The complication gets even more ", "type": "text"}, {"text": "in the weeds", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if we introduce a function expression into the default parameter position, which then can create its own closure (Chapter 7) over parameters in this implied parameter scope:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function whatsTheDealHere(id,defaultID = () => id) {\n    id = 5;\n    console.log( defaultID() );\n}\n\nwhatsTheDealHere(3);\n// 5", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That snippet probably makes sense, because the ", "type": "text"}, {"text": "defaultID()", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow function closes over the ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter/variable, which we then re-assign to ", "type": "text"}, {"text": "5", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But now let's introduce a shadowing definition of ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the function scope:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function whatsTheDealHere(id,defaultID = () => id) {\n    var id = 5;\n    console.log( defaultID() );\n}\n\nwhatsTheDealHere(3);\n// 3", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Uh oh! The ", "type": "text"}, {"text": "var id = 5", "type": "text", "marks": [{"type": "code"}]}, {"text": " is shadowing the ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter, but the closure of the ", "type": "text"}, {"text": "defaultID()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is over the parameter, not the shadowing variable in the function body. This proves there's a scope bubble around the parameter list.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But it gets even crazier than that!", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function whatsTheDealHere(id,defaultID = () => id) {\n    var id;\n\n    console.log(`local variable 'id': ${ id }`);\n    console.log(\n        `parameter 'id' (closure): ${ defaultID() }`\n    );\n\n    console.log(\"reassigning 'id' to 5\");\n    id = 5;\n\n    console.log(`local variable 'id': ${ id }`);\n    console.log(\n        `parameter 'id' (closure): ${ defaultID() }`\n    );\n}\n\nwhatsTheDealHere(3);\n// local variable 'id': 3   <--- Huh!? Weird!\n// parameter 'id' (closure): 3\n// reassigning 'id' to 5\n// local variable 'id': 5\n// parameter 'id' (closure): 3", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The strange bit here is the first console message. At that moment, the shadowing ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " local variable has just been ", "type": "text"}, {"text": "var id", "type": "text", "marks": [{"type": "code"}]}, {"text": " declared, which Chapter 5 asserts is typically auto-initialized to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " at the top of its scope. Why doesn't it print ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this specific corner case (for legacy compat reasons), JS doesn't auto-initialize ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but rather to the value of the ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter (", "type": "text"}, {"text": "3", "type": "text", "marks": [{"type": "code"}]}, {"text": ")!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though the two ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": "s look at that moment like they're one variable, they're actually still separate (and in separate scopes). The ", "type": "text"}, {"text": "id = 5", "type": "text", "marks": [{"type": "code"}]}, {"text": " assignment makes the divergence observable, where the ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter stays ", "type": "text"}, {"text": "3", "type": "text", "marks": [{"type": "code"}]}, {"text": " and the local variable becomes ", "type": "text"}, {"text": "5", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My advice to avoid getting bitten by these weird nuances:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Never shadow parameters with local variables", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Avoid using a default parameter function that closes over any of the parameters", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "At least now you're aware and can be careful about the fact that the parameter list is its own scope if any of the parameters are non-simple.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 3}}, {"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Function Name Scope", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the \"Function Name Scope\" section in Chapter 3, I asserted that the name of a function expression is added to the function's own scope. Recall:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function ofTheTeacher(){\n    // ..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's true that ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not added to the enclosing scope (where ", "type": "text"}, {"text": "askQuestion", "type": "text", "marks": [{"type": "code"}]}, {"text": " is declared), but it's also not ", "type": "text"}, {"text": "just", "type": "text", "marks": [{"type": "italic"}]}, {"text": " added to the scope of the function, the way you're likely assuming. It's another strange corner case of implied scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The name identifier of a function expression is in its own implied scope, nested between the outer enclosing scope and the main inner function scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " was in the function's scope, we'd expect an error here:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var askQuestion = function ofTheTeacher(){\n    // why is this not a duplicate declaration error?\n    let ofTheTeacher = \"Confused, yet?\";\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration form does not allow re-declaration (see Chapter 5). But this is perfectly legal shadowing, not re-declaration, because the two ", "type": "text"}, {"text": "ofTheTeacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifiers are in separate scopes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You'll rarely run into any case where the scope of a function's name identifier matters. But again, it's good to know how these mechanisms actually work. To avoid being bitten, never shadow function name identifiers.", "type": "text"}]}]}, "article_text": "Implied Scopes\n\nScopes are sometimes created in non-obvious places. In practice, these implied scopes don't often impact your program behavior, but it's still useful to know they're happening. Keep an eye out for the following surprising scopes:\n\nParameter scope\n\nFunction name scope\n\nParameter Scope\n\nThe conversation metaphor in Chapter 2 implies that function parameters are basically the same as locally declared variables in the function scope. But that's not always true.\n\nConsider:\n\n// outer/global scope: RED(1)\n\nfunction getStudentName(studentID) {\n    // function scope: BLUE(2)\n\n    // ..\n}\n\nHere, studentID is a considered a \"simple\" parameter, so it does behave as a member of the BLUE(2) function scope. But if we change it to be a non-simple parameter, that's no longer technically the case. Parameter forms considered non-simple include parameters with default values, rest parameters (using ...), and destructured parameters.\n\nConsider:\n\n// outer/global scope: RED(1)\n\nfunction getStudentName(/*BLUE(2)*/ studentID = 0) {\n    // function scope: GREEN(3)\n\n    // ..\n}\n\nHere, the parameter list essentially becomes its own scope, and the function's scope is then nested inside that scope.\n\nWhy? What difference does it make? The non-simple parameter forms introduce various corner cases, so the parameter list becomes its own scope to more effectively deal with them.\n\nConsider:\n\nfunction getStudentName(studentID = maxID, maxID) {\n    // ..\n}\n\nAssuming left-to-right operations, the default = maxID for the studentID parameter requires a maxID to already exist (and to have been initialized). This code produces a TDZ error (Chapter 5). The reason is that maxID is declared in the parameter scope, but it's not yet been initialized because of the order of parameters. If the parameter order is flipped, no TDZ error occurs:\n\nfunction getStudentName(maxID,studentID = maxID) {\n    // ..\n}\n\nThe complication gets even more in the weeds if we introduce a function expression into the default parameter position, which then can create its own closure (Chapter 7) over parameters in this implied parameter scope:\n\nfunction whatsTheDealHere(id,defaultID = () => id) {\n    id = 5;\n    console.log( defaultID() );\n}\n\nwhatsTheDealHere(3);\n// 5\n\nThat snippet probably makes sense, because the defaultID() arrow function closes over the id parameter/variable, which we then re-assign to 5. But now let's introduce a shadowing definition of id in the function scope:\n\nfunction whatsTheDealHere(id,defaultID = () => id) {\n    var id = 5;\n    console.log( defaultID() );\n}\n\nwhatsTheDealHere(3);\n// 3\n\nUh oh! The var id = 5 is shadowing the id parameter, but the closure of the defaultID() function is over the parameter, not the shadowing variable in the function body. This proves there's a scope bubble around the parameter list.\n\nBut it gets even crazier than that!\n\nfunction whatsTheDealHere(id,defaultID = () => id) {\n    var id;\n\n    console.log(`local variable 'id': ${ id }`);\n    console.log(\n        `parameter 'id' (closure): ${ defaultID() }`\n    );\n\n    console.log(\"reassigning 'id' to 5\");\n    id = 5;\n\n    console.log(`local variable 'id': ${ id }`);\n    console.log(\n        `parameter 'id' (closure): ${ defaultID() }`\n    );\n}\n\nwhatsTheDealHere(3);\n// local variable 'id': 3   <--- Huh!? Weird!\n// parameter 'id' (closure): 3\n// reassigning 'id' to 5\n// local variable 'id': 5\n// parameter 'id' (closure): 3\n\nThe strange bit here is the first console message. At that moment, the shadowing id local variable has just been var id declared, which Chapter 5 asserts is typically auto-initialized to undefined at the top of its scope. Why doesn't it print undefined?\n\nIn this specific corner case (for legacy compat reasons), JS doesn't auto-initialize id to undefined, but rather to the value of the id parameter (3)!\n\nThough the two ids look at that moment like they're one variable, they're actually still separate (and in separate scopes). The id = 5 assignment makes the divergence observable, where the id parameter stays 3 and the local variable becomes 5.\n\nMy advice to avoid getting bitten by these weird nuances:\n\nNever shadow parameters with local variables\n\nAvoid using a default parameter function that closes over any of the parameters\n\nAt least now you're aware and can be careful about the fact that the parameter list is its own scope if any of the parameters are non-simple.\n\nFunction Name Scope\n\nIn the \"Function Name Scope\" section in Chapter 3, I asserted that the name of a function expression is added to the function's own scope. Recall:\n\nvar askQuestion = function ofTheTeacher(){\n    // ..\n};\n\nIt's true that ofTheTeacher is not added to the enclosing scope (where askQuestion is declared), but it's also not just added to the scope of the function, the way you're likely assuming. It's another strange corner case of implied scope.\n\nThe name identifier of a function expression is in its own implied scope, nested between the outer enclosing scope and the main inner function scope.\n\nIf ofTheTeacher was in the function's scope, we'd expect an error here:\n\nvar askQuestion = function ofTheTeacher(){\n    // why is this not a duplicate declaration error?\n    let ofTheTeacher = \"Confused, yet?\";\n};\n\nThe let declaration form does not allow re-declaration (see Chapter 5). But this is perfectly legal shadowing, not re-declaration, because the two ofTheTeacher identifiers are in separate scopes.\n\nYou'll rarely run into any case where the scope of a function's name identifier matters. But again, it's good to know how these mechanisms actually work. To avoid being bitten, never shadow function name identifiers."}, "id": 244}, {"data": {"uuid": "eadb51e0-619c-4d0d-af61-544a793ace97", "user": 1, "title": "Anonymous vs. Named Functions", "author": "Kyle Simpson", "created_on": "2023-06-09 01:56:16.644997+00:00", "updated_on": "2023-06-09 01:56:29.512098+00:00", "article_html": "<h2>Anonymous vs. Named Functions</h2><p>As discussed in Chapter 3, functions can be expressed either in named or anonymous form. It's vastly more common to use the anonymous form, but is that a good idea?</p><p>As you contemplate naming your functions, consider:</p><ul><li><p>Name inference is incomplete</p></li><li><p>Lexical names allow self-reference</p></li><li><p>Names are useful descriptions</p></li><li><p>Arrow functions have no lexical names</p></li><li><p>IIFEs also need names</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Anonymous vs. Named Functions", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As discussed in Chapter 3, functions can be expressed either in named or anonymous form. It's vastly more common to use the anonymous form, but is that a good idea?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As you contemplate naming your functions, consider:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Name inference is incomplete", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Lexical names allow self-reference", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Names are useful descriptions", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Arrow functions have no lexical names", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "IIFEs also need names", "type": "text"}]}]}]}]}, "article_text": "Anonymous vs. Named Functions\n\nAs discussed in Chapter 3, functions can be expressed either in named or anonymous form. It's vastly more common to use the anonymous form, but is that a good idea?\n\nAs you contemplate naming your functions, consider:\n\nName inference is incomplete\n\nLexical names allow self-reference\n\nNames are useful descriptions\n\nArrow functions have no lexical names\n\nIIFEs also need names"}, "id": 245, "children": [{"data": {"uuid": "3c371cc2-1870-4f43-b1d3-5fadde53101f", "user": 1, "title": "Explicit or Inferred Names?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:56:47.676812+00:00", "updated_on": "2023-06-09 01:57:07.738183+00:00", "article_html": "<h3>Explicit or Inferred Names?</h3><p>Every function in your program has a purpose. If it doesn't have a purpose, take it out, because you're just wasting space. If it <em>does</em> have a purpose, there <em>is</em> a name for that purpose.</p><p>So far many readers likely agree with me. But does that mean we should always put that name into the code? Here's where I'll raise more than a few eyebrows. I say, unequivocally, yes!</p><p>First of all, \"anonymous\" showing up in stack traces is just not all that helpful to debugging:</p><pre><code>btn.addEventListener(\"click\",function(){\n    setTimeout(function(){\n        [\"a\",42].map(function(v){\n            console.log(v.toUpperCase());\n        });\n    },100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at myProgram.js:4\n//     at Array.map (&lt;anonymous&gt;)\n//     at myProgram.js:3</code></pre><p>Ugh. Compare to what is reported if I give the functions names:</p><pre><code>btn.addEventListener(\"click\",function onClick(){\n    setTimeout(function waitAMoment(){\n        [\"a\",42].map(function allUpper(v){\n            console.log(v.toUpperCase());\n        });\n    },100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at allUpper (myProgram.js:4)\n//     at Array.map (&lt;anonymous&gt;)\n//     at waitAMoment (myProgram.js:3)</code></pre><p>See how <code>waitAMoment</code> and <code>allUpper</code> names appear and give the stack trace more useful information/context for debugging? The program is more debuggable if we use reasonable names for all our functions.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The unfortunate \"&lt;anonymous&gt;\" that still shows up refers to the fact that the implementation of <code>Array.map(..)</code> isn't present in our program, but is built into the JS engine. It's not from any confusion our program introduces with readability shortcuts.</p></td></tr></tbody></table><p>By the way, let's make sure we're on the same page about what a named function is:</p><pre><code>function thisIsNamed() {\n    // ..\n}\n\najax(\"some.url\",function thisIsAlsoNamed(){\n   // ..\n});\n\nvar notNamed = function(){\n    // ..\n};\n\nmakeRequest({\n    data: 42,\n    cb /* also not a name */: function(){\n        // ..\n    }\n});\n\nvar stillNotNamed = function butThisIs(){\n    // ..\n};</code></pre><p>\"But wait!\", you say. Some of those <em>are</em> named, right!?</p><pre><code>var notNamed = function(){\n    // ..\n};\n\nvar config = {\n    cb: function(){\n        // ..\n    }\n};\n\nnotNamed.name;\n// notNamed\n\nconfig.cb.name;\n// cb</code></pre><p>These are referred to as <em>inferred</em> names. Inferred names are fine, but they don't really address the full concern I'm discussing.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Explicit or Inferred Names?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Every function in your program has a purpose. If it doesn't have a purpose, take it out, because you're just wasting space. If it ", "type": "text"}, {"text": "does", "type": "text", "marks": [{"type": "italic"}]}, {"text": " have a purpose, there ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " a name for that purpose.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So far many readers likely agree with me. But does that mean we should always put that name into the code? Here's where I'll raise more than a few eyebrows. I say, unequivocally, yes!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First of all, \"anonymous\" showing up in stack traces is just not all that helpful to debugging:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "btn.addEventListener(\"click\",function(){\n    setTimeout(function(){\n        [\"a\",42].map(function(v){\n            console.log(v.toUpperCase());\n        });\n    },100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at myProgram.js:4\n//     at Array.map (<anonymous>)\n//     at myProgram.js:3", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Ugh. Compare to what is reported if I give the functions names:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "btn.addEventListener(\"click\",function onClick(){\n    setTimeout(function waitAMoment(){\n        [\"a\",42].map(function allUpper(v){\n            console.log(v.toUpperCase());\n        });\n    },100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at allUpper (myProgram.js:4)\n//     at Array.map (<anonymous>)\n//     at waitAMoment (myProgram.js:3)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "See how ", "type": "text"}, {"text": "waitAMoment", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "allUpper", "type": "text", "marks": [{"type": "code"}]}, {"text": " names appear and give the stack trace more useful information/context for debugging? The program is more debuggable if we use reasonable names for all our functions.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The unfortunate \"<anonymous>\" that still shows up refers to the fact that the implementation of ", "type": "text"}, {"text": "Array.map(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " isn't present in our program, but is built into the JS engine. It's not from any confusion our program introduces with readability shortcuts.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "By the way, let's make sure we're on the same page about what a named function is:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function thisIsNamed() {\n    // ..\n}\n\najax(\"some.url\",function thisIsAlsoNamed(){\n   // ..\n});\n\nvar notNamed = function(){\n    // ..\n};\n\nmakeRequest({\n    data: 42,\n    cb /* also not a name */: function(){\n        // ..\n    }\n});\n\nvar stillNotNamed = function butThisIs(){\n    // ..\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "\"But wait!\", you say. Some of those ", "type": "text"}, {"text": "are", "type": "text", "marks": [{"type": "italic"}]}, {"text": " named, right!?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var notNamed = function(){\n    // ..\n};\n\nvar config = {\n    cb: function(){\n        // ..\n    }\n};\n\nnotNamed.name;\n// notNamed\n\nconfig.cb.name;\n// cb", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These are referred to as ", "type": "text"}, {"text": "inferred", "type": "text", "marks": [{"type": "italic"}]}, {"text": " names. Inferred names are fine, but they don't really address the full concern I'm discussing.", "type": "text"}]}]}, "article_text": "Explicit or Inferred Names?\n\nEvery function in your program has a purpose. If it doesn't have a purpose, take it out, because you're just wasting space. If it does have a purpose, there is a name for that purpose.\n\nSo far many readers likely agree with me. But does that mean we should always put that name into the code? Here's where I'll raise more than a few eyebrows. I say, unequivocally, yes!\n\nFirst of all, \"anonymous\" showing up in stack traces is just not all that helpful to debugging:\n\nbtn.addEventListener(\"click\",function(){\n    setTimeout(function(){\n        [\"a\",42].map(function(v){\n            console.log(v.toUpperCase());\n        });\n    },100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at myProgram.js:4\n//     at Array.map (<anonymous>)\n//     at myProgram.js:3\n\nUgh. Compare to what is reported if I give the functions names:\n\nbtn.addEventListener(\"click\",function onClick(){\n    setTimeout(function waitAMoment(){\n        [\"a\",42].map(function allUpper(v){\n            console.log(v.toUpperCase());\n        });\n    },100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at allUpper (myProgram.js:4)\n//     at Array.map (<anonymous>)\n//     at waitAMoment (myProgram.js:3)\n\nSee how waitAMoment and allUpper names appear and give the stack trace more useful information/context for debugging? The program is more debuggable if we use reasonable names for all our functions.\n\nNOTE:\n\nThe unfortunate \"<anonymous>\" that still shows up refers to the fact that the implementation of Array.map(..) isn't present in our program, but is built into the JS engine. It's not from any confusion our program introduces with readability shortcuts.\n\nBy the way, let's make sure we're on the same page about what a named function is:\n\nfunction thisIsNamed() {\n    // ..\n}\n\najax(\"some.url\",function thisIsAlsoNamed(){\n   // ..\n});\n\nvar notNamed = function(){\n    // ..\n};\n\nmakeRequest({\n    data: 42,\n    cb /* also not a name */: function(){\n        // ..\n    }\n});\n\nvar stillNotNamed = function butThisIs(){\n    // ..\n};\n\n\"But wait!\", you say. Some of those are named, right!?\n\nvar notNamed = function(){\n    // ..\n};\n\nvar config = {\n    cb: function(){\n        // ..\n    }\n};\n\nnotNamed.name;\n// notNamed\n\nconfig.cb.name;\n// cb\n\nThese are referred to as inferred names. Inferred names are fine, but they don't really address the full concern I'm discussing."}, "id": 246}, {"data": {"uuid": "216c8e25-466a-46a7-830e-6c0eeb75dc47", "user": 1, "title": "Missing Names?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:57:26.601752+00:00", "updated_on": "2023-06-09 01:57:45.648491+00:00", "article_html": "<h3>Missing Names?</h3><p>Yes, these inferred names might show up in stack traces, which is definitely better than \"anonymous\" showing up. But...</p><pre><code>function ajax(url,cb) {\n    console.log(cb.name);\n}\n\najax(\"some.url\",function(){\n    // ..\n});\n// \"\"</code></pre><p>Oops. Anonymous <code>function</code> expressions passed as callbacks are incapable of receiving an inferred name, so <code>cb.name</code> holds just the empty string <code>\"\"</code>. The vast majority of all <code>function</code> expressions, especially anonymous ones, are used as callback arguments; none of these get a name. So relying on name inference is incomplete, at best.</p><p>And it's not just callbacks that fall short with inference:</p><pre><code>var config = {};\n\nconfig.cb = function(){\n    // ..\n};\n\nconfig.cb.name;\n// \"\"\n\nvar [ noName ] = [ function(){} ];\nnoName.name\n// \"\"</code></pre><p>Any assignment of a <code>function</code> expression that's not a <em>simple assignment</em> will also fail name inferencing. So, in other words, unless you're careful and intentional about it, essentially almost all anonymous <code>function</code> expressions in your program will in fact have no name at all.</p><p>Name inference is just... not enough.</p><p>And even if a <code>function</code> expression <em>does</em> get an inferred name, that still doesn't count as being a full named function.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Missing Names?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Yes, these inferred names might show up in stack traces, which is definitely better than \"anonymous\" showing up. But...", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function ajax(url,cb) {\n    console.log(cb.name);\n}\n\najax(\"some.url\",function(){\n    // ..\n});\n// \"\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Oops. Anonymous ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions passed as callbacks are incapable of receiving an inferred name, so ", "type": "text"}, {"text": "cb.name", "type": "text", "marks": [{"type": "code"}]}, {"text": " holds just the empty string ", "type": "text"}, {"text": "\"\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The vast majority of all ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions, especially anonymous ones, are used as callback arguments; none of these get a name. So relying on name inference is incomplete, at best.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And it's not just callbacks that fall short with inference:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var config = {};\n\nconfig.cb = function(){\n    // ..\n};\n\nconfig.cb.name;\n// \"\"\n\nvar [ noName ] = [ function(){} ];\nnoName.name\n// \"\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Any assignment of a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression that's not a ", "type": "text"}, {"text": "simple assignment", "type": "text", "marks": [{"type": "italic"}]}, {"text": " will also fail name inferencing. So, in other words, unless you're careful and intentional about it, essentially almost all anonymous ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions in your program will in fact have no name at all.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Name inference is just... not enough.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And even if a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression ", "type": "text"}, {"text": "does", "type": "text", "marks": [{"type": "italic"}]}, {"text": " get an inferred name, that still doesn't count as being a full named function.", "type": "text"}]}]}, "article_text": "Missing Names?\n\nYes, these inferred names might show up in stack traces, which is definitely better than \"anonymous\" showing up. But...\n\nfunction ajax(url,cb) {\n    console.log(cb.name);\n}\n\najax(\"some.url\",function(){\n    // ..\n});\n// \"\"\n\nOops. Anonymous function expressions passed as callbacks are incapable of receiving an inferred name, so cb.name holds just the empty string \"\". The vast majority of all function expressions, especially anonymous ones, are used as callback arguments; none of these get a name. So relying on name inference is incomplete, at best.\n\nAnd it's not just callbacks that fall short with inference:\n\nvar config = {};\n\nconfig.cb = function(){\n    // ..\n};\n\nconfig.cb.name;\n// \"\"\n\nvar [ noName ] = [ function(){} ];\nnoName.name\n// \"\"\n\nAny assignment of a function expression that's not a simple assignment will also fail name inferencing. So, in other words, unless you're careful and intentional about it, essentially almost all anonymous function expressions in your program will in fact have no name at all.\n\nName inference is just... not enough.\n\nAnd even if a function expression does get an inferred name, that still doesn't count as being a full named function."}, "id": 247}, {"data": {"uuid": "f254774a-afe9-41e3-9b99-5726519aa152", "user": 1, "title": "Who am I?", "author": "Kyle Simpson", "created_on": "2023-06-09 01:58:07.499205+00:00", "updated_on": "2023-06-09 01:58:29.242549+00:00", "article_html": "<h3>Who am I?</h3><p>Without a lexical name identifier, the function has no internal way to refer to itself. Self-reference is important for things like recursion and event handling:</p><pre><code>// broken\nrunOperation(function(num){\n    if (num &lt;= 1) return 1;\n    return num * oopsNoNameToCall(num - 1);\n});\n\n// also broken\nbtn.addEventListener(\"click\",function(){\n   console.log(\"should only respond to one click!\");\n   btn.removeEventListener(\"click\",oopsNoNameHere);\n});</code></pre><p>Leaving off the lexical name from your callback makes it harder to reliably self-reference the function. You <em>could</em> declare a variable in an enclosing scope that references the function, but this variable is <em>controlled</em> by that enclosing scope\u2014it could be re-assigned, etc.\u2014so it's not as reliable as the function having its own internal self-reference.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Who am I?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Without a lexical name identifier, the function has no internal way to refer to itself. Self-reference is important for things like recursion and event handling:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// broken\nrunOperation(function(num){\n    if (num <= 1) return 1;\n    return num * oopsNoNameToCall(num - 1);\n});\n\n// also broken\nbtn.addEventListener(\"click\",function(){\n   console.log(\"should only respond to one click!\");\n   btn.removeEventListener(\"click\",oopsNoNameHere);\n});", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Leaving off the lexical name from your callback makes it harder to reliably self-reference the function. You ", "type": "text"}, {"text": "could", "type": "text", "marks": [{"type": "italic"}]}, {"text": " declare a variable in an enclosing scope that references the function, but this variable is ", "type": "text"}, {"text": "controlled", "type": "text", "marks": [{"type": "italic"}]}, {"text": " by that enclosing scope\u2014it could be re-assigned, etc.\u2014so it's not as reliable as the function having its own internal self-reference.", "type": "text"}]}]}, "article_text": "Who am I?\n\nWithout a lexical name identifier, the function has no internal way to refer to itself. Self-reference is important for things like recursion and event handling:\n\n// broken\nrunOperation(function(num){\n    if (num <= 1) return 1;\n    return num * oopsNoNameToCall(num - 1);\n});\n\n// also broken\nbtn.addEventListener(\"click\",function(){\n   console.log(\"should only respond to one click!\");\n   btn.removeEventListener(\"click\",oopsNoNameHere);\n});\n\nLeaving off the lexical name from your callback makes it harder to reliably self-reference the function. You could declare a variable in an enclosing scope that references the function, but this variable is controlled by that enclosing scope\u2014it could be re-assigned, etc.\u2014so it's not as reliable as the function having its own internal self-reference."}, "id": 248}, {"data": {"uuid": "c7ccef88-33e9-4982-a8cb-4aa3813a5004", "user": 1, "title": "Names are Descriptors", "author": "Kyle Simpson", "created_on": "2023-06-09 01:58:46.396924+00:00", "updated_on": "2023-06-09 01:59:05.479904+00:00", "article_html": "<h3>Names are Descriptors</h3><p>Lastly, and I think most importantly of all, leaving off a name from a function makes it harder for the reader to tell what the function's purpose is, at a quick glance. They have to read more of the code, including the code inside the function, and the surrounding code outside the function, to figure it out.</p><p>Consider:</p><pre><code>[ 1, 2, 3, 4, 5 ].filter(function(v){\n    return v % 2 == 1;\n});\n// [ 1, 3, 5 ]\n\n[ 1, 2, 3, 4, 5 ].filter(function keepOnlyOdds(v){\n    return v % 2 == 1;\n});\n// [ 1, 3, 5 ]</code></pre><p>There's just no reasonable argument to be made that <strong>omitting</strong> the name <code>keepOnlyOdds</code> from the first callback more effectively communicates to the reader the purpose of this callback. You saved 13 characters, but lost important readability information. The name <code>keepOnlyOdds</code> very clearly tells the reader, at a quick first glance, what's happening.</p><p>The JS engine doesn't care about the name. But human readers of your code absolutely do.</p><p>Can the reader look at <code>v % 2 == 1</code> and figure out what it's doing? Sure. But they have to infer the purpose (and name) by mentally executing the code. Even a brief pause to do so slows down reading of the code. A good descriptive name makes this process almost effortless and instant.</p><p>Think of it this way: how many times does the author of this code need to figure out the purpose of a function before adding the name to the code? About once. Maybe two or three times if they need to adjust the name. But how many times will readers of this code have to figure out the name/purpose? Every single time this line is ever read. Hundreds of times? Thousands? More?</p><p>No matter the length or complexity of the function, my assertion is, the author should figure out a good descriptive name and add it to the code. Even the one-liner functions in <code>map(..)</code> and <code>then(..)</code> statements should be named:</p><pre><code>lookupTheRecords(someData)\n.then(function extractSalesRecords(resp){\n   return resp.allSales;\n})\n.then(storeRecords);</code></pre><p>The name <code>extractSalesRecords</code> tells the reader the purpose of this <code>then(..)</code> handler <em>better</em> than just inferring that purpose from mentally executing <code>return resp.allSales</code>.</p><p>The only excuse for not including a name on a function is either laziness (don't want to type a few extra characters) or uncreativity (can't come up with a good name). If you can't figure out a good name, you likely don't understand the function and its purpose yet. The function is perhaps poorly designed, or it does too many things, and should be re-worked. Once you have a well-designed, single-purpose function, its proper name should become evident.</p><p>Here's a trick I use: while first writing a function, if I don't fully understand its purpose and can't think of a good name to use, I just use <code>TODO</code> as the name. That way, later when reviewing my code, I'm likely to find those name placeholders, and I'm more inclined (and more prepared!) to go back and figure out a better name, rather than just leave it as <code>TODO</code>.</p><p>All functions need names. Every single one. No exceptions. Any name you omit is making the program harder to read, harder to debug, harder to extend and maintain later.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Names are Descriptors", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Lastly, and I think most importantly of all, leaving off a name from a function makes it harder for the reader to tell what the function's purpose is, at a quick glance. They have to read more of the code, including the code inside the function, and the surrounding code outside the function, to figure it out.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "[ 1, 2, 3, 4, 5 ].filter(function(v){\n    return v % 2 == 1;\n});\n// [ 1, 3, 5 ]\n\n[ 1, 2, 3, 4, 5 ].filter(function keepOnlyOdds(v){\n    return v % 2 == 1;\n});\n// [ 1, 3, 5 ]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's just no reasonable argument to be made that ", "type": "text"}, {"text": "omitting", "type": "text", "marks": [{"type": "bold"}]}, {"text": " the name ", "type": "text"}, {"text": "keepOnlyOdds", "type": "text", "marks": [{"type": "code"}]}, {"text": " from the first callback more effectively communicates to the reader the purpose of this callback. You saved 13 characters, but lost important readability information. The name ", "type": "text"}, {"text": "keepOnlyOdds", "type": "text", "marks": [{"type": "code"}]}, {"text": " very clearly tells the reader, at a quick first glance, what's happening.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The JS engine doesn't care about the name. But human readers of your code absolutely do.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Can the reader look at ", "type": "text"}, {"text": "v % 2 == 1", "type": "text", "marks": [{"type": "code"}]}, {"text": " and figure out what it's doing? Sure. But they have to infer the purpose (and name) by mentally executing the code. Even a brief pause to do so slows down reading of the code. A good descriptive name makes this process almost effortless and instant.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Think of it this way: how many times does the author of this code need to figure out the purpose of a function before adding the name to the code? About once. Maybe two or three times if they need to adjust the name. But how many times will readers of this code have to figure out the name/purpose? Every single time this line is ever read. Hundreds of times? Thousands? More?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "No matter the length or complexity of the function, my assertion is, the author should figure out a good descriptive name and add it to the code. Even the one-liner functions in ", "type": "text"}, {"text": "map(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "then(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statements should be named:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "lookupTheRecords(someData)\n.then(function extractSalesRecords(resp){\n   return resp.allSales;\n})\n.then(storeRecords);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The name ", "type": "text"}, {"text": "extractSalesRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " tells the reader the purpose of this ", "type": "text"}, {"text": "then(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " handler ", "type": "text"}, {"text": "better", "type": "text", "marks": [{"type": "italic"}]}, {"text": " than just inferring that purpose from mentally executing ", "type": "text"}, {"text": "return resp.allSales", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The only excuse for not including a name on a function is either laziness (don't want to type a few extra characters) or uncreativity (can't come up with a good name). If you can't figure out a good name, you likely don't understand the function and its purpose yet. The function is perhaps poorly designed, or it does too many things, and should be re-worked. Once you have a well-designed, single-purpose function, its proper name should become evident.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's a trick I use: while first writing a function, if I don't fully understand its purpose and can't think of a good name to use, I just use ", "type": "text"}, {"text": "TODO", "type": "text", "marks": [{"type": "code"}]}, {"text": " as the name. That way, later when reviewing my code, I'm likely to find those name placeholders, and I'm more inclined (and more prepared!) to go back and figure out a better name, rather than just leave it as ", "type": "text"}, {"text": "TODO", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All functions need names. Every single one. No exceptions. Any name you omit is making the program harder to read, harder to debug, harder to extend and maintain later.", "type": "text"}]}]}, "article_text": "Names are Descriptors\n\nLastly, and I think most importantly of all, leaving off a name from a function makes it harder for the reader to tell what the function's purpose is, at a quick glance. They have to read more of the code, including the code inside the function, and the surrounding code outside the function, to figure it out.\n\nConsider:\n\n[ 1, 2, 3, 4, 5 ].filter(function(v){\n    return v % 2 == 1;\n});\n// [ 1, 3, 5 ]\n\n[ 1, 2, 3, 4, 5 ].filter(function keepOnlyOdds(v){\n    return v % 2 == 1;\n});\n// [ 1, 3, 5 ]\n\nThere's just no reasonable argument to be made that omitting the name keepOnlyOdds from the first callback more effectively communicates to the reader the purpose of this callback. You saved 13 characters, but lost important readability information. The name keepOnlyOdds very clearly tells the reader, at a quick first glance, what's happening.\n\nThe JS engine doesn't care about the name. But human readers of your code absolutely do.\n\nCan the reader look at v % 2 == 1 and figure out what it's doing? Sure. But they have to infer the purpose (and name) by mentally executing the code. Even a brief pause to do so slows down reading of the code. A good descriptive name makes this process almost effortless and instant.\n\nThink of it this way: how many times does the author of this code need to figure out the purpose of a function before adding the name to the code? About once. Maybe two or three times if they need to adjust the name. But how many times will readers of this code have to figure out the name/purpose? Every single time this line is ever read. Hundreds of times? Thousands? More?\n\nNo matter the length or complexity of the function, my assertion is, the author should figure out a good descriptive name and add it to the code. Even the one-liner functions in map(..) and then(..) statements should be named:\n\nlookupTheRecords(someData)\n.then(function extractSalesRecords(resp){\n   return resp.allSales;\n})\n.then(storeRecords);\n\nThe name extractSalesRecords tells the reader the purpose of this then(..) handler better than just inferring that purpose from mentally executing return resp.allSales.\n\nThe only excuse for not including a name on a function is either laziness (don't want to type a few extra characters) or uncreativity (can't come up with a good name). If you can't figure out a good name, you likely don't understand the function and its purpose yet. The function is perhaps poorly designed, or it does too many things, and should be re-worked. Once you have a well-designed, single-purpose function, its proper name should become evident.\n\nHere's a trick I use: while first writing a function, if I don't fully understand its purpose and can't think of a good name to use, I just use TODO as the name. That way, later when reviewing my code, I'm likely to find those name placeholders, and I'm more inclined (and more prepared!) to go back and figure out a better name, rather than just leave it as TODO.\n\nAll functions need names. Every single one. No exceptions. Any name you omit is making the program harder to read, harder to debug, harder to extend and maintain later."}, "id": 249}, {"data": {"uuid": "75ff74ed-8ad9-44c9-afe6-b44dc4b42918", "user": 1, "title": "Arrow Functions", "author": "Kyle Simpson", "created_on": "2023-06-09 01:59:21.775754+00:00", "updated_on": "2023-06-09 01:59:41.873803+00:00", "article_html": "<h3>Arrow Functions</h3><p>Arrow functions are <strong>always</strong> anonymous, even if (rarely) they're used in a way that gives them an inferred name. I just spent several pages explaining why anonymous functions are a bad idea, so you can probably guess what I think about arrow functions.</p><p>Don't use them as a general replacement for regular functions. They're more concise, yes, but that brevity comes at the cost of omitting key visual delimiters that help our brains quickly parse out what we're reading. And, to the point of this discussion, they're anonymous, which makes them worse for readability from that angle as well.</p><p>Arrow functions have a purpose, but that purpose is not to save keystrokes. Arrow functions have <em>lexical this</em> behavior, which is somewhat beyond the bounds of our discussion in this book.</p><p>Briefly: arrow functions don't define a <code>this</code> identifier keyword at all. If you use a <code>this</code> inside an arrow function, it behaves exactly as any other variable reference, which is that the scope chain is consulted to find a function scope (non-arrow function) where it <em>is</em> defined, and to use that one.</p><p>In other words, arrow functions treat <code>this</code> like any other lexical variable.</p><p>If you're used to hacks like <code>var self = this</code>, or if you prefer to call <code>.bind(this)</code> on inner <code>function</code> expressions, just to force them to inherit a <code>this</code> from an outer function like it was a lexical variable, then <code>=&gt;</code> arrow functions are absolutely the better option. They're designed specifically to fix that problem.</p><p>So, in the rare cases you need <em>lexical this</em>, use an arrow function. It's the best tool for that job. But just be aware that in doing so, you're accepting the downsides of an anonymous function. You should expend additional effort to mitigate the readability <em>cost</em>, such as more descriptive variable names and code comments.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Arrow Functions", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Arrow functions are ", "type": "text"}, {"text": "always", "type": "text", "marks": [{"type": "bold"}]}, {"text": " anonymous, even if (rarely) they're used in a way that gives them an inferred name. I just spent several pages explaining why anonymous functions are a bad idea, so you can probably guess what I think about arrow functions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't use them as a general replacement for regular functions. They're more concise, yes, but that brevity comes at the cost of omitting key visual delimiters that help our brains quickly parse out what we're reading. And, to the point of this discussion, they're anonymous, which makes them worse for readability from that angle as well.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Arrow functions have a purpose, but that purpose is not to save keystrokes. Arrow functions have ", "type": "text"}, {"text": "lexical this", "type": "text", "marks": [{"type": "italic"}]}, {"text": " behavior, which is somewhat beyond the bounds of our discussion in this book.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Briefly: arrow functions don't define a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier keyword at all. If you use a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside an arrow function, it behaves exactly as any other variable reference, which is that the scope chain is consulted to find a function scope (non-arrow function) where it ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " defined, and to use that one.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, arrow functions treat ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " like any other lexical variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you're used to hacks like ", "type": "text"}, {"text": "var self = this", "type": "text", "marks": [{"type": "code"}]}, {"text": ", or if you prefer to call ", "type": "text"}, {"text": ".bind(this)", "type": "text", "marks": [{"type": "code"}]}, {"text": " on inner ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expressions, just to force them to inherit a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " from an outer function like it was a lexical variable, then ", "type": "text"}, {"text": "=>", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow functions are absolutely the better option. They're designed specifically to fix that problem.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So, in the rare cases you need ", "type": "text"}, {"text": "lexical this", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", use an arrow function. It's the best tool for that job. But just be aware that in doing so, you're accepting the downsides of an anonymous function. You should expend additional effort to mitigate the readability ", "type": "text"}, {"text": "cost", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", such as more descriptive variable names and code comments.", "type": "text"}]}]}, "article_text": "Arrow Functions\n\nArrow functions are always anonymous, even if (rarely) they're used in a way that gives them an inferred name. I just spent several pages explaining why anonymous functions are a bad idea, so you can probably guess what I think about arrow functions.\n\nDon't use them as a general replacement for regular functions. They're more concise, yes, but that brevity comes at the cost of omitting key visual delimiters that help our brains quickly parse out what we're reading. And, to the point of this discussion, they're anonymous, which makes them worse for readability from that angle as well.\n\nArrow functions have a purpose, but that purpose is not to save keystrokes. Arrow functions have lexical this behavior, which is somewhat beyond the bounds of our discussion in this book.\n\nBriefly: arrow functions don't define a this identifier keyword at all. If you use a this inside an arrow function, it behaves exactly as any other variable reference, which is that the scope chain is consulted to find a function scope (non-arrow function) where it is defined, and to use that one.\n\nIn other words, arrow functions treat this like any other lexical variable.\n\nIf you're used to hacks like var self = this, or if you prefer to call .bind(this) on inner function expressions, just to force them to inherit a this from an outer function like it was a lexical variable, then => arrow functions are absolutely the better option. They're designed specifically to fix that problem.\n\nSo, in the rare cases you need lexical this, use an arrow function. It's the best tool for that job. But just be aware that in doing so, you're accepting the downsides of an anonymous function. You should expend additional effort to mitigate the readability cost, such as more descriptive variable names and code comments."}, "id": 250}, {"data": {"uuid": "4068af94-b8c6-4c6d-b53a-4d94a40f0a4d", "user": 1, "title": "IIFE Variations", "author": "Kyle Simpson", "created_on": "2023-06-09 02:00:05.042226+00:00", "updated_on": "2023-06-09 02:00:22.956903+00:00", "article_html": "<h3>IIFE Variations</h3><p>All functions should have names. I said that a few times, right!? That includes IIFEs.</p><pre><code>(function(){\n    // don't do this!\n})();\n\n(function doThisInstead(){\n    // ..\n})();</code></pre><p>How do we come up with a name for an IIFE? Identify what the IIFE is there for. Why do you need a scope in that spot? Are you hiding a cache variable for student records?</p><pre><code>var getStudents = (function StoreStudentRecords(){\n    var studentRecords = [];\n\n    return function getStudents() {\n        // ..\n    }\n})();</code></pre><p>I named the IIFE <code>StoreStudentRecords</code> because that's what it's doing: storing student records. Every IIFE should have a name. No exceptions.</p><p>IIFEs are typically defined by placing <code>( .. )</code> around the <code>function</code> expression, as shown in those previous snippets. But that's not the only way to define an IIFE. Technically, the only reason we're using that first surrounding set of <code>( .. )</code> is just so the <code>function</code> keyword isn't in a position to qualify as a <code>function</code> declaration to the JS parser. But there are other syntactic ways to avoid being parsed as a declaration:</p><pre><code>!function thisIsAnIIFE(){\n    // ..\n}();\n\n+function soIsThisOne(){\n    // ..\n}();\n\n~function andThisOneToo(){\n    // ..\n}();</code></pre><p>The <code>!</code>, <code>+</code>, <code>~</code>, and several other unary operators (operators with one operand) can all be placed in front of <code>function</code> to turn it into an expression. Then the final <code>()</code> call is valid, which makes it an IIFE.</p><p>I actually kind of like using the <code>void</code> unary operator when defining a standalone IIFE:</p><pre><code>void function yepItsAnIIFE() {\n    // ..\n}();</code></pre><p>The benefit of <code>void</code> is, it clearly communicates at the beginning of the function that this IIFE won't be returning any value.</p><p>However you define your IIFEs, show them some love by giving them names.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "IIFE Variations", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All functions should have names. I said that a few times, right!? That includes IIFEs.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "(function(){\n    // don't do this!\n})();\n\n(function doThisInstead(){\n    // ..\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "How do we come up with a name for an IIFE? Identify what the IIFE is there for. Why do you need a scope in that spot? Are you hiding a cache variable for student records?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var getStudents = (function StoreStudentRecords(){\n    var studentRecords = [];\n\n    return function getStudents() {\n        // ..\n    }\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I named the IIFE ", "type": "text"}, {"text": "StoreStudentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " because that's what it's doing: storing student records. Every IIFE should have a name. No exceptions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "IIFEs are typically defined by placing ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": " around the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression, as shown in those previous snippets. But that's not the only way to define an IIFE. Technically, the only reason we're using that first surrounding set of ", "type": "text"}, {"text": "( .. )", "type": "text", "marks": [{"type": "code"}]}, {"text": " is just so the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword isn't in a position to qualify as a ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration to the JS parser. But there are other syntactic ways to avoid being parsed as a declaration:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "!function thisIsAnIIFE(){\n    // ..\n}();\n\n+function soIsThisOne(){\n    // ..\n}();\n\n~function andThisOneToo(){\n    // ..\n}();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "!", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "+", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "~", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and several other unary operators (operators with one operand) can all be placed in front of ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " to turn it into an expression. Then the final ", "type": "text"}, {"text": "()", "type": "text", "marks": [{"type": "code"}]}, {"text": " call is valid, which makes it an IIFE.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I actually kind of like using the ", "type": "text"}, {"text": "void", "type": "text", "marks": [{"type": "code"}]}, {"text": " unary operator when defining a standalone IIFE:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "void function yepItsAnIIFE() {\n    // ..\n}();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The benefit of ", "type": "text"}, {"text": "void", "type": "text", "marks": [{"type": "code"}]}, {"text": " is, it clearly communicates at the beginning of the function that this IIFE won't be returning any value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However you define your IIFEs, show them some love by giving them names.", "type": "text"}]}]}, "article_text": "IIFE Variations\n\nAll functions should have names. I said that a few times, right!? That includes IIFEs.\n\n(function(){\n    // don't do this!\n})();\n\n(function doThisInstead(){\n    // ..\n})();\n\nHow do we come up with a name for an IIFE? Identify what the IIFE is there for. Why do you need a scope in that spot? Are you hiding a cache variable for student records?\n\nvar getStudents = (function StoreStudentRecords(){\n    var studentRecords = [];\n\n    return function getStudents() {\n        // ..\n    }\n})();\n\nI named the IIFE StoreStudentRecords because that's what it's doing: storing student records. Every IIFE should have a name. No exceptions.\n\nIIFEs are typically defined by placing ( .. ) around the function expression, as shown in those previous snippets. But that's not the only way to define an IIFE. Technically, the only reason we're using that first surrounding set of ( .. ) is just so the function keyword isn't in a position to qualify as a function declaration to the JS parser. But there are other syntactic ways to avoid being parsed as a declaration:\n\n!function thisIsAnIIFE(){\n    // ..\n}();\n\n+function soIsThisOne(){\n    // ..\n}();\n\n~function andThisOneToo(){\n    // ..\n}();\n\nThe !, +, ~, and several other unary operators (operators with one operand) can all be placed in front of function to turn it into an expression. Then the final () call is valid, which makes it an IIFE.\n\nI actually kind of like using the void unary operator when defining a standalone IIFE:\n\nvoid function yepItsAnIIFE() {\n    // ..\n}();\n\nThe benefit of void is, it clearly communicates at the beginning of the function that this IIFE won't be returning any value.\n\nHowever you define your IIFEs, show them some love by giving them names."}, "id": 251}]}, {"data": {"uuid": "24b805cf-20cd-4d37-8003-39fd97522091", "user": 1, "title": "Hoisting: Functions and Variables", "author": "Kyle Simpson", "created_on": "2023-06-09 02:00:46.687268+00:00", "updated_on": "2023-06-09 02:01:00.430522+00:00", "article_html": "<h2>Hoisting: Functions and Variables</h2><p>Chapter 5 articulated both <em>function hoisting</em> and <em>variable hoisting</em>. Since hoisting is often cited as mistake in the design of JS, I wanted to briefly explore why both these forms of hoisting <em>can</em> be beneficial and should still be considered.</p><p>Give hoisting a deeper level of consideration by considering the merits of:</p><ul><li><p>Executable code first, function declarations last</p></li><li><p>Semantic placement of variable declarations</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Hoisting: Functions and Variables", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Chapter 5 articulated both ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Since hoisting is often cited as mistake in the design of JS, I wanted to briefly explore why both these forms of hoisting ", "type": "text"}, {"text": "can", "type": "text", "marks": [{"type": "italic"}]}, {"text": " be beneficial and should still be considered.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Give hoisting a deeper level of consideration by considering the merits of:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Executable code first, function declarations last", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Semantic placement of variable declarations", "type": "text"}]}]}]}]}, "article_text": "Hoisting: Functions and Variables\n\nChapter 5 articulated both function hoisting and variable hoisting. Since hoisting is often cited as mistake in the design of JS, I wanted to briefly explore why both these forms of hoisting can be beneficial and should still be considered.\n\nGive hoisting a deeper level of consideration by considering the merits of:\n\nExecutable code first, function declarations last\n\nSemantic placement of variable declarations"}, "id": 252, "children": [{"data": {"uuid": "a9b65957-dcc1-4f54-b1b3-1fb169fcfee6", "user": 1, "title": "Function Hoisting", "author": "Kyle Simpson", "created_on": "2023-06-09 02:01:31.464002+00:00", "updated_on": "2023-06-09 02:01:49.215890+00:00", "article_html": "<h3>Function Hoisting</h3><p>To review, this program works because of <em>function hoisting</em>:</p><pre><code>getStudents();\n\n// ..\n\nfunction getStudents() {\n    // ..\n}</code></pre><p>The <code>function</code> declaration is hoisted during compilation, which means that <code>getStudents</code> is an identifier declared for the entire scope. Additionally, the <code>getStudents</code> identifier is auto-initialized with the function reference, again at the beginning of the scope.</p><p>Why is this useful? The reason I prefer to take advantage of <em>function hoisting</em> is that it puts the <em>executable</em> code in any scope at the top, and any further declarations (functions) below. This means it's easier to find the code that will run in any given area, rather than having to scroll and scroll, hoping to find a trailing <code>}</code> marking the end of a scope/function somewhere.</p><p>I take advantage of this inverse positioning in all levels of scope:</p><pre><code>getStudents();\n\n// *************\n\nfunction getStudents() {\n    var whatever = doSomething();\n\n    // other stuff\n\n    return whatever;\n\n    // *************\n\n    function doSomething() {\n        // ..\n    }\n}</code></pre><p>When I first open a file like that, the very first line is executable code that kicks off its behavior. That's very easy to spot! Then, if I ever need to go find and inspect <code>getStudents()</code>, I like that its first line is also executable code. Only if I need to see the details of <code>doSomething()</code> do I go and find its definition down below.</p><p>In other words, I think <em>function hoisting</em> makes code more readable through a flowing, progressive reading order, from top to bottom.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Function Hoisting", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To review, this program works because of ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "getStudents();\n\n// ..\n\nfunction getStudents() {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration is hoisted during compilation, which means that ", "type": "text"}, {"text": "getStudents", "type": "text", "marks": [{"type": "code"}]}, {"text": " is an identifier declared for the entire scope. Additionally, the ", "type": "text"}, {"text": "getStudents", "type": "text", "marks": [{"type": "code"}]}, {"text": " identifier is auto-initialized with the function reference, again at the beginning of the scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why is this useful? The reason I prefer to take advantage of ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is that it puts the ", "type": "text"}, {"text": "executable", "type": "text", "marks": [{"type": "italic"}]}, {"text": " code in any scope at the top, and any further declarations (functions) below. This means it's easier to find the code that will run in any given area, rather than having to scroll and scroll, hoping to find a trailing ", "type": "text"}, {"text": "}", "type": "text", "marks": [{"type": "code"}]}, {"text": " marking the end of a scope/function somewhere.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I take advantage of this inverse positioning in all levels of scope:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "getStudents();\n\n// *************\n\nfunction getStudents() {\n    var whatever = doSomething();\n\n    // other stuff\n\n    return whatever;\n\n    // *************\n\n    function doSomething() {\n        // ..\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When I first open a file like that, the very first line is executable code that kicks off its behavior. That's very easy to spot! Then, if I ever need to go find and inspect ", "type": "text"}, {"text": "getStudents()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", I like that its first line is also executable code. Only if I need to see the details of ", "type": "text"}, {"text": "doSomething()", "type": "text", "marks": [{"type": "code"}]}, {"text": " do I go and find its definition down below.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, I think ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " makes code more readable through a flowing, progressive reading order, from top to bottom.", "type": "text"}]}]}, "article_text": "Function Hoisting\n\nTo review, this program works because of function hoisting:\n\ngetStudents();\n\n// ..\n\nfunction getStudents() {\n    // ..\n}\n\nThe function declaration is hoisted during compilation, which means that getStudents is an identifier declared for the entire scope. Additionally, the getStudents identifier is auto-initialized with the function reference, again at the beginning of the scope.\n\nWhy is this useful? The reason I prefer to take advantage of function hoisting is that it puts the executable code in any scope at the top, and any further declarations (functions) below. This means it's easier to find the code that will run in any given area, rather than having to scroll and scroll, hoping to find a trailing } marking the end of a scope/function somewhere.\n\nI take advantage of this inverse positioning in all levels of scope:\n\ngetStudents();\n\n// *************\n\nfunction getStudents() {\n    var whatever = doSomething();\n\n    // other stuff\n\n    return whatever;\n\n    // *************\n\n    function doSomething() {\n        // ..\n    }\n}\n\nWhen I first open a file like that, the very first line is executable code that kicks off its behavior. That's very easy to spot! Then, if I ever need to go find and inspect getStudents(), I like that its first line is also executable code. Only if I need to see the details of doSomething() do I go and find its definition down below.\n\nIn other words, I think function hoisting makes code more readable through a flowing, progressive reading order, from top to bottom."}, "id": 253}, {"data": {"uuid": "23aaacfc-afdc-46dd-bf09-12a5577f1b7b", "user": 1, "title": "Variable Hoisting", "author": "Kyle Simpson", "created_on": "2023-06-09 02:02:14.315400+00:00", "updated_on": "2023-06-09 02:02:36.541176+00:00", "article_html": "<h3>Variable Hoisting</h3><p>What about <em>variable hoisting</em>?</p><p>Even though <code>let</code> and <code>const</code> hoist, you cannot use those variables in their TDZ (see Chapter 5). So, the following discussion only applies to <code>var</code> declarations. Before I continue, I'll admit: in almost all cases, I completely agree that <em>variable hoisting</em> is a bad idea:</p><pre><code>pleaseDontDoThis = \"bad idea\";\n\n// much later\nvar pleaseDontDoThis;</code></pre><p>While that kind of inverted ordering was helpful for <em>function hoisting</em>, here I think it usually makes code harder to reason about.</p><p>But there's one exception that I've found, somewhat rarely, in my own coding. It has to do with where I place my <code>var</code> declarations inside a CommonJS module definition.</p><p>Here's how I typically structure my module definitions in Node:</p><pre><code>// dependencies\nvar aModuleINeed = require(\"very-helpful\");\nvar anotherModule = require(\"kinda-helpful\");\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    // ..\n});\n\n// ********************************\n// private implementation\n\nvar cache = { };\nvar otherData = [ ];\n\nfunction getStudents() {\n    // ..\n}\n\nfunction addStudents() {\n    // ..\n}</code></pre><p>Notice how the <code>cache</code> and <code>otherData</code> variables are in the \"private\" section of the module layout? That's because I don't plan to expose them publicly. So I organize the module so they're located alongside the other hidden implementation details of the module.</p><p>But I've had a few rare cases where I needed the assignments of those values to happen <em>above</em>, before I declare the exported public API of the module. For instance:</p><pre><code>// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    refreshData: refreshData.bind(null,cache)\n});</code></pre><p>I need the <code>cache</code> variable to have already been assigned a value, because that value is used in the initialization of the public API (the <code>.bind(..)</code> partial-application).</p><p>Should I just move the <code>var cache = { .. }</code> up to the top, above this public API initialization? Well, perhaps. But now it's less obvious that <code>var cache</code> is a <em>private</em> implementation detail. Here's the compromise I've (somewhat rarely) used:</p><pre><code>cache = {};   // used here, but declared below\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    refreshData: refreshData.bind(null,cache)\n});\n\n// ********************************\n// private implementation\n\nvar cache /* = {}*/;</code></pre><p>See the <em>variable hoisting</em>? I've declared the <code>cache</code> down where it belongs, logically, but in this rare case I've used it earlier up above, in the area where its initialization is needed. I even left a hint at the value that's assigned to <code>cache</code> in a code comment.</p><p>That's literally the only case I've ever found for leveraging <em>variable hoisting</em> to assign a variable earlier in a scope than its declaration. But I think it's a reasonable exception to employ with caution.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Variable Hoisting", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even though ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " hoist, you cannot use those variables in their TDZ (see Chapter 5). So, the following discussion only applies to ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations. Before I continue, I'll admit: in almost all cases, I completely agree that ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is a bad idea:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "pleaseDontDoThis = \"bad idea\";\n\n// much later\nvar pleaseDontDoThis;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "While that kind of inverted ordering was helpful for ", "type": "text"}, {"text": "function hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", here I think it usually makes code harder to reason about.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But there's one exception that I've found, somewhat rarely, in my own coding. It has to do with where I place my ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations inside a CommonJS module definition.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's how I typically structure my module definitions in Node:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// dependencies\nvar aModuleINeed = require(\"very-helpful\");\nvar anotherModule = require(\"kinda-helpful\");\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    // ..\n});\n\n// ********************************\n// private implementation\n\nvar cache = { };\nvar otherData = [ ];\n\nfunction getStudents() {\n    // ..\n}\n\nfunction addStudents() {\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice how the ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "otherData", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables are in the \"private\" section of the module layout? That's because I don't plan to expose them publicly. So I organize the module so they're located alongside the other hidden implementation details of the module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I've had a few rare cases where I needed the assignments of those values to happen ", "type": "text"}, {"text": "above", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", before I declare the exported public API of the module. For instance:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    refreshData: refreshData.bind(null,cache)\n});", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I need the ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable to have already been assigned a value, because that value is used in the initialization of the public API (the ", "type": "text"}, {"text": ".bind(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " partial-application).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Should I just move the ", "type": "text"}, {"text": "var cache = { .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": " up to the top, above this public API initialization? Well, perhaps. But now it's less obvious that ", "type": "text"}, {"text": "var cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "private", "type": "text", "marks": [{"type": "italic"}]}, {"text": " implementation detail. Here's the compromise I've (somewhat rarely) used:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "cache = {};   // used here, but declared below\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    refreshData: refreshData.bind(null,cache)\n});\n\n// ********************************\n// private implementation\n\nvar cache /* = {}*/;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "See the ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? I've declared the ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " down where it belongs, logically, but in this rare case I've used it earlier up above, in the area where its initialization is needed. I even left a hint at the value that's assigned to ", "type": "text"}, {"text": "cache", "type": "text", "marks": [{"type": "code"}]}, {"text": " in a code comment.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's literally the only case I've ever found for leveraging ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to assign a variable earlier in a scope than its declaration. But I think it's a reasonable exception to employ with caution.", "type": "text"}]}]}, "article_text": "Variable Hoisting\n\nWhat about variable hoisting?\n\nEven though let and const hoist, you cannot use those variables in their TDZ (see Chapter 5). So, the following discussion only applies to var declarations. Before I continue, I'll admit: in almost all cases, I completely agree that variable hoisting is a bad idea:\n\npleaseDontDoThis = \"bad idea\";\n\n// much later\nvar pleaseDontDoThis;\n\nWhile that kind of inverted ordering was helpful for function hoisting, here I think it usually makes code harder to reason about.\n\nBut there's one exception that I've found, somewhat rarely, in my own coding. It has to do with where I place my var declarations inside a CommonJS module definition.\n\nHere's how I typically structure my module definitions in Node:\n\n// dependencies\nvar aModuleINeed = require(\"very-helpful\");\nvar anotherModule = require(\"kinda-helpful\");\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    // ..\n});\n\n// ********************************\n// private implementation\n\nvar cache = { };\nvar otherData = [ ];\n\nfunction getStudents() {\n    // ..\n}\n\nfunction addStudents() {\n    // ..\n}\n\nNotice how the cache and otherData variables are in the \"private\" section of the module layout? That's because I don't plan to expose them publicly. So I organize the module so they're located alongside the other hidden implementation details of the module.\n\nBut I've had a few rare cases where I needed the assignments of those values to happen above, before I declare the exported public API of the module. For instance:\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    refreshData: refreshData.bind(null,cache)\n});\n\nI need the cache variable to have already been assigned a value, because that value is used in the initialization of the public API (the .bind(..) partial-application).\n\nShould I just move the var cache = { .. } up to the top, above this public API initialization? Well, perhaps. But now it's less obvious that var cache is a private implementation detail. Here's the compromise I've (somewhat rarely) used:\n\ncache = {};   // used here, but declared below\n\n// public API\nvar publicAPI = Object.assign(module.exports,{\n    getStudents,\n    addStudents,\n    refreshData: refreshData.bind(null,cache)\n});\n\n// ********************************\n// private implementation\n\nvar cache /* = {}*/;\n\nSee the variable hoisting? I've declared the cache down where it belongs, logically, but in this rare case I've used it earlier up above, in the area where its initialization is needed. I even left a hint at the value that's assigned to cache in a code comment.\n\nThat's literally the only case I've ever found for leveraging variable hoisting to assign a variable earlier in a scope than its declaration. But I think it's a reasonable exception to employ with caution."}, "id": 254}]}, {"data": {"uuid": "91d988f9-1e8e-48ab-8a21-4699c983464a", "user": 1, "title": "The Case for var", "author": "Kyle Simpson", "created_on": "2023-06-09 02:03:03.889031+00:00", "updated_on": "2023-06-09 02:03:18.358524+00:00", "article_html": "<h2>The Case for <code>var</code></h2><p>Speaking of <em>variable hoisting</em>, let's have some real talk for a bit about <code>var</code>, a favorite villain devs love to blame for many of the woes of JS development. In Chapter 5, we explored <code>let</code>/<code>const</code> and promised we'd revisit where <code>var</code> falls in the whole mix.</p><p>As I lay out the case, don't miss:</p><ul><li><p><code>var</code> was never broken</p></li><li><p><code>let</code> is your friend</p></li><li><p><code>const</code> has limited utility</p></li><li><p>The best of both worlds: <code>var</code> <em>and</em> <code>let</code></p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Case for ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}]}, {"type": "paragraph", "content": [{"text": "Speaking of ", "type": "text"}, {"text": "variable hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", let's have some real talk for a bit about ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", a favorite villain devs love to blame for many of the woes of JS development. In Chapter 5, we explored ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " and promised we'd revisit where ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " falls in the whole mix.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As I lay out the case, don't miss:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " was never broken", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is your friend", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " has limited utility", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The best of both worlds: ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}]}]}]}]}, "article_text": "The Case for var\n\nSpeaking of variable hoisting, let's have some real talk for a bit about var, a favorite villain devs love to blame for many of the woes of JS development. In Chapter 5, we explored let/const and promised we'd revisit where var falls in the whole mix.\n\nAs I lay out the case, don't miss:\n\nvar was never broken\n\nlet is your friend\n\nconst has limited utility\n\nThe best of both worlds: var and let"}, "id": 255, "children": [{"data": {"uuid": "f1b7ac9f-a119-41f9-afbf-530ceb34e57b", "user": 1, "title": "Don't Throw Out var", "author": "Kyle Simpson", "created_on": "2023-06-09 02:03:45.664107+00:00", "updated_on": "2023-06-09 02:04:06.639897+00:00", "article_html": "<h3>Don't Throw Out <code>var</code></h3><p><code>var</code> is fine, and works just fine. It's been around for 25 years, and it'll be around and useful and functional for another 25 years or more. Claims that <code>var</code> is broken, deprecated, outdated, dangerous, or ill-designed are bogus bandwagoning.</p><p>Does that mean <code>var</code> is the right declarator for every single declaration in your program? Certainly not. But it still has its place in your programs. Refusing to use it because someone on the team chose an aggressive linter opinion that chokes on <code>var</code> is cutting off your nose to spite your face.</p><p>OK, now that I've got you really riled up, let me try to explain my position.</p><p>For the record, I'm a fan of <code>let</code>, for block-scoped declarations. I really dislike TDZ and I think that was a mistake. But <code>let</code> itself is great. I use it often. In fact, I probably use it as much or more than I use <code>var</code>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Don't Throw Out ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}]}, {"type": "paragraph", "content": [{"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is fine, and works just fine. It's been around for 25 years, and it'll be around and useful and functional for another 25 years or more. Claims that ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is broken, deprecated, outdated, dangerous, or ill-designed are bogus bandwagoning.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Does that mean ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is the right declarator for every single declaration in your program? Certainly not. But it still has its place in your programs. Refusing to use it because someone on the team chose an aggressive linter opinion that chokes on ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is cutting off your nose to spite your face.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "OK, now that I've got you really riled up, let me try to explain my position.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For the record, I'm a fan of ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", for block-scoped declarations. I really dislike TDZ and I think that was a mistake. But ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " itself is great. I use it often. In fact, I probably use it as much or more than I use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Don't Throw Out var\n\nvar is fine, and works just fine. It's been around for 25 years, and it'll be around and useful and functional for another 25 years or more. Claims that var is broken, deprecated, outdated, dangerous, or ill-designed are bogus bandwagoning.\n\nDoes that mean var is the right declarator for every single declaration in your program? Certainly not. But it still has its place in your programs. Refusing to use it because someone on the team chose an aggressive linter opinion that chokes on var is cutting off your nose to spite your face.\n\nOK, now that I've got you really riled up, let me try to explain my position.\n\nFor the record, I'm a fan of let, for block-scoped declarations. I really dislike TDZ and I think that was a mistake. But let itself is great. I use it often. In fact, I probably use it as much or more than I use var."}, "id": 256}, {"data": {"uuid": "a9caacd7-bb96-4321-b284-3aca9b3d8760", "user": 1, "title": "const-antly Confused", "author": "Kyle Simpson", "created_on": "2023-06-09 02:04:24.816110+00:00", "updated_on": "2023-06-09 02:04:37.370043+00:00", "article_html": "<h3><code>const</code>-antly Confused</h3><p><code>const</code> on the other hand, I don't use as often. I'm not going to dig into all the reasons why, but it comes down to <code>const</code> not <em>carrying its own weight</em>. That is, while there's a tiny bit of benefit of <code>const</code> in some cases, that benefit is outweighed by the long history of troubles around <code>const</code> confusion in a variety of languages, long before it ever showed up in JS.</p><p><code>const</code> pretends to create values that can't be mutated\u2014a misconception that's extremely common in developer communities across many languages\u2014whereas what it really does is prevent re-assignment.</p><pre><code>const studentIDs = [ 14, 73, 112 ];\n\n// later\n\nstudentIDs.push(6);   // whoa, wait... what!?</code></pre><p>Using a <code>const</code> with a mutable value (like an array or object) is asking for a future developer (or reader of your code) to fall into the trap you set, which was that they either didn't know, or sorta forgot, that <em>value immutability</em> isn't at all the same thing as <em>assignment immutability</em>.</p><p>I just don't think we should set those traps. The only time I ever use <code>const</code> is when I'm assigning an already-immutable value (like <code>42</code> or <code>\"Hello, friends!\"</code>), and when it's clearly a \"constant\" in the sense of being a named placeholder for a literal value, for semantic purposes. That's what <code>const</code> is best used for. That's pretty rare in my code, though.</p><p>If variable re-assignment were a big deal, then <code>const</code> would be more useful. But variable re-assignment just isn't that big of a deal in terms of causing bugs. There's a long list of things that lead to bugs in programs, but \"accidental re-assignment\" is way, way down that list.</p><p>Combine that with the fact that <code>const</code> (and <code>let</code>) are supposed to be used in blocks, and blocks are supposed to be short, and you have a really small area of your code where a <code>const</code> declaration is even applicable. A <code>const</code> on line 1 of your ten-line block only tells you something about the next nine lines. And the thing it tells you is already obvious by glancing down at those nine lines: the variable is never on the left-hand side of an <code>=</code>; it's not re-assigned.</p><p>That's it, that's all <code>const</code> really does. Other than that, it's not very useful. Stacked up against the significant confusion of value vs. assignment immutability, <code>const</code> loses a lot of its luster.</p><p>A <code>let</code> (or <code>var</code>!) that's never re-assigned is already behaviorally a \"constant\", even though it doesn't have the compiler guarantee. That's good enough in most cases.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "-antly Confused", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " on the other hand, I don't use as often. I'm not going to dig into all the reasons why, but it comes down to ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " not ", "type": "text"}, {"text": "carrying its own weight", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". That is, while there's a tiny bit of benefit of ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " in some cases, that benefit is outweighed by the long history of troubles around ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " confusion in a variety of languages, long before it ever showed up in JS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " pretends to create values that can't be mutated\u2014a misconception that's extremely common in developer communities across many languages\u2014whereas what it really does is prevent re-assignment.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const studentIDs = [ 14, 73, 112 ];\n\n// later\n\nstudentIDs.push(6);   // whoa, wait... what!?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Using a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " with a mutable value (like an array or object) is asking for a future developer (or reader of your code) to fall into the trap you set, which was that they either didn't know, or sorta forgot, that ", "type": "text"}, {"text": "value immutability", "type": "text", "marks": [{"type": "italic"}]}, {"text": " isn't at all the same thing as ", "type": "text"}, {"text": "assignment immutability", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I just don't think we should set those traps. The only time I ever use ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " is when I'm assigning an already-immutable value (like ", "type": "text"}, {"text": "42", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "\"Hello, friends!\"", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and when it's clearly a \"constant\" in the sense of being a named placeholder for a literal value, for semantic purposes. That's what ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " is best used for. That's pretty rare in my code, though.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If variable re-assignment were a big deal, then ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " would be more useful. But variable re-assignment just isn't that big of a deal in terms of causing bugs. There's a long list of things that lead to bugs in programs, but \"accidental re-assignment\" is way, way down that list.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Combine that with the fact that ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ") are supposed to be used in blocks, and blocks are supposed to be short, and you have a really small area of your code where a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration is even applicable. A ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " on line 1 of your ten-line block only tells you something about the next nine lines. And the thing it tells you is already obvious by glancing down at those nine lines: the variable is never on the left-hand side of an ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": "; it's not re-assigned.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's it, that's all ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " really does. Other than that, it's not very useful. Stacked up against the significant confusion of value vs. assignment immutability, ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " loses a lot of its luster.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " (or ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "!) that's never re-assigned is already behaviorally a \"constant\", even though it doesn't have the compiler guarantee. That's good enough in most cases.", "type": "text"}]}]}, "article_text": "const-antly Confused\n\nconst on the other hand, I don't use as often. I'm not going to dig into all the reasons why, but it comes down to const not carrying its own weight. That is, while there's a tiny bit of benefit of const in some cases, that benefit is outweighed by the long history of troubles around const confusion in a variety of languages, long before it ever showed up in JS.\n\nconst pretends to create values that can't be mutated\u2014a misconception that's extremely common in developer communities across many languages\u2014whereas what it really does is prevent re-assignment.\n\nconst studentIDs = [ 14, 73, 112 ];\n\n// later\n\nstudentIDs.push(6);   // whoa, wait... what!?\n\nUsing a const with a mutable value (like an array or object) is asking for a future developer (or reader of your code) to fall into the trap you set, which was that they either didn't know, or sorta forgot, that value immutability isn't at all the same thing as assignment immutability.\n\nI just don't think we should set those traps. The only time I ever use const is when I'm assigning an already-immutable value (like 42 or \"Hello, friends!\"), and when it's clearly a \"constant\" in the sense of being a named placeholder for a literal value, for semantic purposes. That's what const is best used for. That's pretty rare in my code, though.\n\nIf variable re-assignment were a big deal, then const would be more useful. But variable re-assignment just isn't that big of a deal in terms of causing bugs. There's a long list of things that lead to bugs in programs, but \"accidental re-assignment\" is way, way down that list.\n\nCombine that with the fact that const (and let) are supposed to be used in blocks, and blocks are supposed to be short, and you have a really small area of your code where a const declaration is even applicable. A const on line 1 of your ten-line block only tells you something about the next nine lines. And the thing it tells you is already obvious by glancing down at those nine lines: the variable is never on the left-hand side of an =; it's not re-assigned.\n\nThat's it, that's all const really does. Other than that, it's not very useful. Stacked up against the significant confusion of value vs. assignment immutability, const loses a lot of its luster.\n\nA let (or var!) that's never re-assigned is already behaviorally a \"constant\", even though it doesn't have the compiler guarantee. That's good enough in most cases."}, "id": 257}, {"data": {"uuid": "014cbc7c-0461-448c-a97d-dcd596ecb09a", "user": 1, "title": "var and let", "author": "Kyle Simpson", "created_on": "2023-06-09 02:05:03.076872+00:00", "updated_on": "2023-06-09 02:05:56.407268+00:00", "article_html": "<h3><code>var</code> <em>and</em> <code>let</code></h3><p>In my mind, <code>const</code> is pretty rarely useful, so this is only two-horse race between <code>let</code> and <code>var</code>. But it's not really a race either, because there doesn't have to be just one winner. They can both win... different races.</p><p>The fact is, you should be using both <code>var</code> and <code>let</code> in your programs. They are not interchangeable: you shouldn't use <code>var</code> where a <code>let</code> is called for, but you also shouldn't use <code>let</code> where a <code>var</code> is most appropriate.</p><p>So where should we still use <code>var</code>? Under what circumstances is it a better choice than <code>let</code>?</p><p>For one, I always use <code>var</code> in the top-level scope of any function, regardless of whether that's at the beginning, middle, or end of the function. I also use <code>var</code> in the global scope, though I try to minimize usage of the global scope.</p><p>Why use <code>var</code> for function scoping? Because that's exactly what <code>var</code> does. There literally is no better tool for the job of function scoping a declaration than a declarator that has, for 25 years, done exactly that.</p><p>You <em>could</em> use <code>let</code> in this top-level scope, but it's not the best tool for that job. I also find that if you use <code>let</code> everywhere, then it's less obvious which declarations are designed to be localized and which ones are intended to be used throughout the function.</p><p>By contrast, I rarely use a <code>var</code> inside a block. That's what <code>let</code> is for. Use the best tool for the job. If you see a <code>let</code>, it tells you that you're dealing with a localized declaration. If you see <code>var</code>, it tells you that you're dealing with a function-wide declaration. Simple as that.</p><pre><code>function getStudents(data) {\n    var studentRecords = [];\n\n    for (let record of data.records) {\n        let id = `student-${ record.id }`;\n        studentRecords.push({\n            id,\n            record.name\n        });\n    }\n\n    return studentRecords;\n}</code></pre><p>The <code>studentRecords</code> variable is intended for use across the whole function. <code>var</code> is the best declarator to tell the reader that. By contrast, <code>record</code> and <code>id</code> are intended for use only in the narrower scope of the loop iteration, so <code>let</code> is the best tool for that job.</p><p>In addition to this <em>best tool</em> semantic argument, <code>var</code> has a few other characteristics that, in certain limited circumstances, make it more powerful.</p><p>One example is when a loop is exclusively using a variable, but its conditional clause cannot see block-scoped declarations inside the iteration:</p><pre><code>function commitAction() {\n    do {\n        let result = commit();\n        var done = result &amp;&amp; result.code == 1;\n    } while (!done);\n}</code></pre><p>Here, <code>result</code> is clearly only used inside the block, so we use <code>let</code>. But <code>done</code> is a bit different. It's only useful for the loop, but the <code>while</code> clause cannot see <code>let</code> declarations that appear inside the loop. So we compromise and use <code>var</code>, so that <code>done</code> is hoisted to the outer scope where it can be seen.</p><p>The alternative\u2014declaring <code>done</code> outside the loop\u2014separates it from where it's first used, and either necessitates picking a default value to assign, or worse, leaving it unassigned and thus looking ambiguous to the reader. I think <code>var</code> inside the loop is preferable here.</p><p>Another helpful characteristic of <code>var</code> is seen with declarations inside unintended blocks. Unintended blocks are blocks that are created because the syntax requires a block, but where the intent of the developer is not really to create a localized scope. The best illustration of unintended scope is the <code>try..catch</code> statement:</p><pre><code>function getStudents() {\n    try {\n        // not really a block scope\n        var records = fromCache(\"students\");\n    }\n    catch (err) {\n        // oops, fall back to a default\n        var records = [];\n    }\n    // ..\n}</code></pre><p>There are other ways to structure this code, yes. But I think this is the <em>best</em> way, given various trade-offs.</p><p>I don't want to declare <code>records</code> (with <code>var</code> or <code>let</code>) outside of the <code>try</code> block, and then assign to it in one or both blocks. I prefer initial declarations to always be as close as possible (ideally, same line) to the first usage of the variable. In this simple example, that would only be a couple of lines distance, but in real code it can grow to many more lines. The bigger the gap, the harder it is to figure out what variable from what scope you're assigning to. <code>var</code> used at the actual assignment makes it less ambiguous.</p><p>Also notice I used <code>var</code> in both the <code>try</code> and <code>catch</code> blocks. That's because I want to signal to the reader that no matter which path is taken, <code>records</code> always gets declared. Technically, that works because <code>var</code> is hoisted once to the function scope. But it's still a nice semantic signal to remind the reader what either <code>var</code> ensures. If <code>var</code> were only used in one of the blocks, and you were only reading the other block, you wouldn't as easily discover where <code>records</code> was coming from.</p><p>This is, in my opinion, a little superpower of <code>var</code>. Not only can it escape the unintentional <code>try..catch</code> blocks, but it's allowed to appear multiple times in a function's scope. You can't do that with <code>let</code>. It's not bad, it's actually a little helpful feature. Think of <code>var</code> more like a declarative annotation that's reminding you, each usage, where the variable comes from. \"Ah ha, right, it belongs to the whole function.\"</p><p>This repeated-annotation superpower is useful in other cases:</p><pre><code>function getStudents() {\n    var data = [];\n\n    // do something with data\n    // .. 50 more lines of code ..\n\n    // purely an annotation to remind us\n    var data;\n\n    // use data again\n    // ..\n}</code></pre><p>The second <code>var data</code> is not re-declaring <code>data</code>, it's just annotating for the readers' benefit that <code>data</code> is a function-wide declaration. That way, the reader doesn't need to scroll up 50+ lines of code to find the initial declaration.</p><p>I'm perfectly fine with re-using variables for multiple purposes throughout a function scope. I'm also perfectly fine with having two usages of a variable be separated by quite a few lines of code. In both cases, the ability to safely \"re-declare\" (annotate) with <code>var</code> helps make sure I can tell where my <code>data</code> is coming from, no matter where I am in the function.</p><p>Again, sadly, <code>let</code> cannot do this.</p><p>There are other nuances and scenarios when <code>var</code> turns out to offer some assistance, but I'm not going to belabor the point any further. The takeaway is that <code>var</code> can be useful in our programs alongside <code>let</code> (and the occasional <code>const</code>). Are you willing to creatively use the tools the JS language provides to tell a richer story to your readers?</p><p>Don't just throw away a useful tool like <code>var</code> because someone shamed you into thinking it wasn't cool anymore. Don't avoid <code>var</code> because you got confused once years ago. Learn these tools and use them each for what they're best at.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}]}, {"type": "paragraph", "content": [{"text": "In my mind, ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " is pretty rarely useful, so this is only two-horse race between ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But it's not really a race either, because there doesn't have to be just one winner. They can both win... different races.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The fact is, you should be using both ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in your programs. They are not interchangeable: you shouldn't use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " where a ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is called for, but you also shouldn't use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " where a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is most appropriate.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So where should we still use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "? Under what circumstances is it a better choice than ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For one, I always use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the top-level scope of any function, regardless of whether that's at the beginning, middle, or end of the function. I also use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the global scope, though I try to minimize usage of the global scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " for function scoping? Because that's exactly what ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " does. There literally is no better tool for the job of function scoping a declaration than a declarator that has, for 25 years, done exactly that.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You ", "type": "text"}, {"text": "could", "type": "text", "marks": [{"type": "italic"}]}, {"text": " use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " in this top-level scope, but it's not the best tool for that job. I also find that if you use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " everywhere, then it's less obvious which declarations are designed to be localized and which ones are intended to be used throughout the function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By contrast, I rarely use a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside a block. That's what ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is for. Use the best tool for the job. If you see a ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it tells you that you're dealing with a localized declaration. If you see ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it tells you that you're dealing with a function-wide declaration. Simple as that.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudents(data) {\n    var studentRecords = [];\n\n    for (let record of data.records) {\n        let id = `student-${ record.id }`;\n        studentRecords.push({\n            id,\n            record.name\n        });\n    }\n\n    return studentRecords;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "studentRecords", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable is intended for use across the whole function. ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is the best declarator to tell the reader that. By contrast, ", "type": "text"}, {"text": "record", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "id", "type": "text", "marks": [{"type": "code"}]}, {"text": " are intended for use only in the narrower scope of the loop iteration, so ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is the best tool for that job.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In addition to this ", "type": "text"}, {"text": "best tool", "type": "text", "marks": [{"type": "italic"}]}, {"text": " semantic argument, ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " has a few other characteristics that, in certain limited circumstances, make it more powerful.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One example is when a loop is exclusively using a variable, but its conditional clause cannot see block-scoped declarations inside the iteration:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function commitAction() {\n    do {\n        let result = commit();\n        var done = result && result.code == 1;\n    } while (!done);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, ", "type": "text"}, {"text": "result", "type": "text", "marks": [{"type": "code"}]}, {"text": " is clearly only used inside the block, so we use ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ". But ", "type": "text"}, {"text": "done", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a bit different. It's only useful for the loop, but the ", "type": "text"}, {"text": "while", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause cannot see ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations that appear inside the loop. So we compromise and use ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so that ", "type": "text"}, {"text": "done", "type": "text", "marks": [{"type": "code"}]}, {"text": " is hoisted to the outer scope where it can be seen.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The alternative\u2014declaring ", "type": "text"}, {"text": "done", "type": "text", "marks": [{"type": "code"}]}, {"text": " outside the loop\u2014separates it from where it's first used, and either necessitates picking a default value to assign, or worse, leaving it unassigned and thus looking ambiguous to the reader. I think ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " inside the loop is preferable here.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another helpful characteristic of ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is seen with declarations inside unintended blocks. Unintended blocks are blocks that are created because the syntax requires a block, but where the intent of the developer is not really to create a localized scope. The best illustration of unintended scope is the ", "type": "text"}, {"text": "try..catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudents() {\n    try {\n        // not really a block scope\n        var records = fromCache(\"students\");\n    }\n    catch (err) {\n        // oops, fall back to a default\n        var records = [];\n    }\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are other ways to structure this code, yes. But I think this is the ", "type": "text"}, {"text": "best", "type": "text", "marks": [{"type": "italic"}]}, {"text": " way, given various trade-offs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I don't want to declare ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " (with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ") outside of the ", "type": "text"}, {"text": "try", "type": "text", "marks": [{"type": "code"}]}, {"text": " block, and then assign to it in one or both blocks. I prefer initial declarations to always be as close as possible (ideally, same line) to the first usage of the variable. In this simple example, that would only be a couple of lines distance, but in real code it can grow to many more lines. The bigger the gap, the harder it is to figure out what variable from what scope you're assigning to. ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " used at the actual assignment makes it less ambiguous.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Also notice I used ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " in both the ", "type": "text"}, {"text": "try", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " blocks. That's because I want to signal to the reader that no matter which path is taken, ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " always gets declared. Technically, that works because ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is hoisted once to the function scope. But it's still a nice semantic signal to remind the reader what either ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " ensures. If ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " were only used in one of the blocks, and you were only reading the other block, you wouldn't as easily discover where ", "type": "text"}, {"text": "records", "type": "text", "marks": [{"type": "code"}]}, {"text": " was coming from.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is, in my opinion, a little superpower of ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Not only can it escape the unintentional ", "type": "text"}, {"text": "try..catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " blocks, but it's allowed to appear multiple times in a function's scope. You can't do that with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ". It's not bad, it's actually a little helpful feature. Think of ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " more like a declarative annotation that's reminding you, each usage, where the variable comes from. \"Ah ha, right, it belongs to the whole function.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This repeated-annotation superpower is useful in other cases:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getStudents() {\n    var data = [];\n\n    // do something with data\n    // .. 50 more lines of code ..\n\n    // purely an annotation to remind us\n    var data;\n\n    // use data again\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The second ", "type": "text"}, {"text": "var data", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not re-declaring ", "type": "text"}, {"text": "data", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it's just annotating for the readers' benefit that ", "type": "text"}, {"text": "data", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a function-wide declaration. That way, the reader doesn't need to scroll up 50+ lines of code to find the initial declaration.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm perfectly fine with re-using variables for multiple purposes throughout a function scope. I'm also perfectly fine with having two usages of a variable be separated by quite a few lines of code. In both cases, the ability to safely \"re-declare\" (annotate) with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " helps make sure I can tell where my ", "type": "text"}, {"text": "data", "type": "text", "marks": [{"type": "code"}]}, {"text": " is coming from, no matter where I am in the function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Again, sadly, ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " cannot do this.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are other nuances and scenarios when ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " turns out to offer some assistance, but I'm not going to belabor the point any further. The takeaway is that ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " can be useful in our programs alongside ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and the occasional ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "). Are you willing to creatively use the tools the JS language provides to tell a richer story to your readers?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't just throw away a useful tool like ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " because someone shamed you into thinking it wasn't cool anymore. Don't avoid ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " because you got confused once years ago. Learn these tools and use them each for what they're best at.", "type": "text"}]}]}, "article_text": "var and let\n\nIn my mind, const is pretty rarely useful, so this is only two-horse race between let and var. But it's not really a race either, because there doesn't have to be just one winner. They can both win... different races.\n\nThe fact is, you should be using both var and let in your programs. They are not interchangeable: you shouldn't use var where a let is called for, but you also shouldn't use let where a var is most appropriate.\n\nSo where should we still use var? Under what circumstances is it a better choice than let?\n\nFor one, I always use var in the top-level scope of any function, regardless of whether that's at the beginning, middle, or end of the function. I also use var in the global scope, though I try to minimize usage of the global scope.\n\nWhy use var for function scoping? Because that's exactly what var does. There literally is no better tool for the job of function scoping a declaration than a declarator that has, for 25 years, done exactly that.\n\nYou could use let in this top-level scope, but it's not the best tool for that job. I also find that if you use let everywhere, then it's less obvious which declarations are designed to be localized and which ones are intended to be used throughout the function.\n\nBy contrast, I rarely use a var inside a block. That's what let is for. Use the best tool for the job. If you see a let, it tells you that you're dealing with a localized declaration. If you see var, it tells you that you're dealing with a function-wide declaration. Simple as that.\n\nfunction getStudents(data) {\n    var studentRecords = [];\n\n    for (let record of data.records) {\n        let id = `student-${ record.id }`;\n        studentRecords.push({\n            id,\n            record.name\n        });\n    }\n\n    return studentRecords;\n}\n\nThe studentRecords variable is intended for use across the whole function. var is the best declarator to tell the reader that. By contrast, record and id are intended for use only in the narrower scope of the loop iteration, so let is the best tool for that job.\n\nIn addition to this best tool semantic argument, var has a few other characteristics that, in certain limited circumstances, make it more powerful.\n\nOne example is when a loop is exclusively using a variable, but its conditional clause cannot see block-scoped declarations inside the iteration:\n\nfunction commitAction() {\n    do {\n        let result = commit();\n        var done = result && result.code == 1;\n    } while (!done);\n}\n\nHere, result is clearly only used inside the block, so we use let. But done is a bit different. It's only useful for the loop, but the while clause cannot see let declarations that appear inside the loop. So we compromise and use var, so that done is hoisted to the outer scope where it can be seen.\n\nThe alternative\u2014declaring done outside the loop\u2014separates it from where it's first used, and either necessitates picking a default value to assign, or worse, leaving it unassigned and thus looking ambiguous to the reader. I think var inside the loop is preferable here.\n\nAnother helpful characteristic of var is seen with declarations inside unintended blocks. Unintended blocks are blocks that are created because the syntax requires a block, but where the intent of the developer is not really to create a localized scope. The best illustration of unintended scope is the try..catch statement:\n\nfunction getStudents() {\n    try {\n        // not really a block scope\n        var records = fromCache(\"students\");\n    }\n    catch (err) {\n        // oops, fall back to a default\n        var records = [];\n    }\n    // ..\n}\n\nThere are other ways to structure this code, yes. But I think this is the best way, given various trade-offs.\n\nI don't want to declare records (with var or let) outside of the try block, and then assign to it in one or both blocks. I prefer initial declarations to always be as close as possible (ideally, same line) to the first usage of the variable. In this simple example, that would only be a couple of lines distance, but in real code it can grow to many more lines. The bigger the gap, the harder it is to figure out what variable from what scope you're assigning to. var used at the actual assignment makes it less ambiguous.\n\nAlso notice I used var in both the try and catch blocks. That's because I want to signal to the reader that no matter which path is taken, records always gets declared. Technically, that works because var is hoisted once to the function scope. But it's still a nice semantic signal to remind the reader what either var ensures. If var were only used in one of the blocks, and you were only reading the other block, you wouldn't as easily discover where records was coming from.\n\nThis is, in my opinion, a little superpower of var. Not only can it escape the unintentional try..catch blocks, but it's allowed to appear multiple times in a function's scope. You can't do that with let. It's not bad, it's actually a little helpful feature. Think of var more like a declarative annotation that's reminding you, each usage, where the variable comes from. \"Ah ha, right, it belongs to the whole function.\"\n\nThis repeated-annotation superpower is useful in other cases:\n\nfunction getStudents() {\n    var data = [];\n\n    // do something with data\n    // .. 50 more lines of code ..\n\n    // purely an annotation to remind us\n    var data;\n\n    // use data again\n    // ..\n}\n\nThe second var data is not re-declaring data, it's just annotating for the readers' benefit that data is a function-wide declaration. That way, the reader doesn't need to scroll up 50+ lines of code to find the initial declaration.\n\nI'm perfectly fine with re-using variables for multiple purposes throughout a function scope. I'm also perfectly fine with having two usages of a variable be separated by quite a few lines of code. In both cases, the ability to safely \"re-declare\" (annotate) with var helps make sure I can tell where my data is coming from, no matter where I am in the function.\n\nAgain, sadly, let cannot do this.\n\nThere are other nuances and scenarios when var turns out to offer some assistance, but I'm not going to belabor the point any further. The takeaway is that var can be useful in our programs alongside let (and the occasional const). Are you willing to creatively use the tools the JS language provides to tell a richer story to your readers?\n\nDon't just throw away a useful tool like var because someone shamed you into thinking it wasn't cool anymore. Don't avoid var because you got confused once years ago. Learn these tools and use them each for what they're best at."}, "id": 258}]}, {"data": {"uuid": "e7a4ab12-36a0-4631-9ab6-087d47ec2462", "user": 1, "title": "What's the Deal with TDZ?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:06:17.125563+00:00", "updated_on": "2023-06-09 02:06:29.848687+00:00", "article_html": "<h2>What's the Deal with TDZ?</h2><p>The TDZ (temporal dead zone) was explained in Chapter 5. We illustrated how it occurs, but we skimmed over any explanation of <em>why</em> it was necessary to introduce in the first place. Let's look briefly at the motivations of TDZ.</p><p>Some breadcrumbs in the TDZ origin story:</p><ul><li><p><code>const</code>s should never change</p></li><li><p>It's all about time</p></li><li><p>Should <code>let</code> behave more like <code>const</code> or <code>var</code>?</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "What's the Deal with TDZ?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The TDZ (temporal dead zone) was explained in Chapter 5. We illustrated how it occurs, but we skimmed over any explanation of ", "type": "text"}, {"text": "why", "type": "text", "marks": [{"type": "italic"}]}, {"text": " it was necessary to introduce in the first place. Let's look briefly at the motivations of TDZ.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some breadcrumbs in the TDZ origin story:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "s should never change", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "It's all about time", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Should ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " behave more like ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}]}]}]}, "article_text": "What's the Deal with TDZ?\n\nThe TDZ (temporal dead zone) was explained in Chapter 5. We illustrated how it occurs, but we skimmed over any explanation of why it was necessary to introduce in the first place. Let's look briefly at the motivations of TDZ.\n\nSome breadcrumbs in the TDZ origin story:\n\nconsts should never change\n\nIt's all about time\n\nShould let behave more like const or var?"}, "id": 259, "children": [{"data": {"uuid": "c020803f-5088-4f08-a5c6-e7e84c1049d6", "user": 1, "title": "Where It All Started", "author": "Kyle Simpson", "created_on": "2023-06-09 02:06:48.232984+00:00", "updated_on": "2023-06-09 02:07:20.220452+00:00", "article_html": "<h3>Where It All Started</h3><p>TDZ comes from <code>const</code>, actually.</p><p>During early ES6 development work, TC39 had to decide whether <code>const</code> (and <code>let</code>) were going to hoist to the top of their blocks. They decided these declarations would hoist, similar to how <code>var</code> does. Had that not been the case, I think some of the fear was confusion with mid-scope shadowing, such as:</p><pre><code>let greeting = \"Hi!\";\n\n{\n    // what should print here?\n    console.log(greeting);\n\n    // .. a bunch of lines of code ..\n\n    // now shadowing the `greeting` variable\n    let greeting = \"Hello, friends!\";\n\n    // ..\n}</code></pre><p>What should we do with that <code>console.log(..)</code> statement? Would it make any sense to JS devs for it to print \"Hi!\"? Seems like that could be a gotcha, to have shadowing kick in only for the second half of the block, but not the first half. That's not very intuitive, JS-like behavior. So <code>let</code> and <code>const</code> have to hoist to the top of the block, visible throughout.</p><p>But if <code>let</code> and <code>const</code> hoist to the top of the block (like <code>var</code> hoists to the top of a function), why don't <code>let</code> and <code>const</code> auto-initialize (to <code>undefined</code>) the way <code>var</code> does? Here was the main concern:</p><pre><code>{\n    // what should print here?\n    console.log(studentName);\n\n    // later\n\n    const studentName = \"Frank\";\n\n    // ..\n}</code></pre><p>Let's imagine that <code>studentName</code> not only hoisted to the top of this block, but was also auto-initialized to <code>undefined</code>. For the first half of the block, <code>studentName</code> could be observed to have the <code>undefined</code> value, such as with our <code>console.log(..)</code> statement. Once the <code>const studentName = ..</code> statement is reached, now <code>studentName</code> is assigned <code>\"Frank\"</code>. From that point forward, <code>studentName</code> can't ever be re-assigned.</p><p>But, is it strange or surprising that a constant observably has two different values, first <code>undefined</code>, then <code>\"Frank\"</code>? That does seem to go against what we think a <code>const</code>ant means; it should only ever be observable with one value.</p><p>So... now we have a problem. We can't auto-initialize <code>studentName</code> to <code>undefined</code> (or any other value for that matter). But the variable has to exist throughout the whole scope. What do we do with the period of time from when it first exists (beginning of scope) and when it's assigned its value?</p><p>We call this period of time the \"dead zone,\" as in the \"temporal dead zone\" (TDZ). To prevent confusion, it was determined that any sort of access of a variable while in its TDZ is illegal and must result in the TDZ error.</p><p>OK, that line of reasoning does make some sense, I must admit.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Where It All Started", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "TDZ comes from ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", actually.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "During early ES6 development work, TC39 had to decide whether ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ") were going to hoist to the top of their blocks. They decided these declarations would hoist, similar to how ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " does. Had that not been the case, I think some of the fear was confusion with mid-scope shadowing, such as:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "let greeting = \"Hi!\";\n\n{\n    // what should print here?\n    console.log(greeting);\n\n    // .. a bunch of lines of code ..\n\n    // now shadowing the `greeting` variable\n    let greeting = \"Hello, friends!\";\n\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What should we do with that ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement? Would it make any sense to JS devs for it to print \"Hi!\"? Seems like that could be a gotcha, to have shadowing kick in only for the second half of the block, but not the first half. That's not very intuitive, JS-like behavior. So ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " have to hoist to the top of the block, visible throughout.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But if ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " hoist to the top of the block (like ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " hoists to the top of a function), why don't ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " auto-initialize (to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ") the way ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " does? Here was the main concern:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "{\n    // what should print here?\n    console.log(studentName);\n\n    // later\n\n    const studentName = \"Frank\";\n\n    // ..\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's imagine that ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " not only hoisted to the top of this block, but was also auto-initialized to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ". For the first half of the block, ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " could be observed to have the ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " value, such as with our ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement. Once the ", "type": "text"}, {"text": "const studentName = ..", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement is reached, now ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is assigned ", "type": "text"}, {"text": "\"Frank\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ". From that point forward, ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " can't ever be re-assigned.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But, is it strange or surprising that a constant observably has two different values, first ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ", then ", "type": "text"}, {"text": "\"Frank\"", "type": "text", "marks": [{"type": "code"}]}, {"text": "? That does seem to go against what we think a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "ant means; it should only ever be observable with one value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So... now we have a problem. We can't auto-initialize ", "type": "text"}, {"text": "studentName", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " (or any other value for that matter). But the variable has to exist throughout the whole scope. What do we do with the period of time from when it first exists (beginning of scope) and when it's assigned its value?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We call this period of time the \"dead zone,\" as in the \"temporal dead zone\" (TDZ). To prevent confusion, it was determined that any sort of access of a variable while in its TDZ is illegal and must result in the TDZ error.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "OK, that line of reasoning does make some sense, I must admit.", "type": "text"}]}]}, "article_text": "Where It All Started\n\nTDZ comes from const, actually.\n\nDuring early ES6 development work, TC39 had to decide whether const (and let) were going to hoist to the top of their blocks. They decided these declarations would hoist, similar to how var does. Had that not been the case, I think some of the fear was confusion with mid-scope shadowing, such as:\n\nlet greeting = \"Hi!\";\n\n{\n    // what should print here?\n    console.log(greeting);\n\n    // .. a bunch of lines of code ..\n\n    // now shadowing the `greeting` variable\n    let greeting = \"Hello, friends!\";\n\n    // ..\n}\n\nWhat should we do with that console.log(..) statement? Would it make any sense to JS devs for it to print \"Hi!\"? Seems like that could be a gotcha, to have shadowing kick in only for the second half of the block, but not the first half. That's not very intuitive, JS-like behavior. So let and const have to hoist to the top of the block, visible throughout.\n\nBut if let and const hoist to the top of the block (like var hoists to the top of a function), why don't let and const auto-initialize (to undefined) the way var does? Here was the main concern:\n\n{\n    // what should print here?\n    console.log(studentName);\n\n    // later\n\n    const studentName = \"Frank\";\n\n    // ..\n}\n\nLet's imagine that studentName not only hoisted to the top of this block, but was also auto-initialized to undefined. For the first half of the block, studentName could be observed to have the undefined value, such as with our console.log(..) statement. Once the const studentName = .. statement is reached, now studentName is assigned \"Frank\". From that point forward, studentName can't ever be re-assigned.\n\nBut, is it strange or surprising that a constant observably has two different values, first undefined, then \"Frank\"? That does seem to go against what we think a constant means; it should only ever be observable with one value.\n\nSo... now we have a problem. We can't auto-initialize studentName to undefined (or any other value for that matter). But the variable has to exist throughout the whole scope. What do we do with the period of time from when it first exists (beginning of scope) and when it's assigned its value?\n\nWe call this period of time the \"dead zone,\" as in the \"temporal dead zone\" (TDZ). To prevent confusion, it was determined that any sort of access of a variable while in its TDZ is illegal and must result in the TDZ error.\n\nOK, that line of reasoning does make some sense, I must admit."}, "id": 260}, {"data": {"uuid": "4dee2b56-d1c7-459e-aa76-09e92ef876a3", "user": 1, "title": "Who let the TDZ Out?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:07:37.290431+00:00", "updated_on": "2023-06-09 02:07:50.315407+00:00", "article_html": "<h3>Who <code>let</code> the TDZ Out?</h3><p>But that's just <code>const</code>. What about <code>let</code>?</p><p>Well, TC39 made the decision: since we need a TDZ for <code>const</code>, we might as well have a TDZ for <code>let</code> as well. <em>In fact, if we make let have a TDZ, then we discourage all that ugly variable hoisting people do.</em> So there was a consistency perspective and, perhaps, a bit of social engineering to shift developers' behavior.</p><p>My counter-argument would be: if you're favoring consistency, be consistent with <code>var</code> instead of <code>const</code>; <code>let</code> is definitely more like <code>var</code> than <code>const</code>. That's especially true since they had already chosen consistency with <code>var</code> for the whole hoisting-to-the-top-of-the-scope thing. Let <code>const</code> be its own unique deal with a TDZ, and let the answer to TDZ purely be: just avoid the TDZ by always declaring your constants at the top of the scope. I think this would have been more reasonable.</p><p>But alas, that's not how it landed. <code>let</code> has a TDZ because <code>const</code> needs a TDZ, because <code>let</code> and <code>const</code> mimic <code>var</code> in their hoisting to the top of the (block) scope. There ya go. Too circular? Read it again a few times.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Who ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " the TDZ Out?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But that's just ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ". What about ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Well, TC39 made the decision: since we need a TDZ for ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we might as well have a TDZ for ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " as well. ", "type": "text"}, {"text": "In fact, if we make let have a TDZ, then we discourage all that ugly variable hoisting people do.", "type": "text", "marks": [{"type": "italic"}]}, {"text": " So there was a consistency perspective and, perhaps, a bit of social engineering to shift developers' behavior.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My counter-argument would be: if you're favoring consistency, be consistent with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "; ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " is definitely more like ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " than ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ". That's especially true since they had already chosen consistency with ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " for the whole hoisting-to-the-top-of-the-scope thing. Let ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " be its own unique deal with a TDZ, and let the answer to TDZ purely be: just avoid the TDZ by always declaring your constants at the top of the scope. I think this would have been more reasonable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But alas, that's not how it landed. ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " has a TDZ because ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " needs a TDZ, because ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " mimic ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " in their hoisting to the top of the (block) scope. There ya go. Too circular? Read it again a few times.", "type": "text"}]}]}, "article_text": "Who let the TDZ Out?\n\nBut that's just const. What about let?\n\nWell, TC39 made the decision: since we need a TDZ for const, we might as well have a TDZ for let as well. In fact, if we make let have a TDZ, then we discourage all that ugly variable hoisting people do. So there was a consistency perspective and, perhaps, a bit of social engineering to shift developers' behavior.\n\nMy counter-argument would be: if you're favoring consistency, be consistent with var instead of const; let is definitely more like var than const. That's especially true since they had already chosen consistency with var for the whole hoisting-to-the-top-of-the-scope thing. Let const be its own unique deal with a TDZ, and let the answer to TDZ purely be: just avoid the TDZ by always declaring your constants at the top of the scope. I think this would have been more reasonable.\n\nBut alas, that's not how it landed. let has a TDZ because const needs a TDZ, because let and const mimic var in their hoisting to the top of the (block) scope. There ya go. Too circular? Read it again a few times."}, "id": 261}]}, {"data": {"uuid": "dc16df60-3924-47bc-b240-1105f73457b4", "user": 1, "title": "Are Synchronous Callbacks Still Closures?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:08:16.344890+00:00", "updated_on": "2023-06-09 02:08:32.357110+00:00", "article_html": "<h2>Are Synchronous Callbacks Still Closures?</h2><p>Chapter 7 presented two different models for tackling closure:</p><ul><li><p>Closure is a function instance remembering its outer variables even as that function is passed around and <strong>invoked in</strong> other scopes.</p></li><li><p>Closure is a function instance and its scope environment being preserved in-place while any references to it are passed around and <strong>invoked from</strong> other scopes.</p></li></ul><p>These models are not wildly divergent, but they do approach from a different perspective. And that different perspective changes what we identify as a closure.</p><p>Don't get lost following this rabbit trail through closures and callbacks:</p><ul><li><p>Calling back to what (or where)?</p></li><li><p>Maybe \"synchronous callback\" isn't the best label</p></li><li><p><strong><em>IIF</em></strong> functions don't move around, why would they need closure?</p></li><li><p>Deferring over time is key to closure</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Are Synchronous Callbacks Still Closures?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Chapter 7 presented two different models for tackling closure:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure is a function instance remembering its outer variables even as that function is passed around and ", "type": "text"}, {"text": "invoked in", "type": "text", "marks": [{"type": "bold"}]}, {"text": " other scopes.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure is a function instance and its scope environment being preserved in-place while any references to it are passed around and ", "type": "text"}, {"text": "invoked from", "type": "text", "marks": [{"type": "bold"}]}, {"text": " other scopes.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "These models are not wildly divergent, but they do approach from a different perspective. And that different perspective changes what we identify as a closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't get lost following this rabbit trail through closures and callbacks:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Calling back to what (or where)?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Maybe \"synchronous callback\" isn't the best label", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "IIF", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": " functions don't move around, why would they need closure?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Deferring over time is key to closure", "type": "text"}]}]}]}]}, "article_text": "Are Synchronous Callbacks Still Closures?\n\nChapter 7 presented two different models for tackling closure:\n\nClosure is a function instance remembering its outer variables even as that function is passed around and invoked in other scopes.\n\nClosure is a function instance and its scope environment being preserved in-place while any references to it are passed around and invoked from other scopes.\n\nThese models are not wildly divergent, but they do approach from a different perspective. And that different perspective changes what we identify as a closure.\n\nDon't get lost following this rabbit trail through closures and callbacks:\n\nCalling back to what (or where)?\n\nMaybe \"synchronous callback\" isn't the best label\n\nIIF functions don't move around, why would they need closure?\n\nDeferring over time is key to closure"}, "id": 262, "children": [{"data": {"uuid": "4de0dd7a-10d3-46c7-9bd9-8be8151ee2d8", "user": 1, "title": "What is a Callback?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:10:48.058015+00:00", "updated_on": "2023-06-09 02:11:06.495392+00:00", "article_html": "<h3>What is a Callback?</h3><p>Before we revisit closure, let me spend a brief moment addressing the word \"callback.\" It's a generally accepted norm that saying \"callback\" is synonymous with both <em>asynchronous callbacks</em> and <em>synchronous callbacks</em>. I don't think I agree that this is a good idea, so I want to explain why and propose we move away from that to another term.</p><p>Let's first consider an <em>asynchronous callback</em>, a function reference that will be invoked at some future <em>later</em> point. What does \"callback\" mean, in this case?</p><p>It means that the current code has finished or paused, suspended itself, and that when the function in question is invoked later, execution is entering back into the suspended program, resuming it. Specifically, the point of re-entry is the code that was wrapped in the function reference:</p><pre><code>setTimeout(function waitForASecond(){\n    // this is where JS should call back into\n    // the program when the timer has elapsed\n},1000);\n\n// this is where the current program finishes\n// or suspends</code></pre><p>In this context, \"calling back\" makes a lot of sense. The JS engine is resuming our suspended program by <em>calling back in</em> at a specific location. OK, so a callback is asynchronous.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "What is a Callback?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Before we revisit closure, let me spend a brief moment addressing the word \"callback.\" It's a generally accepted norm that saying \"callback\" is synonymous with both ", "type": "text"}, {"text": "asynchronous callbacks", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "synchronous callbacks", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". I don't think I agree that this is a good idea, so I want to explain why and propose we move away from that to another term.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's first consider an ", "type": "text"}, {"text": "asynchronous callback", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", a function reference that will be invoked at some future ", "type": "text"}, {"text": "later", "type": "text", "marks": [{"type": "italic"}]}, {"text": " point. What does \"callback\" mean, in this case?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It means that the current code has finished or paused, suspended itself, and that when the function in question is invoked later, execution is entering back into the suspended program, resuming it. Specifically, the point of re-entry is the code that was wrapped in the function reference:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "setTimeout(function waitForASecond(){\n    // this is where JS should call back into\n    // the program when the timer has elapsed\n},1000);\n\n// this is where the current program finishes\n// or suspends", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this context, \"calling back\" makes a lot of sense. The JS engine is resuming our suspended program by ", "type": "text"}, {"text": "calling back in", "type": "text", "marks": [{"type": "italic"}]}, {"text": " at a specific location. OK, so a callback is asynchronous.", "type": "text"}]}]}, "article_text": "What is a Callback?\n\nBefore we revisit closure, let me spend a brief moment addressing the word \"callback.\" It's a generally accepted norm that saying \"callback\" is synonymous with both asynchronous callbacks and synchronous callbacks. I don't think I agree that this is a good idea, so I want to explain why and propose we move away from that to another term.\n\nLet's first consider an asynchronous callback, a function reference that will be invoked at some future later point. What does \"callback\" mean, in this case?\n\nIt means that the current code has finished or paused, suspended itself, and that when the function in question is invoked later, execution is entering back into the suspended program, resuming it. Specifically, the point of re-entry is the code that was wrapped in the function reference:\n\nsetTimeout(function waitForASecond(){\n    // this is where JS should call back into\n    // the program when the timer has elapsed\n},1000);\n\n// this is where the current program finishes\n// or suspends\n\nIn this context, \"calling back\" makes a lot of sense. The JS engine is resuming our suspended program by calling back in at a specific location. OK, so a callback is asynchronous."}, "id": 263}, {"data": {"uuid": "0488fbc5-0c39-4b94-8c5c-3cc291dfb91a", "user": 1, "title": "Synchronous Callback?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:11:26.890868+00:00", "updated_on": "2023-06-09 02:12:15.739782+00:00", "article_html": "<h3>Synchronous Callback?</h3><p>But what about <em>synchronous callbacks</em>? Consider:</p><pre><code>function getLabels(studentIDs) {\n    return studentIDs.map(\n        function formatIDLabel(id){\n            return `Student ID: ${\n               String(id).padStart(6)\n            }`;\n        }\n    );\n}\n\ngetLabels([ 14, 73, 112, 6 ]);\n// [\n//    \"Student ID: 000014\",\n//    \"Student ID: 000073\",\n//    \"Student ID: 000112\",\n//    \"Student ID: 000006\"\n// ]</code></pre><p>Should we refer to <code>formatIDLabel(..)</code> as a callback? Is the <code>map(..)</code> utility really <em>calling back</em> into our program by invoking the function we provided?</p><p>There's nothing to <em>call back into</em> per se, because the program hasn't paused or exited. We're passing a function (reference) from one part of the program to another part of the program, and then it's immediately invoked.</p><p>There's other established terms that might match what we're doing\u2014passing in a function (reference) so that another part of the program can invoke it on our behalf. You might think of this as <em>Dependency Injection</em> (DI) or <em>Inversion of Control</em> (IoC).</p><p>DI can be summarized as passing in necessary part(s) of functionality to another part of the program so that it can invoke them to complete its work. That's a decent description for the <code>map(..)</code> call above, isn't it? The <code>map(..)</code> utility knows to iterate over the list's values, but it doesn't know what to <em>do</em> with those values. That's why we pass it the <code>formatIDLabel(..)</code> function. We pass in the dependency.</p><p>IoC is a pretty similar, related concept. Inversion of control means that instead of the current area of your program controlling what's happening, you hand control off to another part of the program. We wrapped the logic for computing a label string in the function <code>formatIDLabel(..)</code>, then handed invocation control to the <code>map(..)</code> utility.</p><p>Notably, Martin Fowler cites IoC as the difference between a framework and a library: with a library, you call its functions; with a framework, it calls your functions.<sup>[1]</sup> </p><p>In the context of our discussion, either DI or IoC could work as an alternative label for a <em>synchronous callback</em>.</p><p>But I have a different suggestion. Let's refer to (the functions formerly known as) <em>synchronous callbacks</em>, as <em>inter-invoked functions</em> (IIFs). Yes, exactly, I'm playing off IIFEs. These kinds of functions are <em>inter-invoked</em>, meaning: another entity invokes them, as opposed to IIFEs, which invoke themselves immediately.</p><p>What's the relationship between an <em>asynchronous callback</em> and an IIF? An <em>asynchronous callback</em> is an IIF that's invoked asynchronously instead of synchronously.</p><p><sup>[1]</sup> <em>Inversion of Control</em>, Martin Fowler, <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://martinfowler.com/bliki/InversionOfControl.html\">https://martinfowler.com/bliki/InversionOfControl.html</a>, 26 June 2005. </p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Synchronous Callback?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But what about ", "type": "text"}, {"text": "synchronous callbacks", "type": "text", "marks": [{"type": "italic"}]}, {"text": "? Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getLabels(studentIDs) {\n    return studentIDs.map(\n        function formatIDLabel(id){\n            return `Student ID: ${\n               String(id).padStart(6)\n            }`;\n        }\n    );\n}\n\ngetLabels([ 14, 73, 112, 6 ]);\n// [\n//    \"Student ID: 000014\",\n//    \"Student ID: 000073\",\n//    \"Student ID: 000112\",\n//    \"Student ID: 000006\"\n// ]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Should we refer to ", "type": "text"}, {"text": "formatIDLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a callback? Is the ", "type": "text"}, {"text": "map(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility really ", "type": "text"}, {"text": "calling back", "type": "text", "marks": [{"type": "italic"}]}, {"text": " into our program by invoking the function we provided?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's nothing to ", "type": "text"}, {"text": "call back into", "type": "text", "marks": [{"type": "italic"}]}, {"text": " per se, because the program hasn't paused or exited. We're passing a function (reference) from one part of the program to another part of the program, and then it's immediately invoked.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's other established terms that might match what we're doing\u2014passing in a function (reference) so that another part of the program can invoke it on our behalf. You might think of this as ", "type": "text"}, {"text": "Dependency Injection", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (DI) or ", "type": "text"}, {"text": "Inversion of Control", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (IoC).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "DI can be summarized as passing in necessary part(s) of functionality to another part of the program so that it can invoke them to complete its work. That's a decent description for the ", "type": "text"}, {"text": "map(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call above, isn't it? The ", "type": "text"}, {"text": "map(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility knows to iterate over the list's values, but it doesn't know what to ", "type": "text"}, {"text": "do", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with those values. That's why we pass it the ", "type": "text"}, {"text": "formatIDLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function. We pass in the dependency.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "IoC is a pretty similar, related concept. Inversion of control means that instead of the current area of your program controlling what's happening, you hand control off to another part of the program. We wrapped the logic for computing a label string in the function ", "type": "text"}, {"text": "formatIDLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", then handed invocation control to the ", "type": "text"}, {"text": "map(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notably, Martin Fowler cites IoC as the difference between a framework and a library: with a library, you call its functions; with a framework, it calls your functions.", "type": "text"}, {"text": "[1]", "type": "text", "marks": [{"type": "superscript"}]}, {"text": " ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the context of our discussion, either DI or IoC could work as an alternative label for a ", "type": "text"}, {"text": "synchronous callback", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I have a different suggestion. Let's refer to (the functions formerly known as) ", "type": "text"}, {"text": "synchronous callbacks", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", as ", "type": "text"}, {"text": "inter-invoked functions", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (IIFs). Yes, exactly, I'm playing off IIFEs. These kinds of functions are ", "type": "text"}, {"text": "inter-invoked", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", meaning: another entity invokes them, as opposed to IIFEs, which invoke themselves immediately.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What's the relationship between an ", "type": "text"}, {"text": "asynchronous callback", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and an IIF? An ", "type": "text"}, {"text": "asynchronous callback", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is an IIF that's invoked asynchronously instead of synchronously.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "[1]", "type": "text", "marks": [{"type": "superscript"}]}, {"text": " ", "type": "text"}, {"text": "Inversion of Control", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", Martin Fowler, ", "type": "text"}, {"text": "https://martinfowler.com/bliki/InversionOfControl.html", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://martinfowler.com/bliki/InversionOfControl.html", "class": null, "target": "_blank"}}]}, {"text": ", 26 June 2005. ", "type": "text"}]}]}, "article_text": "Synchronous Callback?\n\nBut what about synchronous callbacks? Consider:\n\nfunction getLabels(studentIDs) {\n    return studentIDs.map(\n        function formatIDLabel(id){\n            return `Student ID: ${\n               String(id).padStart(6)\n            }`;\n        }\n    );\n}\n\ngetLabels([ 14, 73, 112, 6 ]);\n// [\n//    \"Student ID: 000014\",\n//    \"Student ID: 000073\",\n//    \"Student ID: 000112\",\n//    \"Student ID: 000006\"\n// ]\n\nShould we refer to formatIDLabel(..) as a callback? Is the map(..) utility really calling back into our program by invoking the function we provided?\n\nThere's nothing to call back into per se, because the program hasn't paused or exited. We're passing a function (reference) from one part of the program to another part of the program, and then it's immediately invoked.\n\nThere's other established terms that might match what we're doing\u2014passing in a function (reference) so that another part of the program can invoke it on our behalf. You might think of this as Dependency Injection (DI) or Inversion of Control (IoC).\n\nDI can be summarized as passing in necessary part(s) of functionality to another part of the program so that it can invoke them to complete its work. That's a decent description for the map(..) call above, isn't it? The map(..) utility knows to iterate over the list's values, but it doesn't know what to do with those values. That's why we pass it the formatIDLabel(..) function. We pass in the dependency.\n\nIoC is a pretty similar, related concept. Inversion of control means that instead of the current area of your program controlling what's happening, you hand control off to another part of the program. We wrapped the logic for computing a label string in the function formatIDLabel(..), then handed invocation control to the map(..) utility.\n\nNotably, Martin Fowler cites IoC as the difference between a framework and a library: with a library, you call its functions; with a framework, it calls your functions.[1] \n\nIn the context of our discussion, either DI or IoC could work as an alternative label for a synchronous callback.\n\nBut I have a different suggestion. Let's refer to (the functions formerly known as) synchronous callbacks, as inter-invoked functions (IIFs). Yes, exactly, I'm playing off IIFEs. These kinds of functions are inter-invoked, meaning: another entity invokes them, as opposed to IIFEs, which invoke themselves immediately.\n\nWhat's the relationship between an asynchronous callback and an IIF? An asynchronous callback is an IIF that's invoked asynchronously instead of synchronously.\n\n[1] Inversion of Control, Martin Fowler, https://martinfowler.com/bliki/InversionOfControl.html, 26 June 2005."}, "id": 264}, {"data": {"uuid": "f737256a-3286-4320-9458-3f139252949e", "user": 1, "title": "Synchronous Closure?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:12:47.353544+00:00", "updated_on": "2023-06-09 02:13:03.816210+00:00", "article_html": "<h3>Synchronous Closure?</h3><p>Now that we've re-labeled <em>synchronous callbacks</em> as IIFs, we can return to our main question: are IIFs an example of closure? Obviously, the IIF would have to reference variable(s) from an outer scope for it to have any chance of being a closure. The <code>formatIDLabel(..)</code> IIF from earlier does not reference any variables outside its own scope, so it's definitely not a closure.</p><p>What about an IIF that does have external references, is that closure?</p><pre><code>function printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n\n    labels.forEach(\n        function renderLabel(label){\n            var li = document.createElement(\"li\");\n            li.innerText = label;\n            list.appendChild(li);\n        }\n    );\n}</code></pre><p>The inner <code>renderLabel(..)</code> IIF references <code>list</code> from the enclosing scope, so it's an IIF that <em>could</em> have closure. But here's where the definition/model we choose for closure matters:</p><ul><li><p>If <code>renderLabel(..)</code> is a <strong>function that gets passed somewhere else</strong>, and that function is then invoked, then yes, <code>renderLabel(..)</code> is exercising a closure, because closure is what preserved its access to its original scope chain.</p></li><li><p>But if, as in the alternative conceptual model from Chapter 7, <code>renderLabel(..)</code> stays in place, and only a reference to it is passed to <code>forEach(..)</code>, is there any need for closure to preserve the scope chain of <code>renderLabel(..)</code>, while it executes synchronously right inside its own scope?</p></li></ul><p>No. That's just normal lexical scope.</p><p>To understand why, consider this alternative form of <code>printLabels(..)</code>:</p><pre><code>function printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n\n    for (let label of labels) {\n        // just a normal function call in its own\n        // scope, right? That's not really closure!\n        renderLabel(label);\n    }\n\n    // **************\n\n    function renderLabel(label) {\n        var li = document.createElement(\"li\");\n        li.innerText = label;\n        list.appendChild(li);\n    }\n}</code></pre><p>These two versions of <code>printLabels(..)</code> are essentially the same.</p><p>The latter one is definitely not an example of closure, at least not in any useful or observable sense. It's just lexical scope. The former version, with <code>forEach(..)</code> calling our function reference, is essentially the same thing. It's also not closure, but rather just a plain ol' lexical scope function call.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Synchronous Closure?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now that we've re-labeled ", "type": "text"}, {"text": "synchronous callbacks", "type": "text", "marks": [{"type": "italic"}]}, {"text": " as IIFs, we can return to our main question: are IIFs an example of closure? Obviously, the IIF would have to reference variable(s) from an outer scope for it to have any chance of being a closure. The ", "type": "text"}, {"text": "formatIDLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " IIF from earlier does not reference any variables outside its own scope, so it's definitely not a closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What about an IIF that does have external references, is that closure?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n\n    labels.forEach(\n        function renderLabel(label){\n            var li = document.createElement(\"li\");\n            li.innerText = label;\n            list.appendChild(li);\n        }\n    );\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The inner ", "type": "text"}, {"text": "renderLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " IIF references ", "type": "text"}, {"text": "list", "type": "text", "marks": [{"type": "code"}]}, {"text": " from the enclosing scope, so it's an IIF that ", "type": "text"}, {"text": "could", "type": "text", "marks": [{"type": "italic"}]}, {"text": " have closure. But here's where the definition/model we choose for closure matters:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "If ", "type": "text"}, {"text": "renderLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a ", "type": "text"}, {"text": "function that gets passed somewhere else", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", and that function is then invoked, then yes, ", "type": "text"}, {"text": "renderLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is exercising a closure, because closure is what preserved its access to its original scope chain.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "But if, as in the alternative conceptual model from Chapter 7, ", "type": "text"}, {"text": "renderLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " stays in place, and only a reference to it is passed to ", "type": "text"}, {"text": "forEach(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", is there any need for closure to preserve the scope chain of ", "type": "text"}, {"text": "renderLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", while it executes synchronously right inside its own scope?", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "No. That's just normal lexical scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To understand why, consider this alternative form of ", "type": "text"}, {"text": "printLabels(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n\n    for (let label of labels) {\n        // just a normal function call in its own\n        // scope, right? That's not really closure!\n        renderLabel(label);\n    }\n\n    // **************\n\n    function renderLabel(label) {\n        var li = document.createElement(\"li\");\n        li.innerText = label;\n        list.appendChild(li);\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These two versions of ", "type": "text"}, {"text": "printLabels(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " are essentially the same.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The latter one is definitely not an example of closure, at least not in any useful or observable sense. It's just lexical scope. The former version, with ", "type": "text"}, {"text": "forEach(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " calling our function reference, is essentially the same thing. It's also not closure, but rather just a plain ol' lexical scope function call.", "type": "text"}]}]}, "article_text": "Synchronous Closure?\n\nNow that we've re-labeled synchronous callbacks as IIFs, we can return to our main question: are IIFs an example of closure? Obviously, the IIF would have to reference variable(s) from an outer scope for it to have any chance of being a closure. The formatIDLabel(..) IIF from earlier does not reference any variables outside its own scope, so it's definitely not a closure.\n\nWhat about an IIF that does have external references, is that closure?\n\nfunction printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n\n    labels.forEach(\n        function renderLabel(label){\n            var li = document.createElement(\"li\");\n            li.innerText = label;\n            list.appendChild(li);\n        }\n    );\n}\n\nThe inner renderLabel(..) IIF references list from the enclosing scope, so it's an IIF that could have closure. But here's where the definition/model we choose for closure matters:\n\nIf renderLabel(..) is a function that gets passed somewhere else, and that function is then invoked, then yes, renderLabel(..) is exercising a closure, because closure is what preserved its access to its original scope chain.\n\nBut if, as in the alternative conceptual model from Chapter 7, renderLabel(..) stays in place, and only a reference to it is passed to forEach(..), is there any need for closure to preserve the scope chain of renderLabel(..), while it executes synchronously right inside its own scope?\n\nNo. That's just normal lexical scope.\n\nTo understand why, consider this alternative form of printLabels(..):\n\nfunction printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n\n    for (let label of labels) {\n        // just a normal function call in its own\n        // scope, right? That's not really closure!\n        renderLabel(label);\n    }\n\n    // **************\n\n    function renderLabel(label) {\n        var li = document.createElement(\"li\");\n        li.innerText = label;\n        list.appendChild(li);\n    }\n}\n\nThese two versions of printLabels(..) are essentially the same.\n\nThe latter one is definitely not an example of closure, at least not in any useful or observable sense. It's just lexical scope. The former version, with forEach(..) calling our function reference, is essentially the same thing. It's also not closure, but rather just a plain ol' lexical scope function call."}, "id": 265}, {"data": {"uuid": "e35d5b3f-5b77-47bf-82a1-f8d751cd1887", "user": 1, "title": "Defer to Closure", "author": "Kyle Simpson", "created_on": "2023-06-09 02:13:22.647802+00:00", "updated_on": "2023-06-09 02:13:46.167659+00:00", "article_html": "<h3>Defer to Closure</h3><p>By the way, Chapter 7 briefly mentioned partial application and currying (which <em>do</em> rely on closure!). This is an interesting scenario where manual currying can be used:</p><pre><code>function printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n    var renderLabel = renderTo(list);\n\n    // definitely closure this time!\n    labels.forEach( renderLabel );\n\n    // **************\n\n    function renderTo(list) {\n        return function createLabel(label){\n            var li = document.createElement(\"li\");\n            li.innerText = label;\n            list.appendChild(li);\n        };\n    }\n}</code></pre><p>The inner function <code>createLabel(..)</code>, which we assign to <code>renderLabel</code>, is closed over <code>list</code>, so closure is definitely being utilized.</p><p>Closure allows us to remember <code>list</code> for later, while we defer execution of the actual label-creation logic from the <code>renderTo(..)</code> call to the subsequent <code>forEach(..)</code> invocations of the <code>createLabel(..)</code> IIF. That may only be a brief moment here, but any amount of time could pass, as closure bridges from call to call.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Defer to Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By the way, Chapter 7 briefly mentioned partial application and currying (which ", "type": "text"}, {"text": "do", "type": "text", "marks": [{"type": "italic"}]}, {"text": " rely on closure!). This is an interesting scenario where manual currying can be used:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n    var renderLabel = renderTo(list);\n\n    // definitely closure this time!\n    labels.forEach( renderLabel );\n\n    // **************\n\n    function renderTo(list) {\n        return function createLabel(label){\n            var li = document.createElement(\"li\");\n            li.innerText = label;\n            list.appendChild(li);\n        };\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The inner function ", "type": "text"}, {"text": "createLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which we assign to ", "type": "text"}, {"text": "renderLabel", "type": "text", "marks": [{"type": "code"}]}, {"text": ", is closed over ", "type": "text"}, {"text": "list", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so closure is definitely being utilized.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure allows us to remember ", "type": "text"}, {"text": "list", "type": "text", "marks": [{"type": "code"}]}, {"text": " for later, while we defer execution of the actual label-creation logic from the ", "type": "text"}, {"text": "renderTo(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call to the subsequent ", "type": "text"}, {"text": "forEach(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " invocations of the ", "type": "text"}, {"text": "createLabel(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " IIF. That may only be a brief moment here, but any amount of time could pass, as closure bridges from call to call.", "type": "text"}]}]}, "article_text": "Defer to Closure\n\nBy the way, Chapter 7 briefly mentioned partial application and currying (which do rely on closure!). This is an interesting scenario where manual currying can be used:\n\nfunction printLabels(labels) {\n    var list = document.getElementById(\"labelsList\");\n    var renderLabel = renderTo(list);\n\n    // definitely closure this time!\n    labels.forEach( renderLabel );\n\n    // **************\n\n    function renderTo(list) {\n        return function createLabel(label){\n            var li = document.createElement(\"li\");\n            li.innerText = label;\n            list.appendChild(li);\n        };\n    }\n}\n\nThe inner function createLabel(..), which we assign to renderLabel, is closed over list, so closure is definitely being utilized.\n\nClosure allows us to remember list for later, while we defer execution of the actual label-creation logic from the renderTo(..) call to the subsequent forEach(..) invocations of the createLabel(..) IIF. That may only be a brief moment here, but any amount of time could pass, as closure bridges from call to call."}, "id": 266}]}, {"data": {"uuid": "922072a6-44ca-4c56-a254-c8a9693d5c1c", "user": 1, "title": "Classic Module Variations", "author": "Kyle Simpson", "created_on": "2023-06-09 02:14:03.113952+00:00", "updated_on": "2023-06-09 02:14:29.518999+00:00", "article_html": "<h2>Classic Module Variations</h2><p>Chapter 8 explained the classic module pattern, which can look like this:</p><pre><code>var StudentList = (function defineModule(Student){\n    var elems = [];\n\n    var publicAPI = {\n        renderList() {\n            // ..\n        }\n    };\n\n    return publicAPI;\n\n})(Student);</code></pre><p>Notice that we're passing <code>Student</code> (another module instance) in as a dependency. But there's lots of useful variations on this module form you may encounter. Some hints for recognizing these variations:</p><ul><li><p>Does the module know about its own API?</p></li><li><p>Even if we use a fancy module loader, it's just a classic module</p></li><li><p>Some modules need to work universally</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Classic Module Variations", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Chapter 8 explained the classic module pattern, which can look like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var StudentList = (function defineModule(Student){\n    var elems = [];\n\n    var publicAPI = {\n        renderList() {\n            // ..\n        }\n    };\n\n    return publicAPI;\n\n})(Student);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice that we're passing ", "type": "text"}, {"text": "Student", "type": "text", "marks": [{"type": "code"}]}, {"text": " (another module instance) in as a dependency. But there's lots of useful variations on this module form you may encounter. Some hints for recognizing these variations:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Does the module know about its own API?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Even if we use a fancy module loader, it's just a classic module", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Some modules need to work universally", "type": "text"}]}]}]}]}, "article_text": "Classic Module Variations\n\nChapter 8 explained the classic module pattern, which can look like this:\n\nvar StudentList = (function defineModule(Student){\n    var elems = [];\n\n    var publicAPI = {\n        renderList() {\n            // ..\n        }\n    };\n\n    return publicAPI;\n\n})(Student);\n\nNotice that we're passing Student (another module instance) in as a dependency. But there's lots of useful variations on this module form you may encounter. Some hints for recognizing these variations:\n\nDoes the module know about its own API?\n\nEven if we use a fancy module loader, it's just a classic module\n\nSome modules need to work universally"}, "id": 267, "children": [{"data": {"uuid": "dee8ebda-1714-48ab-9925-e0521a2c5418", "user": 1, "title": "Where's My API?", "author": "Kyle Simpson", "created_on": "2023-06-09 02:14:47.498190+00:00", "updated_on": "2023-06-09 02:15:04.267507+00:00", "article_html": "<h3>Where's My API?</h3><p>First, most classic modules don't define and use a <code>publicAPI</code> the way I have shown in this code. Instead, they typically look like:</p><pre><code>var StudentList = (function defineModule(Student){\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n\n})(Student);</code></pre><p>The only difference here is directly returning the object that serves as the public API for the module, as opposed to first saving it to an inner <code>publicAPI</code> variable. This is by far how most classic modules are defined.</p><p>But I strongly prefer, and always use myself, the former <code>publicAPI</code> form. Two reasons:</p><ul><li><p><code>publicAPI</code> is a semantic descriptor that aids readability by making it more obvious what the purpose of the object is.</p></li><li><p>Storing an inner <code>publicAPI</code> variable that references the same external public API object returned, can be useful if you need to access or modify the API during the lifetime of the module.</p><p>For example, you may want to call one of the publicly exposed functions, from inside the module. Or, you may want to add or remove methods depending on certain conditions, or update the value of an exposed property.</p><p>Whatever the case may be, it just seems rather silly to me that we <em>wouldn't</em> maintain a reference to access our own API. Right?</p></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Where's My API?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First, most classic modules don't define and use a ", "type": "text"}, {"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": " the way I have shown in this code. Instead, they typically look like:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var StudentList = (function defineModule(Student){\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n\n})(Student);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The only difference here is directly returning the object that serves as the public API for the module, as opposed to first saving it to an inner ", "type": "text"}, {"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable. This is by far how most classic modules are defined.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I strongly prefer, and always use myself, the former ", "type": "text"}, {"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": " form. Two reasons:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a semantic descriptor that aids readability by making it more obvious what the purpose of the object is.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Storing an inner ", "type": "text"}, {"text": "publicAPI", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable that references the same external public API object returned, can be useful if you need to access or modify the API during the lifetime of the module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, you may want to call one of the publicly exposed functions, from inside the module. Or, you may want to add or remove methods depending on certain conditions, or update the value of an exposed property.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Whatever the case may be, it just seems rather silly to me that we ", "type": "text"}, {"text": "wouldn't", "type": "text", "marks": [{"type": "italic"}]}, {"text": " maintain a reference to access our own API. Right?", "type": "text"}]}]}]}]}, "article_text": "Where's My API?\n\nFirst, most classic modules don't define and use a publicAPI the way I have shown in this code. Instead, they typically look like:\n\nvar StudentList = (function defineModule(Student){\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n\n})(Student);\n\nThe only difference here is directly returning the object that serves as the public API for the module, as opposed to first saving it to an inner publicAPI variable. This is by far how most classic modules are defined.\n\nBut I strongly prefer, and always use myself, the former publicAPI form. Two reasons:\n\npublicAPI is a semantic descriptor that aids readability by making it more obvious what the purpose of the object is.\n\nStoring an inner publicAPI variable that references the same external public API object returned, can be useful if you need to access or modify the API during the lifetime of the module.\n\nFor example, you may want to call one of the publicly exposed functions, from inside the module. Or, you may want to add or remove methods depending on certain conditions, or update the value of an exposed property.\n\nWhatever the case may be, it just seems rather silly to me that we wouldn't maintain a reference to access our own API. Right?"}, "id": 268}, {"data": {"uuid": "8ff15fa0-d0b4-4ab8-b033-6a4e5eaeac5e", "user": 1, "title": "Asynchronous Module Definition (AMD)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:15:33.116959+00:00", "updated_on": "2023-06-09 02:16:08.291056+00:00", "article_html": "<h3>Asynchronous Module Definition (AMD)</h3><p>Another variation on the classic module form is AMD-style modules (popular several years back), such as those supported by the RequireJS utility:</p><pre><code>define([ \"./Student\" ],function StudentList(Student){\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n});</code></pre><p>If you look closely at <code>StudentList(..)</code>, it's a classic module factory function. Inside the machinery of <code>define(..)</code> (provided by RequireJS), the <code>StudentList(..)</code> function is executed, passing to it any other module instances declared as dependencies. The return value is an object representing the public API for the module.</p><p>This is based on exactly the same principles (including how the closure works!) as we explored with classic modules.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Asynchronous Module Definition (AMD)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another variation on the classic module form is AMD-style modules (popular several years back), such as those supported by the RequireJS utility:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "define([ \"./Student\" ],function StudentList(Student){\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n});", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you look closely at ", "type": "text"}, {"text": "StudentList(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it's a classic module factory function. Inside the machinery of ", "type": "text"}, {"text": "define(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (provided by RequireJS), the ", "type": "text"}, {"text": "StudentList(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is executed, passing to it any other module instances declared as dependencies. The return value is an object representing the public API for the module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is based on exactly the same principles (including how the closure works!) as we explored with classic modules.", "type": "text"}]}]}, "article_text": "Asynchronous Module Definition (AMD)\n\nAnother variation on the classic module form is AMD-style modules (popular several years back), such as those supported by the RequireJS utility:\n\ndefine([ \"./Student\" ],function StudentList(Student){\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n});\n\nIf you look closely at StudentList(..), it's a classic module factory function. Inside the machinery of define(..) (provided by RequireJS), the StudentList(..) function is executed, passing to it any other module instances declared as dependencies. The return value is an object representing the public API for the module.\n\nThis is based on exactly the same principles (including how the closure works!) as we explored with classic modules."}, "id": 269}, {"data": {"uuid": "becf8b91-4884-4ac0-a349-60bc7f528e24", "user": 1, "title": "Universal Modules (UMD)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:16:23.307382+00:00", "updated_on": "2023-06-09 02:16:50.588710+00:00", "article_html": "<h3>Universal Modules (UMD)</h3><p>The final variation we'll look at is UMD, which is less a specific, exact format and more a collection of very similar formats. It was designed to create better interop (without any build-tool conversion) for modules that may be loaded in browsers, by AMD-style loaders, or in Node. I personally still publish many of my utility libraries using a form of UMD.</p><p>Here's the typical structure of a UMD:</p><pre><code>(function UMD(name,context,definition){\n    // loaded by an AMD-style loader?\n    if (\n        typeof define === \"function\" &amp;&amp;\n        define.amd\n    ) {\n        define(definition);\n    }\n    // in Node?\n    else if (\n        typeof module !== \"undefined\" &amp;&amp;\n        module.exports\n    ) {\n        module.exports = definition(name,context);\n    }\n    // assume standalone browser script\n    else {\n        context[name] = definition(name,context);\n    }\n})(\"StudentList\",this,function DEF(name,context){\n\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n\n});</code></pre><p>Though it may look a bit unusual, UMD is really just an IIFE.</p><p>What's different is that the main <code>function</code> expression part (at the top) of the IIFE contains a series of <code>if..else if</code> statements to detect which of the three supported environments the module is being loaded in.</p><p>The final <code>()</code> that normally invokes an IIFE is being passed three arguments: <code>\"StudentsList\"</code>, <code>this</code>, and another <code>function</code> expression. If you match those arguments to their parameters, you'll see they are: <code>name</code>, <code>context</code>, and <code>definition</code>, respectively. <code>\"StudentList\"</code> (<code>name</code>) is the name label for the module, primarily in case it's defined as a global variable. <code>this</code> (<code>context</code>) is generally the <code>window</code> (aka, global object; see Chapter 4) for defining the module by its name.</p><p><code>definition(..)</code> is invoked to actually retrieve the definition of the module, and you'll notice that, sure enough, that's just a classic module form!</p><p>There's no question that as of the time of this writing, ESM (ES Modules) are becoming popular and widespread rapidly. But with millions and millions of modules written over the last 20 years, all using some pre-ESM variation of classic modules, they're still very important to be able to read and understand when you come across them.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Universal Modules (UMD)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The final variation we'll look at is UMD, which is less a specific, exact format and more a collection of very similar formats. It was designed to create better interop (without any build-tool conversion) for modules that may be loaded in browsers, by AMD-style loaders, or in Node. I personally still publish many of my utility libraries using a form of UMD.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's the typical structure of a UMD:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "(function UMD(name,context,definition){\n    // loaded by an AMD-style loader?\n    if (\n        typeof define === \"function\" &&\n        define.amd\n    ) {\n        define(definition);\n    }\n    // in Node?\n    else if (\n        typeof module !== \"undefined\" &&\n        module.exports\n    ) {\n        module.exports = definition(name,context);\n    }\n    // assume standalone browser script\n    else {\n        context[name] = definition(name,context);\n    }\n})(\"StudentList\",this,function DEF(name,context){\n\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n\n});", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though it may look a bit unusual, UMD is really just an IIFE.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What's different is that the main ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression part (at the top) of the IIFE contains a series of ", "type": "text"}, {"text": "if..else if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statements to detect which of the three supported environments the module is being loaded in.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The final ", "type": "text"}, {"text": "()", "type": "text", "marks": [{"type": "code"}]}, {"text": " that normally invokes an IIFE is being passed three arguments: ", "type": "text"}, {"text": "\"StudentsList\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and another ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " expression. If you match those arguments to their parameters, you'll see they are: ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "context", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "definition", "type": "text", "marks": [{"type": "code"}]}, {"text": ", respectively. ", "type": "text"}, {"text": "\"StudentList\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " (", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": ") is the name label for the module, primarily in case it's defined as a global variable. ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " (", "type": "text"}, {"text": "context", "type": "text", "marks": [{"type": "code"}]}, {"text": ") is generally the ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " (aka, global object; see Chapter 4) for defining the module by its name.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "definition(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is invoked to actually retrieve the definition of the module, and you'll notice that, sure enough, that's just a classic module form!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's no question that as of the time of this writing, ESM (ES Modules) are becoming popular and widespread rapidly. But with millions and millions of modules written over the last 20 years, all using some pre-ESM variation of classic modules, they're still very important to be able to read and understand when you come across them.", "type": "text"}]}]}, "article_text": "Universal Modules (UMD)\n\nThe final variation we'll look at is UMD, which is less a specific, exact format and more a collection of very similar formats. It was designed to create better interop (without any build-tool conversion) for modules that may be loaded in browsers, by AMD-style loaders, or in Node. I personally still publish many of my utility libraries using a form of UMD.\n\nHere's the typical structure of a UMD:\n\n(function UMD(name,context,definition){\n    // loaded by an AMD-style loader?\n    if (\n        typeof define === \"function\" &&\n        define.amd\n    ) {\n        define(definition);\n    }\n    // in Node?\n    else if (\n        typeof module !== \"undefined\" &&\n        module.exports\n    ) {\n        module.exports = definition(name,context);\n    }\n    // assume standalone browser script\n    else {\n        context[name] = definition(name,context);\n    }\n})(\"StudentList\",this,function DEF(name,context){\n\n    var elems = [];\n\n    return {\n        renderList() {\n            // ..\n        }\n    };\n\n});\n\nThough it may look a bit unusual, UMD is really just an IIFE.\n\nWhat's different is that the main function expression part (at the top) of the IIFE contains a series of if..else if statements to detect which of the three supported environments the module is being loaded in.\n\nThe final () that normally invokes an IIFE is being passed three arguments: \"StudentsList\", this, and another function expression. If you match those arguments to their parameters, you'll see they are: name, context, and definition, respectively. \"StudentList\" (name) is the name label for the module, primarily in case it's defined as a global variable. this (context) is generally the window (aka, global object; see Chapter 4) for defining the module by its name.\n\ndefinition(..) is invoked to actually retrieve the definition of the module, and you'll notice that, sure enough, that's just a classic module form!\n\nThere's no question that as of the time of this writing, ESM (ES Modules) are becoming popular and widespread rapidly. But with millions and millions of modules written over the last 20 years, all using some pre-ESM variation of classic modules, they're still very important to be able to read and understand when you come across them."}, "id": 270}]}]}, {"data": {"uuid": "31e31128-eca3-40fe-b529-3b63ee6da655", "user": 1, "title": "Appendix B: Practice", "author": "Kyle Simpson", "created_on": "2023-06-09 02:17:19.207523+00:00", "updated_on": "2023-06-09 02:17:34.943909+00:00", "article_html": "<h1>Appendix B: Practice</h1><p>This appendix aims to give you some challenging and interesting exercises to test and solidify your understanding of the main topics from this book. It's a good idea to try out the exercises yourself\u2014in an actual code editor!\u2014instead of skipping straight to the solutions at the end. No cheating!</p><p>These exercises don't have a specific right answer that you have to get exactly. Your approach may differ some (or a lot!) from the solutions presented, and that's OK.</p><p>There's no judging you on how you write your code. My hope is that you come away from this book feeling confident that you can tackle these sorts of coding tasks built on a strong foundation of knowledge. That's the only objective, here. If you're happy with your code, I am, too!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Appendix B: Practice", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This appendix aims to give you some challenging and interesting exercises to test and solidify your understanding of the main topics from this book. It's a good idea to try out the exercises yourself\u2014in an actual code editor!\u2014instead of skipping straight to the solutions at the end. No cheating!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These exercises don't have a specific right answer that you have to get exactly. Your approach may differ some (or a lot!) from the solutions presented, and that's OK.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's no judging you on how you write your code. My hope is that you come away from this book feeling confident that you can tackle these sorts of coding tasks built on a strong foundation of knowledge. That's the only objective, here. If you're happy with your code, I am, too!", "type": "text"}]}]}, "article_text": "Appendix B: Practice\n\nThis appendix aims to give you some challenging and interesting exercises to test and solidify your understanding of the main topics from this book. It's a good idea to try out the exercises yourself\u2014in an actual code editor!\u2014instead of skipping straight to the solutions at the end. No cheating!\n\nThese exercises don't have a specific right answer that you have to get exactly. Your approach may differ some (or a lot!) from the solutions presented, and that's OK.\n\nThere's no judging you on how you write your code. My hope is that you come away from this book feeling confident that you can tackle these sorts of coding tasks built on a strong foundation of knowledge. That's the only objective, here. If you're happy with your code, I am, too!"}, "id": 271, "children": [{"data": {"uuid": "d79a7f1b-d1c3-4fc7-84ad-ad829dd0ae14", "user": 1, "title": "Buckets of Marbles", "author": "Kyle Simpson", "created_on": "2023-06-09 02:18:19.155627+00:00", "updated_on": "2023-06-09 02:18:48.028138+00:00", "article_html": "<h2>Buckets of Marbles</h2><p>Remember Figure 2 from back in Chapter 2?</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig2.png\"><p><em>Fig. 2 (Ch. 2): Colored Scope Bubbles</em></p><p>This exercise asks you to write a program\u2014any program!\u2014that contains nested functions and block scopes, which satisfies these constraints:</p><ul><li><p>If you color all the scopes (including the global scope!) different colors, you need at least six colors. Make sure to add a code comment labeling each scope with its color.</p><p>BONUS: identify any implied scopes your code may have.</p></li><li><p>Each scope has at least one identifier.</p></li><li><p>Contains at least two function scopes and at least two block scopes.</p></li><li><p>At least one variable from an outer scope must be shadowed by a nested scope variable (see Chapter 3).</p></li><li><p>At least one variable reference must resolve to a variable declaration at least two levels higher in the scope chain.</p></li></ul><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>You <em>can</em> just write junk foo/bar/baz-type code for this exercise, but I suggest you try to come up with some sort of non-trivial real'ish code that at least does something kind of reasonable.</p></td></tr></tbody></table><p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Buckets of Marbles", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember Figure 2 from back in Chapter 2?", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/scope-closures/images/fig2.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 2 (Ch. 2): Colored Scope Bubbles", "type": "text", "marks": [{"type": "italic"}]}]}, {"type": "paragraph", "content": [{"text": "This exercise asks you to write a program\u2014any program!\u2014that contains nested functions and block scopes, which satisfies these constraints:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "If you color all the scopes (including the global scope!) different colors, you need at least six colors. Make sure to add a code comment labeling each scope with its color.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "BONUS: identify any implied scopes your code may have.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Each scope has at least one identifier.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Contains at least two function scopes and at least two block scopes.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "At least one variable from an outer scope must be shadowed by a nested scope variable (see Chapter 3).", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "At least one variable reference must resolve to a variable declaration at least two levels higher in the scope chain.", "type": "text"}]}]}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "You ", "type": "text"}, {"text": "can", "type": "text", "marks": [{"type": "italic"}]}, {"text": " just write junk foo/bar/baz-type code for this exercise, but I suggest you try to come up with some sort of non-trivial real'ish code that at least does something kind of reasonable.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Try the exercise for yourself, then check out the suggested solution at the end of this appendix.", "type": "text"}]}]}, "article_text": "Buckets of Marbles\n\nRemember Figure 2 from back in Chapter 2?\n\nFig. 2 (Ch. 2): Colored Scope Bubbles\n\nThis exercise asks you to write a program\u2014any program!\u2014that contains nested functions and block scopes, which satisfies these constraints:\n\nIf you color all the scopes (including the global scope!) different colors, you need at least six colors. Make sure to add a code comment labeling each scope with its color.\n\nBONUS: identify any implied scopes your code may have.\n\nEach scope has at least one identifier.\n\nContains at least two function scopes and at least two block scopes.\n\nAt least one variable from an outer scope must be shadowed by a nested scope variable (see Chapter 3).\n\nAt least one variable reference must resolve to a variable declaration at least two levels higher in the scope chain.\n\nTIP:\n\nYou can just write junk foo/bar/baz-type code for this exercise, but I suggest you try to come up with some sort of non-trivial real'ish code that at least does something kind of reasonable.\n\nTry the exercise for yourself, then check out the suggested solution at the end of this appendix."}, "id": 272}, {"data": {"uuid": "8d2e9e1d-3a52-4d72-bf7d-5d58e3fff4b1", "user": 1, "title": "Closure (PART 1)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:19:07.160736+00:00", "updated_on": "2023-06-09 02:19:49.304285+00:00", "article_html": "<h2>Closure (PART 1)</h2><p>Let's first practice closure with some common computer-math operations: determining if a value is prime (has no divisors other than 1 and itself), and generating a list of prime factors (divisors) for a given number.</p><p>For example:</p><pre><code>isPrime(11);        // true\nisPrime(12);        // false\n\nfactorize(11);      // [ 11 ]\nfactorize(12);      // [ 3, 2, 2 ] --&gt; 3*2*2=12</code></pre><p>Here's an implementation of <code>isPrime(..)</code>, adapted from the Math.js library: <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apB.md#user-content-fn-MathJSisPrime-8a944c0a33f0ede2ffb2b9a1ec8e4d8d\"><sup>1</sup></a></p><pre><code>function isPrime(v) {\n    if (v &lt;= 3) {\n        return v &gt; 1;\n    }\n    if (v % 2 == 0 || v % 3 == 0) {\n        return false;\n    }\n    var vSqrt = Math.sqrt(v);\n    for (let i = 5; i &lt;= vSqrt; i += 6) {\n        if (v % i == 0 || v % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}</code></pre><p>And here's a somewhat basic implementation of <code>factorize(..)</code> (not to be confused with <code>factorial(..)</code> from Chapter 6):</p><pre><code>function factorize(v) {\n    if (!isPrime(v)) {\n        let i = Math.floor(Math.sqrt(v));\n        while (v % i != 0) {\n            i--;\n        }\n        return [\n            ...factorize(i),\n            ...factorize(v / i)\n        ];\n    }\n    return [v];\n}</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>I call this basic because it's not optimized for performance. It's binary-recursive (which isn't tail-call optimizable), and it creates a lot of intermediate array copies. It also doesn't order the discovered factors in any way. There are many, many other algorithms for this task, but I wanted to use something short and roughly understandable for our exercise.</p></td></tr></tbody></table><p>If you were to call <code>isPrime(4327)</code> multiple times in a program, you can see that it would go through all its dozens of comparison/computation steps every time. If you consider <code>factorize(..)</code>, it's calling <code>isPrime(..)</code> many times as it computes the list of factors. And there's a good chance most of those calls are repeats. That's a lot of wasted work!</p><p>The first part of this exercise is to use closure to implement a cache to remember the results of <code>isPrime(..)</code>, so that the primality (<code>true</code> or <code>false</code>) of a given number is only ever computed once. Hint: we already showed this sort of caching in Chapter 6 with <code>factorial(..)</code>.</p><p>If you look at <code>factorize(..)</code>, it's implemented with recursion, meaning it calls itself repeatedly. That again means we may likely see a lot of wasted calls to compute prime factors for the same number. So the second part of the exercise is to use the same closure cache technique for <code>factorize(..)</code>.</p><p>Use separate closures for caching of <code>isPrime(..)</code> and <code>factorize(..)</code>, rather than putting them inside a single scope.</p><p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p><h3>A Word About Memory</h3><p>I want to share a little quick note about this closure cache technique and the impacts it has on your application's performance.</p><p>We can see that in saving the repeated calls, we improve computation speed (in some cases, by a dramatic amount). But this usage of closure is making an explicit trade-off that you should be very aware of.</p><p>The trade-off is memory. We're essentially growing our cache (in memory) unboundedly. If the functions in question were called many millions of times with mostly unique inputs, we'd be chewing up a lot of memory. This can definitely be worth the expense, but only if we think it's likely we see repetition of common inputs so that we're taking advantage of the cache.</p><p>If most every call will have a unique input, and the cache is essentially never <em>used</em> to any benefit, this is an inappropriate technique to employ.</p><p>It also might be a good idea to have a more sophisticated caching approach, such as an LRU (least recently used) cache, that limits its size; as it runs up to the limit, an LRU evicts the values that are... well, least recently used!</p><p>The downside here is that LRU is quite non-trivial in its own right. You'll want to use a highly optimized implementation of LRU, and be keenly aware of all the trade-offs at play.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Closure (PART 1)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's first practice closure with some common computer-math operations: determining if a value is prime (has no divisors other than 1 and itself), and generating a list of prime factors (divisors) for a given number.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "isPrime(11);        // true\nisPrime(12);        // false\n\nfactorize(11);      // [ 11 ]\nfactorize(12);      // [ 3, 2, 2 ] --> 3*2*2=12", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's an implementation of ", "type": "text"}, {"text": "isPrime(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", adapted from the Math.js library: ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apB.md#user-content-fn-MathJSisPrime-8a944c0a33f0ede2ffb2b9a1ec8e4d8d", "class": null, "target": "_blank"}}, {"type": "superscript"}]}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function isPrime(v) {\n    if (v <= 3) {\n        return v > 1;\n    }\n    if (v % 2 == 0 || v % 3 == 0) {\n        return false;\n    }\n    var vSqrt = Math.sqrt(v);\n    for (let i = 5; i <= vSqrt; i += 6) {\n        if (v % i == 0 || v % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And here's a somewhat basic implementation of ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (not to be confused with ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " from Chapter 6):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function factorize(v) {\n    if (!isPrime(v)) {\n        let i = Math.floor(Math.sqrt(v));\n        while (v % i != 0) {\n            i--;\n        }\n        return [\n            ...factorize(i),\n            ...factorize(v / i)\n        ];\n    }\n    return [v];\n}", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "I call this basic because it's not optimized for performance. It's binary-recursive (which isn't tail-call optimizable), and it creates a lot of intermediate array copies. It also doesn't order the discovered factors in any way. There are many, many other algorithms for this task, but I wanted to use something short and roughly understandable for our exercise.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "If you were to call ", "type": "text"}, {"text": "isPrime(4327)", "type": "text", "marks": [{"type": "code"}]}, {"text": " multiple times in a program, you can see that it would go through all its dozens of comparison/computation steps every time. If you consider ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it's calling ", "type": "text"}, {"text": "isPrime(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " many times as it computes the list of factors. And there's a good chance most of those calls are repeats. That's a lot of wasted work!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first part of this exercise is to use closure to implement a cache to remember the results of ", "type": "text"}, {"text": "isPrime(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", so that the primality (", "type": "text"}, {"text": "true", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "false", "type": "text", "marks": [{"type": "code"}]}, {"text": ") of a given number is only ever computed once. Hint: we already showed this sort of caching in Chapter 6 with ", "type": "text"}, {"text": "factorial(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you look at ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", it's implemented with recursion, meaning it calls itself repeatedly. That again means we may likely see a lot of wasted calls to compute prime factors for the same number. So the second part of the exercise is to use the same closure cache technique for ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Use separate closures for caching of ", "type": "text"}, {"text": "isPrime(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", rather than putting them inside a single scope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try the exercise for yourself, then check out the suggested solution at the end of this appendix.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 3}, "content": [{"text": "A Word About Memory", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I want to share a little quick note about this closure cache technique and the impacts it has on your application's performance.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We can see that in saving the repeated calls, we improve computation speed (in some cases, by a dramatic amount). But this usage of closure is making an explicit trade-off that you should be very aware of.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The trade-off is memory. We're essentially growing our cache (in memory) unboundedly. If the functions in question were called many millions of times with mostly unique inputs, we'd be chewing up a lot of memory. This can definitely be worth the expense, but only if we think it's likely we see repetition of common inputs so that we're taking advantage of the cache.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If most every call will have a unique input, and the cache is essentially never ", "type": "text"}, {"text": "used", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to any benefit, this is an inappropriate technique to employ.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It also might be a good idea to have a more sophisticated caching approach, such as an LRU (least recently used) cache, that limits its size; as it runs up to the limit, an LRU evicts the values that are... well, least recently used!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The downside here is that LRU is quite non-trivial in its own right. You'll want to use a highly optimized implementation of LRU, and be keenly aware of all the trade-offs at play.", "type": "text"}]}]}, "article_text": "Closure (PART 1)\n\nLet's first practice closure with some common computer-math operations: determining if a value is prime (has no divisors other than 1 and itself), and generating a list of prime factors (divisors) for a given number.\n\nFor example:\n\nisPrime(11);        // true\nisPrime(12);        // false\n\nfactorize(11);      // [ 11 ]\nfactorize(12);      // [ 3, 2, 2 ] --> 3*2*2=12\n\nHere's an implementation of isPrime(..), adapted from the Math.js library: 1\n\nfunction isPrime(v) {\n    if (v <= 3) {\n        return v > 1;\n    }\n    if (v % 2 == 0 || v % 3 == 0) {\n        return false;\n    }\n    var vSqrt = Math.sqrt(v);\n    for (let i = 5; i <= vSqrt; i += 6) {\n        if (v % i == 0 || v % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nAnd here's a somewhat basic implementation of factorize(..) (not to be confused with factorial(..) from Chapter 6):\n\nfunction factorize(v) {\n    if (!isPrime(v)) {\n        let i = Math.floor(Math.sqrt(v));\n        while (v % i != 0) {\n            i--;\n        }\n        return [\n            ...factorize(i),\n            ...factorize(v / i)\n        ];\n    }\n    return [v];\n}\n\nNOTE:\n\nI call this basic because it's not optimized for performance. It's binary-recursive (which isn't tail-call optimizable), and it creates a lot of intermediate array copies. It also doesn't order the discovered factors in any way. There are many, many other algorithms for this task, but I wanted to use something short and roughly understandable for our exercise.\n\nIf you were to call isPrime(4327) multiple times in a program, you can see that it would go through all its dozens of comparison/computation steps every time. If you consider factorize(..), it's calling isPrime(..) many times as it computes the list of factors. And there's a good chance most of those calls are repeats. That's a lot of wasted work!\n\nThe first part of this exercise is to use closure to implement a cache to remember the results of isPrime(..), so that the primality (true or false) of a given number is only ever computed once. Hint: we already showed this sort of caching in Chapter 6 with factorial(..).\n\nIf you look at factorize(..), it's implemented with recursion, meaning it calls itself repeatedly. That again means we may likely see a lot of wasted calls to compute prime factors for the same number. So the second part of the exercise is to use the same closure cache technique for factorize(..).\n\nUse separate closures for caching of isPrime(..) and factorize(..), rather than putting them inside a single scope.\n\nTry the exercise for yourself, then check out the suggested solution at the end of this appendix.\n\nA Word About Memory\n\nI want to share a little quick note about this closure cache technique and the impacts it has on your application's performance.\n\nWe can see that in saving the repeated calls, we improve computation speed (in some cases, by a dramatic amount). But this usage of closure is making an explicit trade-off that you should be very aware of.\n\nThe trade-off is memory. We're essentially growing our cache (in memory) unboundedly. If the functions in question were called many millions of times with mostly unique inputs, we'd be chewing up a lot of memory. This can definitely be worth the expense, but only if we think it's likely we see repetition of common inputs so that we're taking advantage of the cache.\n\nIf most every call will have a unique input, and the cache is essentially never used to any benefit, this is an inappropriate technique to employ.\n\nIt also might be a good idea to have a more sophisticated caching approach, such as an LRU (least recently used) cache, that limits its size; as it runs up to the limit, an LRU evicts the values that are... well, least recently used!\n\nThe downside here is that LRU is quite non-trivial in its own right. You'll want to use a highly optimized implementation of LRU, and be keenly aware of all the trade-offs at play."}, "id": 273}, {"data": {"uuid": "a2b886e6-811a-427b-b2e5-34af6978433d", "user": 1, "title": "Closure (PART 2)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:20:10.716205+00:00", "updated_on": "2023-06-09 02:20:25.397342+00:00", "article_html": "<h2>Closure (PART 2)</h2><p>In this exercise, we're going to again practive closure by defining a <code>toggle(..)</code> utility that gives us a value toggler.</p><p>You will pass one or more values (as arguments) into <code>toggle(..)</code>, and get back a function. That returned function will alternate/rotate between all the passed-in values in order, one at a time, as it's called repeatedly.</p><pre><code>function toggle(/* .. */) {\n    // ..\n}\n\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\n\nhello();      // \"hello\"\nhello();      // \"hello\"\n\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\n\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"</code></pre><p>The corner case of passing in no values to <code>toggle(..)</code> is not very important; such a toggler instance could just always return <code>undefined</code>.</p><p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Closure (PART 2)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this exercise, we're going to again practive closure by defining a ", "type": "text"}, {"text": "toggle(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility that gives us a value toggler.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You will pass one or more values (as arguments) into ", "type": "text"}, {"text": "toggle(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and get back a function. That returned function will alternate/rotate between all the passed-in values in order, one at a time, as it's called repeatedly.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function toggle(/* .. */) {\n    // ..\n}\n\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\n\nhello();      // \"hello\"\nhello();      // \"hello\"\n\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\n\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The corner case of passing in no values to ", "type": "text"}, {"text": "toggle(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not very important; such a toggler instance could just always return ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try the exercise for yourself, then check out the suggested solution at the end of this appendix.", "type": "text"}]}]}, "article_text": "Closure (PART 2)\n\nIn this exercise, we're going to again practive closure by defining a toggle(..) utility that gives us a value toggler.\n\nYou will pass one or more values (as arguments) into toggle(..), and get back a function. That returned function will alternate/rotate between all the passed-in values in order, one at a time, as it's called repeatedly.\n\nfunction toggle(/* .. */) {\n    // ..\n}\n\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\n\nhello();      // \"hello\"\nhello();      // \"hello\"\n\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\n\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"\n\nThe corner case of passing in no values to toggle(..) is not very important; such a toggler instance could just always return undefined.\n\nTry the exercise for yourself, then check out the suggested solution at the end of this appendix."}, "id": 274}, {"data": {"uuid": "aeea3906-d9d7-4146-bbfb-b487a312458b", "user": 1, "title": "Closure (PART 3)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:20:39.872723+00:00", "updated_on": "2023-06-09 02:21:04.055828+00:00", "article_html": "<h2></h2><h2>Closure (PART 3)</h2><p>In this third and final exercise on closure, we're going to implement a basic calculator. The <code>calculator()</code> function will produce an instance of a calculator that maintains its own state, in the form of a function (<code>calc(..)</code>, below):</p><pre><code>function calculator() {\n    // ..\n}\n\nvar calc = calculator();</code></pre><p>Each time <code>calc(..)</code> is called, you'll pass in a single character that represents a keypress of a calculator button. To keep things more straightforward, we'll restrict our calculator to supporting entering only digits (0-9), arithmetic operations (+, -, *, /), and \"=\" to compute the operation. Operations are processed strictly in the order entered; there's no \"( )\" grouping or operator precedence.</p><p>We don't support entering decimals, but the divide operation can result in them. We don't support entering negative numbers, but the \"-\" operation can result in them. So, you should be able to produce any negative or decimal number by first entering an operation to compute it. You can then keep computing with that value.</p><p>The return of <code>calc(..)</code> calls should mimic what would be shown on a real calculator, like reflecting what was just pressed, or computing the total when pressing \"=\".</p><p>For example:</p><pre><code>calc(\"4\");     // 4\ncalc(\"+\");     // +\ncalc(\"7\");     // 7\ncalc(\"3\");     // 3\ncalc(\"-\");     // -\ncalc(\"2\");     // 2\ncalc(\"=\");     // 75\ncalc(\"*\");     // *\ncalc(\"4\");     // 4\ncalc(\"=\");     // 300\ncalc(\"5\");     // 5\ncalc(\"-\");     // -\ncalc(\"5\");     // 5\ncalc(\"=\");     // 0</code></pre><p>Since this usage is a bit clumsy, here's a <code>useCalc(..)</code> helper, that runs the calculator with characters one at a time from a string, and computes the display each time:</p><pre><code>function useCalc(calc,keys) {\n    return [...keys].reduce(\n        function showDisplay(display,key){\n            var ret = String( calc(key) );\n            return (\n                display +\n                (\n                  (ret != \"\" &amp;&amp; key == \"=\") ?\n                      \"=\" :\n                      \"\"\n                ) +\n                ret\n            );\n        },\n        \"\"\n    );\n}\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51</code></pre><p>The most sensible usage of this <code>useCalc(..)</code> helper is to always have \"=\" be the last character entered.</p><p>Some of the formatting of the totals displayed by the calculator require special handling. I'm providing this <code>formatTotal(..)</code> function, which your calculator should use whenever it's going to return a current computed total (after an <code>\"=\"</code> is entered):</p><pre><code>function formatTotal(display) {\n    if (Number.isFinite(display)) {\n        // constrain display to max 11 chars\n        let maxDigits = 11;\n        // reserve space for \"e+\" notation?\n        if (Math.abs(display) &gt; 99999999999) {\n            maxDigits -= 6;\n        }\n        // reserve space for \"-\"?\n        if (display &lt; 0) {\n            maxDigits--;\n        }\n\n        // whole number?\n        if (Number.isInteger(display)) {\n            display = display\n                .toPrecision(maxDigits)\n                .replace(/\\.0+$/,\"\");\n        }\n        // decimal\n        else {\n            // reserve space for \".\"\n            maxDigits--;\n            // reserve space for leading \"0\"?\n            if (\n                Math.abs(display) &gt;= 0 &amp;&amp;\n                Math.abs(display) &lt; 1\n            ) {\n                maxDigits--;\n            }\n            display = display\n                .toPrecision(maxDigits)\n                .replace(/0+$/,\"\");\n        }\n    }\n    else {\n        display = \"ERR\";\n    }\n    return display;\n}</code></pre><p>Don't worry too much about how <code>formatTotal(..)</code> works. Most of its logic is a bunch of handling to limit the calculator display to 11 characters max, even if negatives, repeating decimals, or even \"e+\" exponential notation is required.</p><p>Again, don't get too mired in the mud around calculator-specific behavior. Focus on the <em>memory</em> of closure.</p><p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Closure (PART 3)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this third and final exercise on closure, we're going to implement a basic calculator. The ", "type": "text"}, {"text": "calculator()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function will produce an instance of a calculator that maintains its own state, in the form of a function (", "type": "text"}, {"text": "calc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", below):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function calculator() {\n    // ..\n}\n\nvar calc = calculator();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each time ", "type": "text"}, {"text": "calc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is called, you'll pass in a single character that represents a keypress of a calculator button. To keep things more straightforward, we'll restrict our calculator to supporting entering only digits (0-9), arithmetic operations (+, -, *, /), and \"=\" to compute the operation. Operations are processed strictly in the order entered; there's no \"( )\" grouping or operator precedence.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We don't support entering decimals, but the divide operation can result in them. We don't support entering negative numbers, but the \"-\" operation can result in them. So, you should be able to produce any negative or decimal number by first entering an operation to compute it. You can then keep computing with that value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The return of ", "type": "text"}, {"text": "calc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " calls should mimic what would be shown on a real calculator, like reflecting what was just pressed, or computing the total when pressing \"=\".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "calc(\"4\");     // 4\ncalc(\"+\");     // +\ncalc(\"7\");     // 7\ncalc(\"3\");     // 3\ncalc(\"-\");     // -\ncalc(\"2\");     // 2\ncalc(\"=\");     // 75\ncalc(\"*\");     // *\ncalc(\"4\");     // 4\ncalc(\"=\");     // 300\ncalc(\"5\");     // 5\ncalc(\"-\");     // -\ncalc(\"5\");     // 5\ncalc(\"=\");     // 0", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since this usage is a bit clumsy, here's a ", "type": "text"}, {"text": "useCalc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " helper, that runs the calculator with characters one at a time from a string, and computes the display each time:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function useCalc(calc,keys) {\n    return [...keys].reduce(\n        function showDisplay(display,key){\n            var ret = String( calc(key) );\n            return (\n                display +\n                (\n                  (ret != \"\" && key == \"=\") ?\n                      \"=\" :\n                      \"\"\n                ) +\n                ret\n            );\n        },\n        \"\"\n    );\n}\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The most sensible usage of this ", "type": "text"}, {"text": "useCalc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " helper is to always have \"=\" be the last character entered.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some of the formatting of the totals displayed by the calculator require special handling. I'm providing this ", "type": "text"}, {"text": "formatTotal(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function, which your calculator should use whenever it's going to return a current computed total (after an ", "type": "text"}, {"text": "\"=\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " is entered):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function formatTotal(display) {\n    if (Number.isFinite(display)) {\n        // constrain display to max 11 chars\n        let maxDigits = 11;\n        // reserve space for \"e+\" notation?\n        if (Math.abs(display) > 99999999999) {\n            maxDigits -= 6;\n        }\n        // reserve space for \"-\"?\n        if (display < 0) {\n            maxDigits--;\n        }\n\n        // whole number?\n        if (Number.isInteger(display)) {\n            display = display\n                .toPrecision(maxDigits)\n                .replace(/\\.0+$/,\"\");\n        }\n        // decimal\n        else {\n            // reserve space for \".\"\n            maxDigits--;\n            // reserve space for leading \"0\"?\n            if (\n                Math.abs(display) >= 0 &&\n                Math.abs(display) < 1\n            ) {\n                maxDigits--;\n            }\n            display = display\n                .toPrecision(maxDigits)\n                .replace(/0+$/,\"\");\n        }\n    }\n    else {\n        display = \"ERR\";\n    }\n    return display;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't worry too much about how ", "type": "text"}, {"text": "formatTotal(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " works. Most of its logic is a bunch of handling to limit the calculator display to 11 characters max, even if negatives, repeating decimals, or even \"e+\" exponential notation is required.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Again, don't get too mired in the mud around calculator-specific behavior. Focus on the ", "type": "text"}, {"text": "memory", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try the exercise for yourself, then check out the suggested solution at the end of this appendix.", "type": "text"}]}]}, "article_text": "Closure (PART 3)\n\nIn this third and final exercise on closure, we're going to implement a basic calculator. The calculator() function will produce an instance of a calculator that maintains its own state, in the form of a function (calc(..), below):\n\nfunction calculator() {\n    // ..\n}\n\nvar calc = calculator();\n\nEach time calc(..) is called, you'll pass in a single character that represents a keypress of a calculator button. To keep things more straightforward, we'll restrict our calculator to supporting entering only digits (0-9), arithmetic operations (+, -, *, /), and \"=\" to compute the operation. Operations are processed strictly in the order entered; there's no \"( )\" grouping or operator precedence.\n\nWe don't support entering decimals, but the divide operation can result in them. We don't support entering negative numbers, but the \"-\" operation can result in them. So, you should be able to produce any negative or decimal number by first entering an operation to compute it. You can then keep computing with that value.\n\nThe return of calc(..) calls should mimic what would be shown on a real calculator, like reflecting what was just pressed, or computing the total when pressing \"=\".\n\nFor example:\n\ncalc(\"4\");     // 4\ncalc(\"+\");     // +\ncalc(\"7\");     // 7\ncalc(\"3\");     // 3\ncalc(\"-\");     // -\ncalc(\"2\");     // 2\ncalc(\"=\");     // 75\ncalc(\"*\");     // *\ncalc(\"4\");     // 4\ncalc(\"=\");     // 300\ncalc(\"5\");     // 5\ncalc(\"-\");     // -\ncalc(\"5\");     // 5\ncalc(\"=\");     // 0\n\nSince this usage is a bit clumsy, here's a useCalc(..) helper, that runs the calculator with characters one at a time from a string, and computes the display each time:\n\nfunction useCalc(calc,keys) {\n    return [...keys].reduce(\n        function showDisplay(display,key){\n            var ret = String( calc(key) );\n            return (\n                display +\n                (\n                  (ret != \"\" && key == \"=\") ?\n                      \"=\" :\n                      \"\"\n                ) +\n                ret\n            );\n        },\n        \"\"\n    );\n}\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n\nThe most sensible usage of this useCalc(..) helper is to always have \"=\" be the last character entered.\n\nSome of the formatting of the totals displayed by the calculator require special handling. I'm providing this formatTotal(..) function, which your calculator should use whenever it's going to return a current computed total (after an \"=\" is entered):\n\nfunction formatTotal(display) {\n    if (Number.isFinite(display)) {\n        // constrain display to max 11 chars\n        let maxDigits = 11;\n        // reserve space for \"e+\" notation?\n        if (Math.abs(display) > 99999999999) {\n            maxDigits -= 6;\n        }\n        // reserve space for \"-\"?\n        if (display < 0) {\n            maxDigits--;\n        }\n\n        // whole number?\n        if (Number.isInteger(display)) {\n            display = display\n                .toPrecision(maxDigits)\n                .replace(/\\.0+$/,\"\");\n        }\n        // decimal\n        else {\n            // reserve space for \".\"\n            maxDigits--;\n            // reserve space for leading \"0\"?\n            if (\n                Math.abs(display) >= 0 &&\n                Math.abs(display) < 1\n            ) {\n                maxDigits--;\n            }\n            display = display\n                .toPrecision(maxDigits)\n                .replace(/0+$/,\"\");\n        }\n    }\n    else {\n        display = \"ERR\";\n    }\n    return display;\n}\n\nDon't worry too much about how formatTotal(..) works. Most of its logic is a bunch of handling to limit the calculator display to 11 characters max, even if negatives, repeating decimals, or even \"e+\" exponential notation is required.\n\nAgain, don't get too mired in the mud around calculator-specific behavior. Focus on the memory of closure.\n\nTry the exercise for yourself, then check out the suggested solution at the end of this appendix."}, "id": 275}, {"data": {"uuid": "ac9ec862-7d0f-4aae-91da-ed45e554e7ae", "user": 1, "title": "Modules", "author": "Kyle Simpson", "created_on": "2023-06-09 02:21:24.041179+00:00", "updated_on": "2023-06-09 02:21:45.220151+00:00", "article_html": "<h2>Modules</h2><p>This exercise is to convert the calculator from Closure (PART 3) into a module.</p><p>We're not adding any additional functionality to the calculator, only changing its interface. Instead of calling a single function <code>calc(..)</code>, we'll be calling specific methods on the public API for each \"keypress\" of our calculator. The outputs stay the same.</p><p>This module should be expressed as a classic module factory function called <code>calculator()</code>, instead of a singleton IIFE, so that multiple calculators can be created if desired.</p><p>The public API should include the following methods:</p><ul><li><p><code>number(..)</code> (input: the character/number \"pressed\")</p></li><li><p><code>plus()</code></p></li><li><p><code>minus()</code></p></li><li><p><code>mult()</code></p></li><li><p><code>div()</code></p></li><li><p><code>eq()</code></p></li></ul><p>Usage would look like:</p><pre><code>var calc = calculator();\n\ncalc.number(\"4\");     // 4\ncalc.plus();          // +\ncalc.number(\"7\");     // 7\ncalc.number(\"3\");     // 3\ncalc.minus();         // -\ncalc.number(\"2\");     // 2\ncalc.eq();            // 75</code></pre><p><code>formatTotal(..)</code> remains the same from that previous exercise. But the <code>useCalc(..)</code> helper needs to be adjusted to work with the module API:</p><pre><code>function useCalc(calc,keys) {\n    var keyMappings = {\n        \"+\": \"plus\",\n        \"-\": \"minus\",\n        \"*\": \"mult\",\n        \"/\": \"div\",\n        \"=\": \"eq\"\n    };\n\n    return [...keys].reduce(\n        function showDisplay(display,key){\n            var fn = keyMappings[key] || \"number\";\n            var ret = String( calc[fn](key) );\n            return (\n                display +\n                (\n                  (ret != \"\" &amp;&amp; key == \"=\") ?\n                      \"=\" :\n                      \"\"\n                ) +\n                ret\n            );\n        },\n        \"\"\n    );\n}\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51</code></pre><p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p><p>As you work on this exercise, also spend some time considering the pros/cons of representing the calculator as a module as opposed to the closure-function approach from the previous exercise.</p><p>BONUS: write out a few sentences explaining your thoughts.</p><p>BONUS #2: try converting your module to other module formats, including: UMD, CommonJS, and ESM (ES Modules).</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Modules", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This exercise is to convert the calculator from Closure (PART 3) into a module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We're not adding any additional functionality to the calculator, only changing its interface. Instead of calling a single function ", "type": "text"}, {"text": "calc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we'll be calling specific methods on the public API for each \"keypress\" of our calculator. The outputs stay the same.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This module should be expressed as a classic module factory function called ", "type": "text"}, {"text": "calculator()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", instead of a singleton IIFE, so that multiple calculators can be created if desired.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The public API should include the following methods:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "number(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (input: the character/number \"pressed\")", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "plus()", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "minus()", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "mult()", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "div()", "type": "text", "marks": [{"type": "code"}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "eq()", "type": "text", "marks": [{"type": "code"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Usage would look like:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var calc = calculator();\n\ncalc.number(\"4\");     // 4\ncalc.plus();          // +\ncalc.number(\"7\");     // 7\ncalc.number(\"3\");     // 3\ncalc.minus();         // -\ncalc.number(\"2\");     // 2\ncalc.eq();            // 75", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "formatTotal(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " remains the same from that previous exercise. But the ", "type": "text"}, {"text": "useCalc(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " helper needs to be adjusted to work with the module API:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function useCalc(calc,keys) {\n    var keyMappings = {\n        \"+\": \"plus\",\n        \"-\": \"minus\",\n        \"*\": \"mult\",\n        \"/\": \"div\",\n        \"=\": \"eq\"\n    };\n\n    return [...keys].reduce(\n        function showDisplay(display,key){\n            var fn = keyMappings[key] || \"number\";\n            var ret = String( calc[fn](key) );\n            return (\n                display +\n                (\n                  (ret != \"\" && key == \"=\") ?\n                      \"=\" :\n                      \"\"\n                ) +\n                ret\n            );\n        },\n        \"\"\n    );\n}\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try the exercise for yourself, then check out the suggested solution at the end of this appendix.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As you work on this exercise, also spend some time considering the pros/cons of representing the calculator as a module as opposed to the closure-function approach from the previous exercise.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "BONUS: write out a few sentences explaining your thoughts.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "BONUS #2: try converting your module to other module formats, including: UMD, CommonJS, and ESM (ES Modules).", "type": "text"}]}]}, "article_text": "Modules\n\nThis exercise is to convert the calculator from Closure (PART 3) into a module.\n\nWe're not adding any additional functionality to the calculator, only changing its interface. Instead of calling a single function calc(..), we'll be calling specific methods on the public API for each \"keypress\" of our calculator. The outputs stay the same.\n\nThis module should be expressed as a classic module factory function called calculator(), instead of a singleton IIFE, so that multiple calculators can be created if desired.\n\nThe public API should include the following methods:\n\nnumber(..) (input: the character/number \"pressed\")\n\nplus()\n\nminus()\n\nmult()\n\ndiv()\n\neq()\n\nUsage would look like:\n\nvar calc = calculator();\n\ncalc.number(\"4\");     // 4\ncalc.plus();          // +\ncalc.number(\"7\");     // 7\ncalc.number(\"3\");     // 3\ncalc.minus();         // -\ncalc.number(\"2\");     // 2\ncalc.eq();            // 75\n\nformatTotal(..) remains the same from that previous exercise. But the useCalc(..) helper needs to be adjusted to work with the module API:\n\nfunction useCalc(calc,keys) {\n    var keyMappings = {\n        \"+\": \"plus\",\n        \"-\": \"minus\",\n        \"*\": \"mult\",\n        \"/\": \"div\",\n        \"=\": \"eq\"\n    };\n\n    return [...keys].reduce(\n        function showDisplay(display,key){\n            var fn = keyMappings[key] || \"number\";\n            var ret = String( calc[fn](key) );\n            return (\n                display +\n                (\n                  (ret != \"\" && key == \"=\") ?\n                      \"=\" :\n                      \"\"\n                ) +\n                ret\n            );\n        },\n        \"\"\n    );\n}\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n\nTry the exercise for yourself, then check out the suggested solution at the end of this appendix.\n\nAs you work on this exercise, also spend some time considering the pros/cons of representing the calculator as a module as opposed to the closure-function approach from the previous exercise.\n\nBONUS: write out a few sentences explaining your thoughts.\n\nBONUS #2: try converting your module to other module formats, including: UMD, CommonJS, and ESM (ES Modules)."}, "id": 276}, {"data": {"uuid": "5ae25a41-207b-4c36-ba8d-f711b8c114f5", "user": 1, "title": "Suggested Solutions", "author": "Kyle Simpson", "created_on": "2023-06-09 02:22:01.550456+00:00", "updated_on": "2023-06-09 02:22:13.210695+00:00", "article_html": "<h2>Suggested Solutions</h2><p>Hopefully you've tried out the exercises before you're reading this far. No cheating!</p><p>Remember, each suggested solution is just one of a bunch of different ways to approach the problems. They're not \"the right answer,\" but they do illustrate a reasonable way to approach each exercise.</p><p>The most important benefit you can get from reading these suggested solutions is to compare them to your code and analyze why we each made similar or different choices. Don't get into too much bikeshedding; try to stay focused on the main topic rather than the small details.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Suggested Solutions", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Hopefully you've tried out the exercises before you're reading this far. No cheating!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember, each suggested solution is just one of a bunch of different ways to approach the problems. They're not \"the right answer,\" but they do illustrate a reasonable way to approach each exercise.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The most important benefit you can get from reading these suggested solutions is to compare them to your code and analyze why we each made similar or different choices. Don't get into too much bikeshedding; try to stay focused on the main topic rather than the small details.", "type": "text"}]}]}, "article_text": "Suggested Solutions\n\nHopefully you've tried out the exercises before you're reading this far. No cheating!\n\nRemember, each suggested solution is just one of a bunch of different ways to approach the problems. They're not \"the right answer,\" but they do illustrate a reasonable way to approach each exercise.\n\nThe most important benefit you can get from reading these suggested solutions is to compare them to your code and analyze why we each made similar or different choices. Don't get into too much bikeshedding; try to stay focused on the main topic rather than the small details."}, "id": 277, "children": [{"data": {"uuid": "9c6870c1-5c3e-40f3-bff0-bd04379b9062", "user": 1, "title": "Suggested: Buckets of Marbles", "author": "Kyle Simpson", "created_on": "2023-06-09 02:22:35.992265+00:00", "updated_on": "2023-06-09 02:22:55.435652+00:00", "article_html": "<h3>Suggested: Buckets of Marbles</h3><p>The <em>Buckets of Marbles Exercise</em> can be solved like this:</p><pre><code>// RED(1)\nconst howMany = 100;\n\n// Sieve of Eratosthenes\nfunction findPrimes(howMany) {\n    // BLUE(2)\n    var sieve = Array(howMany).fill(true);\n    var max = Math.sqrt(howMany);\n\n    for (let i = 2; i &lt; max; i++) {\n        // GREEN(3)\n        if (sieve[i]) {\n            // ORANGE(4)\n            let j = Math.pow(i,2);\n            for (let k = j; k &lt; howMany; k += i) {\n                // PURPLE(5)\n                sieve[k] = false;\n            }\n        }\n    }\n\n    return sieve\n        .map(function getPrime(flag,prime){\n            // PINK(6)\n            if (flag) return prime;\n            return flag;\n        })\n        .filter(function onlyPrimes(v){\n            // YELLOW(7)\n            return !!v;\n        })\n        .slice(1);\n}\n\nfindPrimes(howMany);\n// [\n//    2, 3, 5, 7, 11, 13, 17,\n//    19, 23, 29, 31, 37, 41,\n//    43, 47, 53, 59, 61, 67,\n//    71, 73, 79, 83, 89, 97\n// ]</code></pre>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Suggested: Buckets of Marbles", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "Buckets of Marbles Exercise", "type": "text", "marks": [{"type": "italic"}]}, {"text": " can be solved like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// RED(1)\nconst howMany = 100;\n\n// Sieve of Eratosthenes\nfunction findPrimes(howMany) {\n    // BLUE(2)\n    var sieve = Array(howMany).fill(true);\n    var max = Math.sqrt(howMany);\n\n    for (let i = 2; i < max; i++) {\n        // GREEN(3)\n        if (sieve[i]) {\n            // ORANGE(4)\n            let j = Math.pow(i,2);\n            for (let k = j; k < howMany; k += i) {\n                // PURPLE(5)\n                sieve[k] = false;\n            }\n        }\n    }\n\n    return sieve\n        .map(function getPrime(flag,prime){\n            // PINK(6)\n            if (flag) return prime;\n            return flag;\n        })\n        .filter(function onlyPrimes(v){\n            // YELLOW(7)\n            return !!v;\n        })\n        .slice(1);\n}\n\nfindPrimes(howMany);\n// [\n//    2, 3, 5, 7, 11, 13, 17,\n//    19, 23, 29, 31, 37, 41,\n//    43, 47, 53, 59, 61, 67,\n//    71, 73, 79, 83, 89, 97\n// ]", "type": "text"}]}]}, "article_text": "Suggested: Buckets of Marbles\n\nThe Buckets of Marbles Exercise can be solved like this:\n\n// RED(1)\nconst howMany = 100;\n\n// Sieve of Eratosthenes\nfunction findPrimes(howMany) {\n    // BLUE(2)\n    var sieve = Array(howMany).fill(true);\n    var max = Math.sqrt(howMany);\n\n    for (let i = 2; i < max; i++) {\n        // GREEN(3)\n        if (sieve[i]) {\n            // ORANGE(4)\n            let j = Math.pow(i,2);\n            for (let k = j; k < howMany; k += i) {\n                // PURPLE(5)\n                sieve[k] = false;\n            }\n        }\n    }\n\n    return sieve\n        .map(function getPrime(flag,prime){\n            // PINK(6)\n            if (flag) return prime;\n            return flag;\n        })\n        .filter(function onlyPrimes(v){\n            // YELLOW(7)\n            return !!v;\n        })\n        .slice(1);\n}\n\nfindPrimes(howMany);\n// [\n//    2, 3, 5, 7, 11, 13, 17,\n//    19, 23, 29, 31, 37, 41,\n//    43, 47, 53, 59, 61, 67,\n//    71, 73, 79, 83, 89, 97\n// ]"}, "id": 278}, {"data": {"uuid": "e7ea168f-b0f5-4ca4-8512-c1a457402b64", "user": 1, "title": "Suggested: Closure (PART 1)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:23:27.198958+00:00", "updated_on": "2023-06-09 02:23:44.321136+00:00", "article_html": "<h3>Suggested: Closure (PART 1)</h3><p>The <em>Closure Exercise (PART 1)</em> for <code>isPrime(..)</code> and <code>factorize(..)</code>, can be solved like this:</p><pre><code>var isPrime = (function isPrime(v){\n    var primes = {};\n\n    return function isPrime(v) {\n        if (v in primes) {\n            return primes[v];\n        }\n        if (v &lt;= 3) {\n            return (primes[v] = v &gt; 1);\n        }\n        if (v % 2 == 0 || v % 3 == 0) {\n            return (primes[v] = false);\n        }\n        let vSqrt = Math.sqrt(v);\n        for (let i = 5; i &lt;= vSqrt; i += 6) {\n            if (v % i == 0 || v % (i + 2) == 0) {\n                return (primes[v] = false);\n            }\n        }\n        return (primes[v] = true);\n    };\n})();\n\nvar factorize = (function factorize(v){\n    var factors = {};\n\n    return function findFactors(v) {\n        if (v in factors) {\n            return factors[v];\n        }\n        if (!isPrime(v)) {\n            let i = Math.floor(Math.sqrt(v));\n            while (v % i != 0) {\n                i--;\n            }\n            return (factors[v] = [\n                ...findFactors(i),\n                ...findFactors(v / i)\n            ]);\n        }\n        return (factors[v] = [v]);\n    };\n})();</code></pre><p>The general steps I used for each utility:</p><ol><li><p>Wrap an IIFE to define the scope for the cache variable to reside.</p></li><li><p>In the underlying call, first check the cache, and if a result is already known, return.</p></li><li><p>At each place where a <code>return</code> was happening originally, assign to the cache and just return the results of that assignment operation\u2014this is a space savings trick mostly just for brevity in the book.</p></li></ol><p>I also renamed the inner function from <code>factorize(..)</code> to <code>findFactors(..)</code>. That's not technically necessary, but it helps it make clearer which function the recursive calls invoke.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Suggested: Closure (PART 1)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "Closure Exercise (PART 1)", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for ", "type": "text"}, {"text": "isPrime(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", can be solved like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var isPrime = (function isPrime(v){\n    var primes = {};\n\n    return function isPrime(v) {\n        if (v in primes) {\n            return primes[v];\n        }\n        if (v <= 3) {\n            return (primes[v] = v > 1);\n        }\n        if (v % 2 == 0 || v % 3 == 0) {\n            return (primes[v] = false);\n        }\n        let vSqrt = Math.sqrt(v);\n        for (let i = 5; i <= vSqrt; i += 6) {\n            if (v % i == 0 || v % (i + 2) == 0) {\n                return (primes[v] = false);\n            }\n        }\n        return (primes[v] = true);\n    };\n})();\n\nvar factorize = (function factorize(v){\n    var factors = {};\n\n    return function findFactors(v) {\n        if (v in factors) {\n            return factors[v];\n        }\n        if (!isPrime(v)) {\n            let i = Math.floor(Math.sqrt(v));\n            while (v % i != 0) {\n                i--;\n            }\n            return (factors[v] = [\n                ...findFactors(i),\n                ...findFactors(v / i)\n            ]);\n        }\n        return (factors[v] = [v]);\n    };\n})();", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The general steps I used for each utility:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Wrap an IIFE to define the scope for the cache variable to reside.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "In the underlying call, first check the cache, and if a result is already known, return.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "At each place where a ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " was happening originally, assign to the cache and just return the results of that assignment operation\u2014this is a space savings trick mostly just for brevity in the book.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "I also renamed the inner function from ", "type": "text"}, {"text": "factorize(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "findFactors(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". That's not technically necessary, but it helps it make clearer which function the recursive calls invoke.", "type": "text"}]}]}, "article_text": "Suggested: Closure (PART 1)\n\nThe Closure Exercise (PART 1) for isPrime(..) and factorize(..), can be solved like this:\n\nvar isPrime = (function isPrime(v){\n    var primes = {};\n\n    return function isPrime(v) {\n        if (v in primes) {\n            return primes[v];\n        }\n        if (v <= 3) {\n            return (primes[v] = v > 1);\n        }\n        if (v % 2 == 0 || v % 3 == 0) {\n            return (primes[v] = false);\n        }\n        let vSqrt = Math.sqrt(v);\n        for (let i = 5; i <= vSqrt; i += 6) {\n            if (v % i == 0 || v % (i + 2) == 0) {\n                return (primes[v] = false);\n            }\n        }\n        return (primes[v] = true);\n    };\n})();\n\nvar factorize = (function factorize(v){\n    var factors = {};\n\n    return function findFactors(v) {\n        if (v in factors) {\n            return factors[v];\n        }\n        if (!isPrime(v)) {\n            let i = Math.floor(Math.sqrt(v));\n            while (v % i != 0) {\n                i--;\n            }\n            return (factors[v] = [\n                ...findFactors(i),\n                ...findFactors(v / i)\n            ]);\n        }\n        return (factors[v] = [v]);\n    };\n})();\n\nThe general steps I used for each utility:\n\nWrap an IIFE to define the scope for the cache variable to reside.\n\nIn the underlying call, first check the cache, and if a result is already known, return.\n\nAt each place where a return was happening originally, assign to the cache and just return the results of that assignment operation\u2014this is a space savings trick mostly just for brevity in the book.\n\nI also renamed the inner function from factorize(..) to findFactors(..). That's not technically necessary, but it helps it make clearer which function the recursive calls invoke."}, "id": 279}, {"data": {"uuid": "792b9727-a09b-4d6c-9420-01bd69c689ac", "user": 1, "title": "Suggested: Closure (PART 2)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:23:54.524789+00:00", "updated_on": "2023-06-09 02:24:45.889276+00:00", "article_html": "<h3>Suggested: Closure (PART 2)</h3><p>The <em>Closure Exercise (PART 2)</em> <code>toggle(..)</code> can be solved like this:</p><pre><code>function toggle(...vals) {\n    var unset = {};\n    var cur = unset;\n\n    return function next(){\n        // save previous value back at\n        // the end of the list\n        if (cur != unset) {\n            vals.push(cur);\n        }\n        cur = vals.shift();\n        return cur;\n    };\n}\n\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\n\nhello();      // \"hello\"\nhello();      // \"hello\"\n\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\n\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"</code></pre>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Suggested: Closure (PART 2)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "Closure Exercise (PART 2)", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "toggle(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " can be solved like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function toggle(...vals) {\n    var unset = {};\n    var cur = unset;\n\n    return function next(){\n        // save previous value back at\n        // the end of the list\n        if (cur != unset) {\n            vals.push(cur);\n        }\n        cur = vals.shift();\n        return cur;\n    };\n}\n\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\n\nhello();      // \"hello\"\nhello();      // \"hello\"\n\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\n\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"", "type": "text"}]}]}, "article_text": "Suggested: Closure (PART 2)\n\nThe Closure Exercise (PART 2) toggle(..) can be solved like this:\n\nfunction toggle(...vals) {\n    var unset = {};\n    var cur = unset;\n\n    return function next(){\n        // save previous value back at\n        // the end of the list\n        if (cur != unset) {\n            vals.push(cur);\n        }\n        cur = vals.shift();\n        return cur;\n    };\n}\n\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\n\nhello();      // \"hello\"\nhello();      // \"hello\"\n\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\n\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\""}, "id": 280}, {"data": {"uuid": "6bac4714-cbf9-4afd-87c4-1dfe97b4d7d9", "user": 1, "title": "Suggested: Closure (PART 3)", "author": "Kyle Simpson", "created_on": "2023-06-09 02:25:10.108307+00:00", "updated_on": "2023-06-09 02:25:29.989072+00:00", "article_html": "<h3>Suggested: Closure (PART 3)</h3><p>The <em>Closure Exercise (PART 3)</em> <code>calculator()</code> can be solved like this:</p><pre><code>// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\n\nfunction calculator() {\n    var currentTotal = 0;\n    var currentVal = \"\";\n    var currentOper = \"=\";\n\n    return pressKey;\n\n    // ********************\n\n    function pressKey(key){\n        // number key?\n        if (/\\d/.test(key)) {\n            currentVal += key;\n            return key;\n        }\n        // operator key?\n        else if (/[+*/-]/.test(key)) {\n            // multiple operations in a series?\n            if (\n                currentOper != \"=\" &amp;&amp;\n                currentVal != \"\"\n            ) {\n                // implied '=' keypress\n                pressKey(\"=\");\n            }\n            else if (currentVal != \"\") {\n                currentTotal = Number(currentVal);\n            }\n            currentOper = key;\n            currentVal = \"\";\n            return key;\n        }\n        // = key?\n        else if (\n            key == \"=\" &amp;&amp;\n            currentOper != \"=\"\n        ) {\n            currentTotal = op(\n                currentTotal,\n                currentOper,\n                Number(currentVal)\n            );\n            currentOper = \"=\";\n            currentVal = \"\";\n            return formatTotal(currentTotal);\n        }\n        return \"\";\n    };\n\n    function op(val1,oper,val2) {\n        var ops = {\n            // NOTE: using arrow functions\n            // only for brevity in the book\n            \"+\": (v1,v2) =&gt; v1 + v2,\n            \"-\": (v1,v2) =&gt; v1 - v2,\n            \"*\": (v1,v2) =&gt; v1 * v2,\n            \"/\": (v1,v2) =&gt; v1 / v2\n        };\n        return ops[oper](val1,val2);\n    }\n}\n\nvar calc = calculator();\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Remember: this exercise is about closure. Don't focus too much on the actual mechanics of a calculator, but rather on whether you are properly <em>remembering</em> the calculator state across function calls.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Suggested: Closure (PART 3)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "Closure Exercise (PART 3)", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "calculator()", "type": "text", "marks": [{"type": "code"}]}, {"text": " can be solved like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\n\nfunction calculator() {\n    var currentTotal = 0;\n    var currentVal = \"\";\n    var currentOper = \"=\";\n\n    return pressKey;\n\n    // ********************\n\n    function pressKey(key){\n        // number key?\n        if (/\\d/.test(key)) {\n            currentVal += key;\n            return key;\n        }\n        // operator key?\n        else if (/[+*/-]/.test(key)) {\n            // multiple operations in a series?\n            if (\n                currentOper != \"=\" &&\n                currentVal != \"\"\n            ) {\n                // implied '=' keypress\n                pressKey(\"=\");\n            }\n            else if (currentVal != \"\") {\n                currentTotal = Number(currentVal);\n            }\n            currentOper = key;\n            currentVal = \"\";\n            return key;\n        }\n        // = key?\n        else if (\n            key == \"=\" &&\n            currentOper != \"=\"\n        ) {\n            currentTotal = op(\n                currentTotal,\n                currentOper,\n                Number(currentVal)\n            );\n            currentOper = \"=\";\n            currentVal = \"\";\n            return formatTotal(currentTotal);\n        }\n        return \"\";\n    };\n\n    function op(val1,oper,val2) {\n        var ops = {\n            // NOTE: using arrow functions\n            // only for brevity in the book\n            \"+\": (v1,v2) => v1 + v2,\n            \"-\": (v1,v2) => v1 - v2,\n            \"*\": (v1,v2) => v1 * v2,\n            \"/\": (v1,v2) => v1 / v2\n        };\n        return ops[oper](val1,val2);\n    }\n}\n\nvar calc = calculator();\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Remember: this exercise is about closure. Don't focus too much on the actual mechanics of a calculator, but rather on whether you are properly ", "type": "text"}, {"text": "remembering", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the calculator state across function calls.", "type": "text"}]}]}]}]}]}, "article_text": "Suggested: Closure (PART 3)\n\nThe Closure Exercise (PART 3) calculator() can be solved like this:\n\n// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\n\nfunction calculator() {\n    var currentTotal = 0;\n    var currentVal = \"\";\n    var currentOper = \"=\";\n\n    return pressKey;\n\n    // ********************\n\n    function pressKey(key){\n        // number key?\n        if (/\\d/.test(key)) {\n            currentVal += key;\n            return key;\n        }\n        // operator key?\n        else if (/[+*/-]/.test(key)) {\n            // multiple operations in a series?\n            if (\n                currentOper != \"=\" &&\n                currentVal != \"\"\n            ) {\n                // implied '=' keypress\n                pressKey(\"=\");\n            }\n            else if (currentVal != \"\") {\n                currentTotal = Number(currentVal);\n            }\n            currentOper = key;\n            currentVal = \"\";\n            return key;\n        }\n        // = key?\n        else if (\n            key == \"=\" &&\n            currentOper != \"=\"\n        ) {\n            currentTotal = op(\n                currentTotal,\n                currentOper,\n                Number(currentVal)\n            );\n            currentOper = \"=\";\n            currentVal = \"\";\n            return formatTotal(currentTotal);\n        }\n        return \"\";\n    };\n\n    function op(val1,oper,val2) {\n        var ops = {\n            // NOTE: using arrow functions\n            // only for brevity in the book\n            \"+\": (v1,v2) => v1 + v2,\n            \"-\": (v1,v2) => v1 - v2,\n            \"*\": (v1,v2) => v1 * v2,\n            \"/\": (v1,v2) => v1 / v2\n        };\n        return ops[oper](val1,val2);\n    }\n}\n\nvar calc = calculator();\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n\nNOTE:\n\nRemember: this exercise is about closure. Don't focus too much on the actual mechanics of a calculator, but rather on whether you are properly remembering the calculator state across function calls."}, "id": 281}, {"data": {"uuid": "e2c6fa4e-6f6f-4dec-a767-b88d8ab55c6f", "user": 1, "title": "Suggested: Modules", "author": "Kyle Simpson", "created_on": "2023-06-09 02:25:52.748313+00:00", "updated_on": "2023-06-09 02:26:15.030981+00:00", "article_html": "<h3>Suggested: Modules</h3><p>The <em>Modules Exercise</em> <code>calculator()</code> can be solved like this:</p><pre><code>// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\n\nfunction calculator() {\n    var currentTotal = 0;\n    var currentVal = \"\";\n    var currentOper = \"=\";\n\n    var publicAPI = {\n        number,\n        eq,\n        plus() { return operator(\"+\"); },\n        minus() { return operator(\"-\"); },\n        mult() { return operator(\"*\"); },\n        div() { return operator(\"/\"); }\n    };\n\n    return publicAPI;\n\n    // ********************\n\n    function number(key) {\n        // number key?\n        if (/\\d/.test(key)) {\n            currentVal += key;\n            return key;\n        }\n    }\n\n    function eq() {\n        // = key?\n        if (currentOper != \"=\") {\n            currentTotal = op(\n                currentTotal,\n                currentOper,\n                Number(currentVal)\n            );\n            currentOper = \"=\";\n            currentVal = \"\";\n            return formatTotal(currentTotal);\n        }\n        return \"\";\n    }\n\n    function operator(key) {\n        // multiple operations in a series?\n        if (\n            currentOper != \"=\" &amp;&amp;\n            currentVal != \"\"\n        ) {\n            // implied '=' keypress\n            eq();\n        }\n        else if (currentVal != \"\") {\n            currentTotal = Number(currentVal);\n        }\n        currentOper = key;\n        currentVal = \"\";\n        return key;\n    }\n\n    function op(val1,oper,val2) {\n        var ops = {\n            // NOTE: using arrow functions\n            // only for brevity in the book\n            \"+\": (v1,v2) =&gt; v1 + v2,\n            \"-\": (v1,v2) =&gt; v1 - v2,\n            \"*\": (v1,v2) =&gt; v1 * v2,\n            \"/\": (v1,v2) =&gt; v1 / v2\n        };\n        return ops[oper](val1,val2);\n    }\n}\n\nvar calc = calculator();\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51</code></pre><p>That's it for this book, congratulations on your achievement! When you're ready, move on to Book 3, <em>Objects &amp; Classes</em>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Suggested: Modules", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "Modules Exercise", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "calculator()", "type": "text", "marks": [{"type": "code"}]}, {"text": " can be solved like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\n\nfunction calculator() {\n    var currentTotal = 0;\n    var currentVal = \"\";\n    var currentOper = \"=\";\n\n    var publicAPI = {\n        number,\n        eq,\n        plus() { return operator(\"+\"); },\n        minus() { return operator(\"-\"); },\n        mult() { return operator(\"*\"); },\n        div() { return operator(\"/\"); }\n    };\n\n    return publicAPI;\n\n    // ********************\n\n    function number(key) {\n        // number key?\n        if (/\\d/.test(key)) {\n            currentVal += key;\n            return key;\n        }\n    }\n\n    function eq() {\n        // = key?\n        if (currentOper != \"=\") {\n            currentTotal = op(\n                currentTotal,\n                currentOper,\n                Number(currentVal)\n            );\n            currentOper = \"=\";\n            currentVal = \"\";\n            return formatTotal(currentTotal);\n        }\n        return \"\";\n    }\n\n    function operator(key) {\n        // multiple operations in a series?\n        if (\n            currentOper != \"=\" &&\n            currentVal != \"\"\n        ) {\n            // implied '=' keypress\n            eq();\n        }\n        else if (currentVal != \"\") {\n            currentTotal = Number(currentVal);\n        }\n        currentOper = key;\n        currentVal = \"\";\n        return key;\n    }\n\n    function op(val1,oper,val2) {\n        var ops = {\n            // NOTE: using arrow functions\n            // only for brevity in the book\n            \"+\": (v1,v2) => v1 + v2,\n            \"-\": (v1,v2) => v1 - v2,\n            \"*\": (v1,v2) => v1 * v2,\n            \"/\": (v1,v2) => v1 / v2\n        };\n        return ops[oper](val1,val2);\n    }\n}\n\nvar calc = calculator();\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's it for this book, congratulations on your achievement! When you're ready, move on to Book 3, ", "type": "text"}, {"text": "Objects & Classes", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Suggested: Modules\n\nThe Modules Exercise calculator() can be solved like this:\n\n// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\n\nfunction calculator() {\n    var currentTotal = 0;\n    var currentVal = \"\";\n    var currentOper = \"=\";\n\n    var publicAPI = {\n        number,\n        eq,\n        plus() { return operator(\"+\"); },\n        minus() { return operator(\"-\"); },\n        mult() { return operator(\"*\"); },\n        div() { return operator(\"/\"); }\n    };\n\n    return publicAPI;\n\n    // ********************\n\n    function number(key) {\n        // number key?\n        if (/\\d/.test(key)) {\n            currentVal += key;\n            return key;\n        }\n    }\n\n    function eq() {\n        // = key?\n        if (currentOper != \"=\") {\n            currentTotal = op(\n                currentTotal,\n                currentOper,\n                Number(currentVal)\n            );\n            currentOper = \"=\";\n            currentVal = \"\";\n            return formatTotal(currentTotal);\n        }\n        return \"\";\n    }\n\n    function operator(key) {\n        // multiple operations in a series?\n        if (\n            currentOper != \"=\" &&\n            currentVal != \"\"\n        ) {\n            // implied '=' keypress\n            eq();\n        }\n        else if (currentVal != \"\") {\n            currentTotal = Number(currentVal);\n        }\n        currentOper = key;\n        currentVal = \"\";\n        return key;\n    }\n\n    function op(val1,oper,val2) {\n        var ops = {\n            // NOTE: using arrow functions\n            // only for brevity in the book\n            \"+\": (v1,v2) => v1 + v2,\n            \"-\": (v1,v2) => v1 - v2,\n            \"*\": (v1,v2) => v1 * v2,\n            \"/\": (v1,v2) => v1 / v2\n        };\n        return ops[oper](val1,val2);\n    }\n}\n\nvar calc = calculator();\n\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n\nThat's it for this book, congratulations on your achievement! When you're ready, move on to Book 3, Objects & Classes."}, "id": 282}]}]}]}]