[{"data": {"uuid": "28fbcf1d-a6b8-4055-825c-4edf8ba5db69", "user": 1, "title": "You Don't Know JS: Get Started - 2nd Edition", "author": "Kyle Simpson", "created_on": "2023-06-05 17:05:34.159327+00:00", "updated_on": "2023-06-05 21:07:20.217518+00:00", "article_html": "<h1>You Don't Know JS Yet: Get Started - 2nd Edition</h1><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/cover.png\"><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://leanpub.com/ydkjsy-get-started\"><strong>Purchase ebook/PDF from LeanPub</strong></a></p><p>Table of Contents</p><ul><li><p>Foreword</p></li><li><p>Preface</p></li><li><p>Chapter 1: What Is JavaScript?</p></li><li><p>Chapter 2: Surveying JS</p></li><li><p>Chapter 3: Digging to the Roots of JS</p></li><li><p>Chapter 4: The Bigger Picture</p></li><li><p>Appendix A: Exploring Further</p></li><li><p>Appendix B: Practice, Practice, Practice!</p></li></ul><p></p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "You Don't Know JS Yet: Get Started - 2nd Edition", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/cover.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Purchase ebook/PDF from LeanPub", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://leanpub.com/ydkjsy-get-started", "class": null, "target": "_blank"}}, {"type": "bold"}]}]}, {"type": "paragraph", "content": [{"text": "Table of Contents", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Foreword", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Preface", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 1: What Is JavaScript?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 2: Surveying JS", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 3: Digging to the Roots of JS", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 4: The Bigger Picture", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix A: Exploring Further", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix B: Practice, Practice, Practice!", "type": "text"}]}]}]}, {"type": "paragraph"}]}, "article_text": "You Don't Know JS Yet: Get Started - 2nd Edition\r\n\r\nPurchase ebook/PDF from LeanPub\r\n\r\nTable of Contents\r\n\r\nForeword\r\n\r\nPreface\r\n\r\nChapter 1: What Is JavaScript?\r\n\r\nChapter 2: Surveying JS\r\n\r\nChapter 3: Digging to the Roots of JS\r\n\r\nChapter 4: The Bigger Picture\r\n\r\nAppendix A: Exploring Further\r\n\r\nAppendix B: Practice, Practice, Practice!"}, "id": 98, "children": [{"data": {"uuid": "5edbbda9-d7ec-4825-b1b6-8f0f2ef68c39", "user": 1, "title": "Table of Contents", "author": "Kyle Simpson", "created_on": "2023-06-05 19:37:11.119243+00:00", "updated_on": "2023-06-05 19:54:45.120369+00:00", "article_html": "<h1>Table of Contents</h1><ul><li><p>Foreword</p></li><li><p>Preface</p></li><li><p>Chapter 1: What Is JavaScript?</p><ul><li><p>About This Book</p></li><li><p>What's With That Name?</p></li><li><p>Language Specification</p></li><li><p>Many Faces</p></li><li><p>Backwards &amp; Forwards</p></li><li><p>What's in an Interpretation?</p></li><li><p>Strictly Speaking</p></li><li><p>Defined</p></li></ul></li><li><p>Chapter 2: Surveying JS</p><ul><li><p>Each File is a Program</p></li><li><p>Values</p></li><li><p>Declaring and Using Variables</p></li><li><p>Functions</p></li><li><p>Comparisons</p></li><li><p>How We Organize in JS</p></li><li><p>The Rabbit Hole Deepens</p></li></ul></li><li><p>Chapter 3: Digging To The Roots Of JS</p><ul><li><p>Iteration</p></li><li><p>Closure</p></li><li><p><code>this</code> Keyword</p></li><li><p>Prototypes</p></li><li><p>Asking \"Why?\"</p></li></ul></li><li><p>Chapter 4: The Bigger Picture</p><ul><li><p>Pillar 1: Scope and Closure</p></li><li><p>Pillar 2: Prototypes</p></li><li><p>Pillar 3: Types and Coercion</p></li><li><p>With the Grain</p></li><li><p>In Order</p></li></ul></li><li><p>Appendix A: Exploring Further</p><ul><li><p>Values vs. References</p></li><li><p>So Many Function Forms</p></li><li><p>Coercive Conditional Comparison</p></li><li><p>Prototypal \"Classes\"</p></li></ul></li><li><p>Appendix B: Practice, Practice, Practice!</p><ul><li><p>Practicing Comparisons</p></li><li><p>Practicing Closure</p></li><li><p>Practicing Prototypes</p></li><li><p>Suggested Solutions</p></li></ul></li></ul>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Table of Contents", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Foreword", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Preface", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 1: What Is JavaScript?", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "About This Book", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "What's With That Name?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Language Specification", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Many Faces", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Backwards & Forwards", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "What's in an Interpretation?", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Strictly Speaking", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Defined", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 2: Surveying JS", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Each File is a Program", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Values", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Declaring and Using Variables", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Functions", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Comparisons", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "How We Organize in JS", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The Rabbit Hole Deepens", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 3: Digging To The Roots Of JS", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Iteration", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Closure", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " Keyword", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Prototypes", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Asking \"Why?\"", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Chapter 4: The Bigger Picture", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Pillar 1: Scope and Closure", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Pillar 2: Prototypes", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Pillar 3: Types and Coercion", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "With the Grain", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "In Order", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix A: Exploring Further", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Values vs. References", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "So Many Function Forms", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Coercive Conditional Comparison", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Prototypal \"Classes\"", "type": "text"}]}]}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Appendix B: Practice, Practice, Practice!", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Practicing Comparisons", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Practicing Closure", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Practicing Prototypes", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Suggested Solutions", "type": "text"}]}]}]}]}]}]}, "article_text": "Table of Contents\n\nForeword\n\nPreface\n\nChapter 1: What Is JavaScript?\n\nAbout This Book\n\nWhat's With That Name?\n\nLanguage Specification\n\nMany Faces\n\nBackwards & Forwards\n\nWhat's in an Interpretation?\n\nStrictly Speaking\n\nDefined\n\nChapter 2: Surveying JS\n\nEach File is a Program\n\nValues\n\nDeclaring and Using Variables\n\nFunctions\n\nComparisons\n\nHow We Organize in JS\n\nThe Rabbit Hole Deepens\n\nChapter 3: Digging To The Roots Of JS\n\nIteration\n\nClosure\n\nthis Keyword\n\nPrototypes\n\nAsking \"Why?\"\n\nChapter 4: The Bigger Picture\n\nPillar 1: Scope and Closure\n\nPillar 2: Prototypes\n\nPillar 3: Types and Coercion\n\nWith the Grain\n\nIn Order\n\nAppendix A: Exploring Further\n\nValues vs. References\n\nSo Many Function Forms\n\nCoercive Conditional Comparison\n\nPrototypal \"Classes\"\n\nAppendix B: Practice, Practice, Practice!\n\nPracticing Comparisons\n\nPracticing Closure\n\nPracticing Prototypes\n\nSuggested Solutions"}, "id": 99}, {"data": {"uuid": "2c8ff2ec-b406-4eb2-be61-7efa17a89a18", "user": 1, "title": "Foreword", "author": "Kyle Simpson", "created_on": "2023-06-05 19:53:31.799986+00:00", "updated_on": "2023-06-05 19:56:35.214408+00:00", "article_html": "<h1>Foreword</h1><p>The first time I saw a tweet advertising the crowdfunding campaign for the original book series <em>You Don't Know JS</em>, I thought to myself that whoever the hell this Kyle Simpson is can get bent. Of course I know JavaScript! At the time I had been working in JavaScript for many years with some of tech's biggest names, so I felt justified in looking down my nose at this sweeping claim.</p><p>Once the funding for the book completed, I observed that a lot of people were really excited to read this book series and I decided to go ahead and give it a shot\u2014you know, just to show everyone that I <em>do know</em> JavaScript. Once I dug in and poured over the texts, I experienced a profound mix of learning, surprise, and even a little anger. Kyle has a knack for saying something that challenges my world view and making me think about it until I realize what he said was actually true (I'll never admit this to him though!).</p><p>So it turned out I didn't know JavaScript. I didn't know why I had adopted certain patterns; I didn't know why JavaScript behaves the way it does in certain situations, and I didn't know much of the nuance of the languages that I assumed I did. Many were things I didn't know I didn't know, and I was worse off as a developer for it.</p><p>This is what this book series is great for. It's not just for someone picking up the language for the first time (though it's for them, too); it's for all software craftspeople who want to master their tools, who want to understand the ins and outs of their trade, and who want to select the proper methods for solving problems.</p><p>The thing I appreciate about Kyle and his work is that he is delightfully uninfluenced by the zeitgeist of the programming world around him. That isn't to say he isn't aware of what's happening in the community but rather that it doesn't sway his pursuit of the best answers to the correct questions. This often has put him at odds with the latest \"best practices,\" but in reality this is exactly what you need: a perspective removed from temporal influence and simply speaking to the underlying truth. That's why this series is so good. The first edition of <em>You Don't Know JS</em> is still accurate, years later! Not many things stand this test of time given the shifting sands of the JavaScript landscape.</p><p>Let's talk a moment about this first book itself, <em>Get Started</em>. You may be tempted to skip it as you may think that you already have \"gotten started,\" but it's worth reading this one! You'd be surprised how much depth, nuance, and oddity there is in the underlying building blocks of JavaScript, and it's quite essential for you to grapple with these underpinnings before venturing forward into the constructs of the language. It's exactly the sort of foundation you need, to really know JavaScript.</p><p>So, do your future self a favor and dig into this book and unlock the knowledge within. These solid foundations will serve you better than any framework ever will; those come and go but we'll still be writing JavaScript itself for decades to come. Keep an open mind and challenge your preconceived notions.</p><p>Because, as I found out myself, you probably don't know JavaScript (yet).</p><p>Brian Holt<br>Senior Program Manager<br>Visual Studio Code and Node.js on Azure<br>Microsoft</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Foreword", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first time I saw a tweet advertising the crowdfunding campaign for the original book series ", "type": "text"}, {"text": "You Don't Know JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", I thought to myself that whoever the hell this Kyle Simpson is can get bent. Of course I know JavaScript! At the time I had been working in JavaScript for many years with some of tech's biggest names, so I felt justified in looking down my nose at this sweeping claim.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Once the funding for the book completed, I observed that a lot of people were really excited to read this book series and I decided to go ahead and give it a shot\u2014you know, just to show everyone that I ", "type": "text"}, {"text": "do know", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JavaScript. Once I dug in and poured over the texts, I experienced a profound mix of learning, surprise, and even a little anger. Kyle has a knack for saying something that challenges my world view and making me think about it until I realize what he said was actually true (I'll never admit this to him though!).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So it turned out I didn't know JavaScript. I didn't know why I had adopted certain patterns; I didn't know why JavaScript behaves the way it does in certain situations, and I didn't know much of the nuance of the languages that I assumed I did. Many were things I didn't know I didn't know, and I was worse off as a developer for it.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is what this book series is great for. It's not just for someone picking up the language for the first time (though it's for them, too); it's for all software craftspeople who want to master their tools, who want to understand the ins and outs of their trade, and who want to select the proper methods for solving problems.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The thing I appreciate about Kyle and his work is that he is delightfully uninfluenced by the zeitgeist of the programming world around him. That isn't to say he isn't aware of what's happening in the community but rather that it doesn't sway his pursuit of the best answers to the correct questions. This often has put him at odds with the latest \"best practices,\" but in reality this is exactly what you need: a perspective removed from temporal influence and simply speaking to the underlying truth. That's why this series is so good. The first edition of ", "type": "text"}, {"text": "You Don't Know JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is still accurate, years later! Not many things stand this test of time given the shifting sands of the JavaScript landscape.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's talk a moment about this first book itself, ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". You may be tempted to skip it as you may think that you already have \"gotten started,\" but it's worth reading this one! You'd be surprised how much depth, nuance, and oddity there is in the underlying building blocks of JavaScript, and it's quite essential for you to grapple with these underpinnings before venturing forward into the constructs of the language. It's exactly the sort of foundation you need, to really know JavaScript.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So, do your future self a favor and dig into this book and unlock the knowledge within. These solid foundations will serve you better than any framework ever will; those come and go but we'll still be writing JavaScript itself for decades to come. Keep an open mind and challenge your preconceived notions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Because, as I found out myself, you probably don't know JavaScript (yet).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Brian Holt", "type": "text"}, {"type": "hardBreak"}, {"text": "Senior Program Manager", "type": "text"}, {"type": "hardBreak"}, {"text": "Visual Studio Code and Node.js on Azure", "type": "text"}, {"type": "hardBreak"}, {"text": "Microsoft", "type": "text"}]}]}, "article_text": "Foreword\n\nThe first time I saw a tweet advertising the crowdfunding campaign for the original book series You Don't Know JS, I thought to myself that whoever the hell this Kyle Simpson is can get bent. Of course I know JavaScript! At the time I had been working in JavaScript for many years with some of tech's biggest names, so I felt justified in looking down my nose at this sweeping claim.\n\nOnce the funding for the book completed, I observed that a lot of people were really excited to read this book series and I decided to go ahead and give it a shot\u2014you know, just to show everyone that I do know JavaScript. Once I dug in and poured over the texts, I experienced a profound mix of learning, surprise, and even a little anger. Kyle has a knack for saying something that challenges my world view and making me think about it until I realize what he said was actually true (I'll never admit this to him though!).\n\nSo it turned out I didn't know JavaScript. I didn't know why I had adopted certain patterns; I didn't know why JavaScript behaves the way it does in certain situations, and I didn't know much of the nuance of the languages that I assumed I did. Many were things I didn't know I didn't know, and I was worse off as a developer for it.\n\nThis is what this book series is great for. It's not just for someone picking up the language for the first time (though it's for them, too); it's for all software craftspeople who want to master their tools, who want to understand the ins and outs of their trade, and who want to select the proper methods for solving problems.\n\nThe thing I appreciate about Kyle and his work is that he is delightfully uninfluenced by the zeitgeist of the programming world around him. That isn't to say he isn't aware of what's happening in the community but rather that it doesn't sway his pursuit of the best answers to the correct questions. This often has put him at odds with the latest \"best practices,\" but in reality this is exactly what you need: a perspective removed from temporal influence and simply speaking to the underlying truth. That's why this series is so good. The first edition of You Don't Know JS is still accurate, years later! Not many things stand this test of time given the shifting sands of the JavaScript landscape.\n\nLet's talk a moment about this first book itself, Get Started. You may be tempted to skip it as you may think that you already have \"gotten started,\" but it's worth reading this one! You'd be surprised how much depth, nuance, and oddity there is in the underlying building blocks of JavaScript, and it's quite essential for you to grapple with these underpinnings before venturing forward into the constructs of the language. It's exactly the sort of foundation you need, to really know JavaScript.\n\nSo, do your future self a favor and dig into this book and unlock the knowledge within. These solid foundations will serve you better than any framework ever will; those come and go but we'll still be writing JavaScript itself for decades to come. Keep an open mind and challenge your preconceived notions.\n\nBecause, as I found out myself, you probably don't know JavaScript (yet).\n\nBrian Holt\nSenior Program Manager\nVisual Studio Code and Node.js on Azure\nMicrosoft"}, "id": 100}, {"data": {"uuid": "b7ef09a8-ca68-4e4e-a0ff-5cdfaae852df", "user": 1, "title": "Preface", "author": "Kyle Simpson", "created_on": "2023-06-05 20:01:55.298972+00:00", "updated_on": "2023-06-05 20:03:50.508351+00:00", "article_html": "<h1>Preface</h1><p>Welcome to the 2nd edition of the widely acclaimed <em>You Don't Know JS</em> (<strong>YDKJS</strong>) book series: <em>You Don't Know JS </em><strong><em>Yet</em></strong> (<strong>YDKJSY</strong>).</p><p>If you've read any of the 1st edition books, you can expect a refreshed approach in these new ones, with plenty of updated coverage of what's changed in JS over the last five years. But what I hope and believe you'll still <em>get</em> is the same commitment to respecting JS and digging into what really makes it tick.</p><p>If this is your first time reading these books, I'm glad you're here. Prepare for a deep and extensive journey into all the corners of JavaScript.</p><p>If you are new to programming or JS, be aware that these books are not intended as a gentle \"intro to JavaScript.\" This material is, at times, complex and challenging, and goes much deeper than is typical for a first-time learner. You're welcome here no matter what your background is, but these books are written assuming you're already comfortable with JS and have at least 6\u20139 months experience with it.</p><h2>The Parts</h2><p>These books approach JavaScript intentionally opposite of how <em>The Good Parts</em> treats the language. No, that doesn't mean we're looking at <em>the bad parts</em>, but rather, exploring <strong>all the parts</strong>.</p><p>You may have been told, or felt yourself, that JS is a deeply flawed language that was poorly designed and inconsistently implemented. Many have asserted that it's the worst most popular language in the world; that nobody writes JS because they want to, only because they have to given its place at the center of the web. That's a ridiculous, unhealthy, and wholly condescending claim.</p><p>Millions of developers write JavaScript every day, and many of them appreciate and respect the language.</p><p>Like any great language, it has its brilliant parts as well as its scars. Even the creator of JavaScript himself, Brendan Eich, laments some of those parts as mistakes. But he's wrong: they weren't mistakes at all. JS is what it is today\u2014the world's most ubiquitous and thus most influential programming language\u2014precisely because of <em>all those parts</em>.</p><p>Don't buy the lie that you should only learn and use a small collection of <em>good parts</em> while avoiding all the bad stuff. Don't buy the \"X is the new Y\" snake oil, that some new feature of the language instantly relegates all usage of a previous feature as obsolete and ignorant. Don't listen when someone says your code isn't \"modern\" because it isn't yet using a stage-0 feature that was only proposed a few weeks ago!</p><p>Every part of JS is useful. Some parts are more useful than others. Some parts require you to be more careful and intentional.</p><p>I find it absurd to try to be a truly effective JavaScript developer while only using a small sliver of what the language has to offer. Can you imagine a construction worker with a toolbox full of tools, who only uses their hammer and scoffs at the screwdriver or tape measure as inferior? That's just silly.</p><p>My unreserved claim is that you should go about learning all parts of JavaScript, and where appropriate, use them! And if I may be so bold as to suggest: it's time to discard any JS books that tell you otherwise.</p><h2>The Title?</h2><p>So what's the title of the series all about?</p><p>I'm not trying to insult you with criticism about your current lack of knowledge or understanding of JavaScript. I'm not suggesting you can't or won't be able to learn JavaScript. I'm not boasting about secret advanced insider wisdom that I and only a select few possess.</p><p>Seriously, all those were real reactions to the original series title before folks even read the books. And they're baseless.</p><p>The primary point of the title \"You Don't Know JS Yet\" is to point out that most JS developers don't take the time to really understand how the code that they write works. They know <em>that</em> it works\u2014that it produces a desired outcome. But they either don't understand exactly <em>how</em>, or worse, they have an inaccurate mental model for the <em>how</em> that falters on closer scrutiny.</p><p>I'm presenting a gentle but earnest challenge to you the reader, to set aside the assumptions you have about JS, and approach it with fresh eyes and an invigorated curiosity that leads you to ask <em>why</em> for every line of code you write. Why does it do what it does? Why is one way better or more appropriate than the other half-dozen ways you could have accomplished it? Why do all the \"popular kids\" say to do X with your code, but it turns out that Y might be a better choice?</p><p>I added \"Yet\" to the title, not only because it's the second edition, but because ultimately I want these books to challenge you in a hopeful rather than discouraging way.</p><p>But let me be clear: I don't think it's possible to ever fully <em>know</em> JS. That's not an achievement to be obtained, but a goal to strive after. You don't finish knowing everything about JS, you just keep learning more and more as you spend more time with the language. And the deeper you go, the more you revisit what you <em>knew</em> before, and you re-learn it from that more experienced perspective.</p><p>I encourage you to adopt a mindset around JavaScript, and indeed all of software development, that you will never fully have mastered it, but that you can and should keep working to get closer to that end, a journey that will stretch for the entirety of your software development career, and beyond.</p><p>You can always know JS better than you currently do. That's what I hope these YDKJSY books represent.</p><h2>The Mission</h2><p>The case doesn't really need to be made for why developers should take JS seriously\u2014I think it's already more than proven worthy of first-class status among the world's programming languages.</p><p>But a different, more important case still needs to be made, and these books rise to that challenge.</p><p>I've taught more than 5,000 developers from teams and companies all over the world, in more than 25 countries on six continents. And what I've seen is that far too often, what <em>counts</em> is generally just the result of the program, not how the program is written or how/why it works.</p><p>My experience not only as a developer but in teaching many other developers tells me: you will always be more effective in your development work if you more completely understand how your code works than you are solely <em>just</em> getting it to produce a desired outcome.</p><p>In other words, <em>good enough to work</em> is not, and should not be, <em>good enough</em>.</p><p>All developers regularly struggle with some piece of code not working correctly, and they can't figure out why. But far too often, JS developers will blame this on the language rather than admitting it's their own understanding that is falling short. These books serve as both the question and answer: why did it do <em>this</em>, and here's how to get it to do <em>that</em> instead.</p><p>My mission with YDKJSY is to empower every single JS developer to fully own the code they write, to understand it and to write with intention and clarity.</p><h2>The Path</h2><p>Some of you have started reading this book with the goal of completing all six books, back to back.</p><p>I would like to caution you to consider changing that plan.</p><p>It is not my intention that YDKJSY be read straight through. The material in these books is dense, because JavaScript is powerful, sophisticated, and in parts rather complex. Nobody can really hope to <em>download</em> all this information to their brains in a single pass and retain any significant amount of it. That's unreasonable, and it's foolish to try.</p><p>My suggestion is you take your time going through YDKJSY. Take one chapter, read it completely through start to finish, and then go back and re-read it section by section. Stop in between each section, and practice the code or ideas from that section. For larger concepts, it probably is a good idea to expect to spend several days digesting, re-reading, practicing, then digesting some more.</p><p>You could spend a week or two on each chapter, and a month or two on each book, and a year or more on the whole series, and you would still not be squeezing every ounce of YDKJSY out.</p><p>Don't binge these books; be patient and spread out your reading. Interleave reading with lots of practice on real code in your job or on projects you participate in. Wrestle with the opinions I've presented along the way, debate with others, and most of all, disagree with me! Run a study group or book club. Teach mini-workshops at your office. Write blog posts on what you've learned. Speak about these topics at local JS meetups.</p><p>It's never my goal to convince you to agree with my opinion, but to encourage you to own and be able to defend your opinions. You can't get <em>there</em> with an expedient read-through of these books. That's something that takes a long while to emerge, little by little, as you study and ponder and re-visit.</p><p>These books are meant to be a field-guide on your wanderings through JavaScript, from wherever you currently are with the language, to a place of deeper understanding. And the deeper you understand JS, the more questions you will ask and the more you will have to explore! That's what I find so exciting!</p><p>I'm so glad you're embarking on this journey, and I am so honored you would consider and consult these books along the way. It's time to start <em>getting to know JS</em>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Preface", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Welcome to the 2nd edition of the widely acclaimed ", "type": "text"}, {"text": "You Don't Know JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (", "type": "text"}, {"text": "YDKJS", "type": "text", "marks": [{"type": "bold"}]}, {"text": ") book series: ", "type": "text"}, {"text": "You Don't Know JS ", "type": "text", "marks": [{"type": "italic"}]}, {"text": "Yet", "type": "text", "marks": [{"type": "bold"}, {"type": "italic"}]}, {"text": " (", "type": "text"}, {"text": "YDKJSY", "type": "text", "marks": [{"type": "bold"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you've read any of the 1st edition books, you can expect a refreshed approach in these new ones, with plenty of updated coverage of what's changed in JS over the last five years. But what I hope and believe you'll still ", "type": "text"}, {"text": "get", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is the same commitment to respecting JS and digging into what really makes it tick.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If this is your first time reading these books, I'm glad you're here. Prepare for a deep and extensive journey into all the corners of JavaScript.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you are new to programming or JS, be aware that these books are not intended as a gentle \"intro to JavaScript.\" This material is, at times, complex and challenging, and goes much deeper than is typical for a first-time learner. You're welcome here no matter what your background is, but these books are written assuming you're already comfortable with JS and have at least 6\u20139 months experience with it.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Parts", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These books approach JavaScript intentionally opposite of how ", "type": "text"}, {"text": "The Good Parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": " treats the language. No, that doesn't mean we're looking at ", "type": "text"}, {"text": "the bad parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", but rather, exploring ", "type": "text"}, {"text": "all the parts", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You may have been told, or felt yourself, that JS is a deeply flawed language that was poorly designed and inconsistently implemented. Many have asserted that it's the worst most popular language in the world; that nobody writes JS because they want to, only because they have to given its place at the center of the web. That's a ridiculous, unhealthy, and wholly condescending claim.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Millions of developers write JavaScript every day, and many of them appreciate and respect the language.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Like any great language, it has its brilliant parts as well as its scars. Even the creator of JavaScript himself, Brendan Eich, laments some of those parts as mistakes. But he's wrong: they weren't mistakes at all. JS is what it is today\u2014the world's most ubiquitous and thus most influential programming language\u2014precisely because of ", "type": "text"}, {"text": "all those parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't buy the lie that you should only learn and use a small collection of ", "type": "text"}, {"text": "good parts", "type": "text", "marks": [{"type": "italic"}]}, {"text": " while avoiding all the bad stuff. Don't buy the \"X is the new Y\" snake oil, that some new feature of the language instantly relegates all usage of a previous feature as obsolete and ignorant. Don't listen when someone says your code isn't \"modern\" because it isn't yet using a stage-0 feature that was only proposed a few weeks ago!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Every part of JS is useful. Some parts are more useful than others. Some parts require you to be more careful and intentional.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I find it absurd to try to be a truly effective JavaScript developer while only using a small sliver of what the language has to offer. Can you imagine a construction worker with a toolbox full of tools, who only uses their hammer and scoffs at the screwdriver or tape measure as inferior? That's just silly.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My unreserved claim is that you should go about learning all parts of JavaScript, and where appropriate, use them! And if I may be so bold as to suggest: it's time to discard any JS books that tell you otherwise.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Title?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So what's the title of the series all about?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm not trying to insult you with criticism about your current lack of knowledge or understanding of JavaScript. I'm not suggesting you can't or won't be able to learn JavaScript. I'm not boasting about secret advanced insider wisdom that I and only a select few possess.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Seriously, all those were real reactions to the original series title before folks even read the books. And they're baseless.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The primary point of the title \"You Don't Know JS Yet\" is to point out that most JS developers don't take the time to really understand how the code that they write works. They know ", "type": "text"}, {"text": "that", "type": "text", "marks": [{"type": "italic"}]}, {"text": " it works\u2014that it produces a desired outcome. But they either don't understand exactly ", "type": "text"}, {"text": "how", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", or worse, they have an inaccurate mental model for the ", "type": "text"}, {"text": "how", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that falters on closer scrutiny.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm presenting a gentle but earnest challenge to you the reader, to set aside the assumptions you have about JS, and approach it with fresh eyes and an invigorated curiosity that leads you to ask ", "type": "text"}, {"text": "why", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for every line of code you write. Why does it do what it does? Why is one way better or more appropriate than the other half-dozen ways you could have accomplished it? Why do all the \"popular kids\" say to do X with your code, but it turns out that Y might be a better choice?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I added \"Yet\" to the title, not only because it's the second edition, but because ultimately I want these books to challenge you in a hopeful rather than discouraging way.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But let me be clear: I don't think it's possible to ever fully ", "type": "text"}, {"text": "know", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JS. That's not an achievement to be obtained, but a goal to strive after. You don't finish knowing everything about JS, you just keep learning more and more as you spend more time with the language. And the deeper you go, the more you revisit what you ", "type": "text"}, {"text": "knew", "type": "text", "marks": [{"type": "italic"}]}, {"text": " before, and you re-learn it from that more experienced perspective.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I encourage you to adopt a mindset around JavaScript, and indeed all of software development, that you will never fully have mastered it, but that you can and should keep working to get closer to that end, a journey that will stretch for the entirety of your software development career, and beyond.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You can always know JS better than you currently do. That's what I hope these YDKJSY books represent.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Mission", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The case doesn't really need to be made for why developers should take JS seriously\u2014I think it's already more than proven worthy of first-class status among the world's programming languages.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But a different, more important case still needs to be made, and these books rise to that challenge.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I've taught more than 5,000 developers from teams and companies all over the world, in more than 25 countries on six continents. And what I've seen is that far too often, what ", "type": "text"}, {"text": "counts", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is generally just the result of the program, not how the program is written or how/why it works.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My experience not only as a developer but in teaching many other developers tells me: you will always be more effective in your development work if you more completely understand how your code works than you are solely ", "type": "text"}, {"text": "just", "type": "text", "marks": [{"type": "italic"}]}, {"text": " getting it to produce a desired outcome.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, ", "type": "text"}, {"text": "good enough to work", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is not, and should not be, ", "type": "text"}, {"text": "good enough", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All developers regularly struggle with some piece of code not working correctly, and they can't figure out why. But far too often, JS developers will blame this on the language rather than admitting it's their own understanding that is falling short. These books serve as both the question and answer: why did it do ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and here's how to get it to do ", "type": "text"}, {"text": "that", "type": "text", "marks": [{"type": "italic"}]}, {"text": " instead.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My mission with YDKJSY is to empower every single JS developer to fully own the code they write, to understand it and to write with intention and clarity.", "type": "text"}]}, {"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Path", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some of you have started reading this book with the goal of completing all six books, back to back.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I would like to caution you to consider changing that plan.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It is not my intention that YDKJSY be read straight through. The material in these books is dense, because JavaScript is powerful, sophisticated, and in parts rather complex. Nobody can really hope to ", "type": "text"}, {"text": "download", "type": "text", "marks": [{"type": "italic"}]}, {"text": " all this information to their brains in a single pass and retain any significant amount of it. That's unreasonable, and it's foolish to try.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My suggestion is you take your time going through YDKJSY. Take one chapter, read it completely through start to finish, and then go back and re-read it section by section. Stop in between each section, and practice the code or ideas from that section. For larger concepts, it probably is a good idea to expect to spend several days digesting, re-reading, practicing, then digesting some more.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You could spend a week or two on each chapter, and a month or two on each book, and a year or more on the whole series, and you would still not be squeezing every ounce of YDKJSY out.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't binge these books; be patient and spread out your reading. Interleave reading with lots of practice on real code in your job or on projects you participate in. Wrestle with the opinions I've presented along the way, debate with others, and most of all, disagree with me! Run a study group or book club. Teach mini-workshops at your office. Write blog posts on what you've learned. Speak about these topics at local JS meetups.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's never my goal to convince you to agree with my opinion, but to encourage you to own and be able to defend your opinions. You can't get ", "type": "text"}, {"text": "there", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with an expedient read-through of these books. That's something that takes a long while to emerge, little by little, as you study and ponder and re-visit.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These books are meant to be a field-guide on your wanderings through JavaScript, from wherever you currently are with the language, to a place of deeper understanding. And the deeper you understand JS, the more questions you will ask and the more you will have to explore! That's what I find so exciting!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I'm so glad you're embarking on this journey, and I am so honored you would consider and consult these books along the way. It's time to start ", "type": "text"}, {"text": "getting to know JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Preface\n\nWelcome to the 2nd edition of the widely acclaimed You Don't Know JS (YDKJS) book series: You Don't Know JS Yet (YDKJSY).\n\nIf you've read any of the 1st edition books, you can expect a refreshed approach in these new ones, with plenty of updated coverage of what's changed in JS over the last five years. But what I hope and believe you'll still get is the same commitment to respecting JS and digging into what really makes it tick.\n\nIf this is your first time reading these books, I'm glad you're here. Prepare for a deep and extensive journey into all the corners of JavaScript.\n\nIf you are new to programming or JS, be aware that these books are not intended as a gentle \"intro to JavaScript.\" This material is, at times, complex and challenging, and goes much deeper than is typical for a first-time learner. You're welcome here no matter what your background is, but these books are written assuming you're already comfortable with JS and have at least 6\u20139 months experience with it.\n\nThe Parts\n\nThese books approach JavaScript intentionally opposite of how The Good Parts treats the language. No, that doesn't mean we're looking at the bad parts, but rather, exploring all the parts.\n\nYou may have been told, or felt yourself, that JS is a deeply flawed language that was poorly designed and inconsistently implemented. Many have asserted that it's the worst most popular language in the world; that nobody writes JS because they want to, only because they have to given its place at the center of the web. That's a ridiculous, unhealthy, and wholly condescending claim.\n\nMillions of developers write JavaScript every day, and many of them appreciate and respect the language.\n\nLike any great language, it has its brilliant parts as well as its scars. Even the creator of JavaScript himself, Brendan Eich, laments some of those parts as mistakes. But he's wrong: they weren't mistakes at all. JS is what it is today\u2014the world's most ubiquitous and thus most influential programming language\u2014precisely because of all those parts.\n\nDon't buy the lie that you should only learn and use a small collection of good parts while avoiding all the bad stuff. Don't buy the \"X is the new Y\" snake oil, that some new feature of the language instantly relegates all usage of a previous feature as obsolete and ignorant. Don't listen when someone says your code isn't \"modern\" because it isn't yet using a stage-0 feature that was only proposed a few weeks ago!\n\nEvery part of JS is useful. Some parts are more useful than others. Some parts require you to be more careful and intentional.\n\nI find it absurd to try to be a truly effective JavaScript developer while only using a small sliver of what the language has to offer. Can you imagine a construction worker with a toolbox full of tools, who only uses their hammer and scoffs at the screwdriver or tape measure as inferior? That's just silly.\n\nMy unreserved claim is that you should go about learning all parts of JavaScript, and where appropriate, use them! And if I may be so bold as to suggest: it's time to discard any JS books that tell you otherwise.\n\nThe Title?\n\nSo what's the title of the series all about?\n\nI'm not trying to insult you with criticism about your current lack of knowledge or understanding of JavaScript. I'm not suggesting you can't or won't be able to learn JavaScript. I'm not boasting about secret advanced insider wisdom that I and only a select few possess.\n\nSeriously, all those were real reactions to the original series title before folks even read the books. And they're baseless.\n\nThe primary point of the title \"You Don't Know JS Yet\" is to point out that most JS developers don't take the time to really understand how the code that they write works. They know that it works\u2014that it produces a desired outcome. But they either don't understand exactly how, or worse, they have an inaccurate mental model for the how that falters on closer scrutiny.\n\nI'm presenting a gentle but earnest challenge to you the reader, to set aside the assumptions you have about JS, and approach it with fresh eyes and an invigorated curiosity that leads you to ask why for every line of code you write. Why does it do what it does? Why is one way better or more appropriate than the other half-dozen ways you could have accomplished it? Why do all the \"popular kids\" say to do X with your code, but it turns out that Y might be a better choice?\n\nI added \"Yet\" to the title, not only because it's the second edition, but because ultimately I want these books to challenge you in a hopeful rather than discouraging way.\n\nBut let me be clear: I don't think it's possible to ever fully know JS. That's not an achievement to be obtained, but a goal to strive after. You don't finish knowing everything about JS, you just keep learning more and more as you spend more time with the language. And the deeper you go, the more you revisit what you knew before, and you re-learn it from that more experienced perspective.\n\nI encourage you to adopt a mindset around JavaScript, and indeed all of software development, that you will never fully have mastered it, but that you can and should keep working to get closer to that end, a journey that will stretch for the entirety of your software development career, and beyond.\n\nYou can always know JS better than you currently do. That's what I hope these YDKJSY books represent.\n\nThe Mission\n\nThe case doesn't really need to be made for why developers should take JS seriously\u2014I think it's already more than proven worthy of first-class status among the world's programming languages.\n\nBut a different, more important case still needs to be made, and these books rise to that challenge.\n\nI've taught more than 5,000 developers from teams and companies all over the world, in more than 25 countries on six continents. And what I've seen is that far too often, what counts is generally just the result of the program, not how the program is written or how/why it works.\n\nMy experience not only as a developer but in teaching many other developers tells me: you will always be more effective in your development work if you more completely understand how your code works than you are solely just getting it to produce a desired outcome.\n\nIn other words, good enough to work is not, and should not be, good enough.\n\nAll developers regularly struggle with some piece of code not working correctly, and they can't figure out why. But far too often, JS developers will blame this on the language rather than admitting it's their own understanding that is falling short. These books serve as both the question and answer: why did it do this, and here's how to get it to do that instead.\n\nMy mission with YDKJSY is to empower every single JS developer to fully own the code they write, to understand it and to write with intention and clarity.\n\nThe Path\n\nSome of you have started reading this book with the goal of completing all six books, back to back.\n\nI would like to caution you to consider changing that plan.\n\nIt is not my intention that YDKJSY be read straight through. The material in these books is dense, because JavaScript is powerful, sophisticated, and in parts rather complex. Nobody can really hope to download all this information to their brains in a single pass and retain any significant amount of it. That's unreasonable, and it's foolish to try.\n\nMy suggestion is you take your time going through YDKJSY. Take one chapter, read it completely through start to finish, and then go back and re-read it section by section. Stop in between each section, and practice the code or ideas from that section. For larger concepts, it probably is a good idea to expect to spend several days digesting, re-reading, practicing, then digesting some more.\n\nYou could spend a week or two on each chapter, and a month or two on each book, and a year or more on the whole series, and you would still not be squeezing every ounce of YDKJSY out.\n\nDon't binge these books; be patient and spread out your reading. Interleave reading with lots of practice on real code in your job or on projects you participate in. Wrestle with the opinions I've presented along the way, debate with others, and most of all, disagree with me! Run a study group or book club. Teach mini-workshops at your office. Write blog posts on what you've learned. Speak about these topics at local JS meetups.\n\nIt's never my goal to convince you to agree with my opinion, but to encourage you to own and be able to defend your opinions. You can't get there with an expedient read-through of these books. That's something that takes a long while to emerge, little by little, as you study and ponder and re-visit.\n\nThese books are meant to be a field-guide on your wanderings through JavaScript, from wherever you currently are with the language, to a place of deeper understanding. And the deeper you understand JS, the more questions you will ask and the more you will have to explore! That's what I find so exciting!\n\nI'm so glad you're embarking on this journey, and I am so honored you would consider and consult these books along the way. It's time to start getting to know JS."}, "id": 101}, {"data": {"uuid": "bbb5ce17-3c31-4152-af2e-a87067a45815", "user": 1, "title": "Chapter 1: What is Javascript?", "author": "Kyle Simpson", "created_on": "2023-06-05 20:12:08.899095+00:00", "updated_on": "2023-06-05 20:13:02.016823+00:00", "article_html": "<h1>Chapter 1: What <em>Is</em> JavaScript?</h1><p>You don't know JS, yet. Neither do I, not fully anyway. None of us do. But we can all start getting to know JS better.</p><p>In this first chapter of the first book of the <em>You Don't Know JS Yet</em> (YDKJSY) series, we will take some time to build a foundation to move forward on. We need to start by covering a variety of important background housekeeping details, clearing up some myths and misconceptions about what the language really is (and isn't!).</p><p>This is valuable insight into the identity and process of how JS is organized and maintained; all JS developers should understand it. If you want to get to know JS, this is how to <em>get started</em> taking the first steps in that journey.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 1: What ", "type": "text"}, {"text": "Is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JavaScript?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You don't know JS, yet. Neither do I, not fully anyway. None of us do. But we can all start getting to know JS better.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this first chapter of the first book of the ", "type": "text"}, {"text": "You Don't Know JS Yet", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (YDKJSY) series, we will take some time to build a foundation to move forward on. We need to start by covering a variety of important background housekeeping details, clearing up some myths and misconceptions about what the language really is (and isn't!).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is valuable insight into the identity and process of how JS is organized and maintained; all JS developers should understand it. If you want to get to know JS, this is how to ", "type": "text"}, {"text": "get started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " taking the first steps in that journey.", "type": "text"}]}]}, "article_text": "Chapter 1: What Is JavaScript?\r\n\r\nYou don't know JS, yet. Neither do I, not fully anyway. None of us do. But we can all start getting to know JS better.\r\n\r\nIn this first chapter of the first book of the You Don't Know JS Yet (YDKJSY) series, we will take some time to build a foundation to move forward on. We need to start by covering a variety of important background housekeeping details, clearing up some myths and misconceptions about what the language really is (and isn't!).\r\n\r\nThis is valuable insight into the identity and process of how JS is organized and maintained; all JS developers should understand it. If you want to get to know JS, this is how to get started taking the first steps in that journey."}, "id": 102, "children": [{"data": {"uuid": "77dad3a2-b292-4dda-bf4b-ac0731851e69", "user": 1, "title": "About this Book", "author": "Kyle Simpson", "created_on": "2023-06-05 20:13:21.583607+00:00", "updated_on": "2023-06-05 20:13:49.180399+00:00", "article_html": "<h2>About This Book</h2><p>I emphasize the word journey because <em>knowing JS</em> is not a destination, it's a direction. No matter how much time you spend with the language, you will always be able to find something else to learn and understand a little better. So don't look at this book as something to rush through for a quick achievement. Instead, patience and persistence are best as you take these first few steps.</p><p>Following this background chapter, the rest of the book lays out a high-level map of what you will find as you dig into and study JS with the YDKJSY books.</p><p>In particular, Chapter 4 identifies three main pillars around which the JS language is organized: scope/closures, prototypes/objects, and types/coercion. JS is a broad and sophisticated language, with many features and capabilities. But all of JS is founded on these three foundational pillars.</p><p>Keep in mind that even though this book is titled \"Get Started,\" it's <strong>not intended as a beginner/intro book</strong>. This book's main job is to get you ready for studying JS deeply throughout the rest of the series; it's written assuming you already have familiarity with JS over at least several months experience before moving on in YDKJSY. So to get the most out of <em>Get Started</em>, make sure you spend plenty of time writing JS code to build up your experience.</p><p>Even if you've already written a lot of JS before, this book should not be skimmed over or skipped; take your time to fully process the material here. <strong>A good start always depends on a solid first step.</strong></p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "About This Book", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I emphasize the word journey because ", "type": "text"}, {"text": "knowing JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is not a destination, it's a direction. No matter how much time you spend with the language, you will always be able to find something else to learn and understand a little better. So don't look at this book as something to rush through for a quick achievement. Instead, patience and persistence are best as you take these first few steps.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Following this background chapter, the rest of the book lays out a high-level map of what you will find as you dig into and study JS with the YDKJSY books.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In particular, Chapter 4 identifies three main pillars around which the JS language is organized: scope/closures, prototypes/objects, and types/coercion. JS is a broad and sophisticated language, with many features and capabilities. But all of JS is founded on these three foundational pillars.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Keep in mind that even though this book is titled \"Get Started,\" it's ", "type": "text"}, {"text": "not intended as a beginner/intro book", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". This book's main job is to get you ready for studying JS deeply throughout the rest of the series; it's written assuming you already have familiarity with JS over at least several months experience before moving on in YDKJSY. So to get the most out of ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", make sure you spend plenty of time writing JS code to build up your experience.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even if you've already written a lot of JS before, this book should not be skimmed over or skipped; take your time to fully process the material here. ", "type": "text"}, {"text": "A good start always depends on a solid first step.", "type": "text", "marks": [{"type": "bold"}]}]}]}, "article_text": "About This Book\n\nI emphasize the word journey because knowing JS is not a destination, it's a direction. No matter how much time you spend with the language, you will always be able to find something else to learn and understand a little better. So don't look at this book as something to rush through for a quick achievement. Instead, patience and persistence are best as you take these first few steps.\n\nFollowing this background chapter, the rest of the book lays out a high-level map of what you will find as you dig into and study JS with the YDKJSY books.\n\nIn particular, Chapter 4 identifies three main pillars around which the JS language is organized: scope/closures, prototypes/objects, and types/coercion. JS is a broad and sophisticated language, with many features and capabilities. But all of JS is founded on these three foundational pillars.\n\nKeep in mind that even though this book is titled \"Get Started,\" it's not intended as a beginner/intro book. This book's main job is to get you ready for studying JS deeply throughout the rest of the series; it's written assuming you already have familiarity with JS over at least several months experience before moving on in YDKJSY. So to get the most out of Get Started, make sure you spend plenty of time writing JS code to build up your experience.\n\nEven if you've already written a lot of JS before, this book should not be skimmed over or skipped; take your time to fully process the material here. A good start always depends on a solid first step."}, "id": 103}, {"data": {"uuid": "71ab2a62-3554-4fa9-84a3-3867a8a81711", "user": 1, "title": "What's With That Name?", "author": "Kyle Simpson", "created_on": "2023-06-05 20:15:24.914410+00:00", "updated_on": "2023-06-06 20:18:55.095734+00:00", "article_html": "<h2>What's With That Name?</h2><p>The name JavaScript is probably the most mistaken and misunderstood programming language name.</p><p>Is this language related to Java? Is it only the script form for Java? Is it only for writing scripts and not real programs?</p><p>The truth is, the name JavaScript is an artifact of marketing shenanigans. When Brendan Eich first conceived of the language, he code-named it Mocha. Internally at Netscape, the brand LiveScript was used. But when it came time to publicly name the language, \"JavaScript\" won the vote.</p><p>Why? Because this language was originally designed to appeal to an audience of mostly Java programmers, and because the word \"script\" was popular at the time to refer to lightweight programs. These lightweight \"scripts\" would be the first ones to embed inside of pages on this new thing called the web!</p><p>In other words, JavaScript was a marketing ploy to try to position this language as a palatable alternative to writing the heavier and more well-known Java of the day. It could just as easily have been called \"WebJava,\" for that matter.</p><p>There are some superficial resemblances between JavaScript's code and Java code. Those similarities don't particularly come from shared development, but from both languages targeting developers with assumed syntax expectations from C (and to an extent, C++).</p><p>For example, we use the <code>{</code> to begin a block of code and the <code>}</code> to end that block of code, just like C/C++ and Java. We also use the <code>;</code> to punctuate the end of a statement.</p><p>In some ways, legal relationships run even deeper than the syntax. Oracle (via Sun), the company that still owns and runs Java, also owns the official trademark for the name \"JavaScript\" (via Netscape). This trademark is almost never enforced, and likely couldn't be at this point.</p><p>For these reasons, some have suggested we use JS instead of JavaScript. That is a very common shorthand, if not a good candidate for an official language branding itself. Indeed, these books use JS almost exclusively to refer to the language.</p><p>Further distancing the language from the Oracle-owned trademark, the official name of the language specified by TC39 and formalized by the ECMA standards body is <strong>ECMAScript</strong>. And indeed, since 2016, the official language name has also been suffixed by the revision year; as of this writing, that's ECMAScript 2019, or otherwise abbreviated ES2019.</p><p>In other words, the JavaScript/JS that runs in your browser or in Node.js, is <em>an</em> implementation of the ES2019 standard.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>Note</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Don't use terms like \"JS6\" or \"ES8\" to refer to the language. Some do, but those terms only serve to perpetuate confusion. \"ES20xx\" or just \"JS\" are what you should stick to.</p></td></tr></tbody></table><p>Whether you call it JavaScript, JS, ECMAScript, or ES2019, it's most definitely not a variant of the Java language!</p><blockquote><p>\"Java is to JavaScript as ham is to hamster.\" --Jeremy Keith, 2009</p></blockquote>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "What's With That Name?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The name JavaScript is probably the most mistaken and misunderstood programming language name.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Is this language related to Java? Is it only the script form for Java? Is it only for writing scripts and not real programs?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The truth is, the name JavaScript is an artifact of marketing shenanigans. When Brendan Eich first conceived of the language, he code-named it Mocha. Internally at Netscape, the brand LiveScript was used. But when it came time to publicly name the language, \"JavaScript\" won the vote.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why? Because this language was originally designed to appeal to an audience of mostly Java programmers, and because the word \"script\" was popular at the time to refer to lightweight programs. These lightweight \"scripts\" would be the first ones to embed inside of pages on this new thing called the web!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, JavaScript was a marketing ploy to try to position this language as a palatable alternative to writing the heavier and more well-known Java of the day. It could just as easily have been called \"WebJava,\" for that matter.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are some superficial resemblances between JavaScript's code and Java code. Those similarities don't particularly come from shared development, but from both languages targeting developers with assumed syntax expectations from C (and to an extent, C++).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, we use the ", "type": "text"}, {"text": "{", "type": "text", "marks": [{"type": "code"}]}, {"text": " to begin a block of code and the ", "type": "text"}, {"text": "}", "type": "text", "marks": [{"type": "code"}]}, {"text": " to end that block of code, just like C/C++ and Java. We also use the ", "type": "text"}, {"text": ";", "type": "text", "marks": [{"type": "code"}]}, {"text": " to punctuate the end of a statement.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In some ways, legal relationships run even deeper than the syntax. Oracle (via Sun), the company that still owns and runs Java, also owns the official trademark for the name \"JavaScript\" (via Netscape). This trademark is almost never enforced, and likely couldn't be at this point.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For these reasons, some have suggested we use JS instead of JavaScript. That is a very common shorthand, if not a good candidate for an official language branding itself. Indeed, these books use JS almost exclusively to refer to the language.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Further distancing the language from the Oracle-owned trademark, the official name of the language specified by TC39 and formalized by the ECMA standards body is ", "type": "text"}, {"text": "ECMAScript", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". And indeed, since 2016, the official language name has also been suffixed by the revision year; as of this writing, that's ECMAScript 2019, or otherwise abbreviated ES2019.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, the JavaScript/JS that runs in your browser or in Node.js, is ", "type": "text"}, {"text": "an", "type": "text", "marks": [{"type": "italic"}]}, {"text": " implementation of the ES2019 standard.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Note", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Don't use terms like \"JS6\" or \"ES8\" to refer to the language. Some do, but those terms only serve to perpetuate confusion. \"ES20xx\" or just \"JS\" are what you should stick to.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Whether you call it JavaScript, JS, ECMAScript, or ES2019, it's most definitely not a variant of the Java language!", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "\"Java is to JavaScript as ham is to hamster.\" --Jeremy Keith, 2009", "type": "text"}]}]}]}, "article_text": "What's With That Name?\r\n\r\nThe name JavaScript is probably the most mistaken and misunderstood programming language name.\r\n\r\nIs this language related to Java? Is it only the script form for Java? Is it only for writing scripts and not real programs?\r\n\r\nThe truth is, the name JavaScript is an artifact of marketing shenanigans. When Brendan Eich first conceived of the language, he code-named it Mocha. Internally at Netscape, the brand LiveScript was used. But when it came time to publicly name the language, \"JavaScript\" won the vote.\r\n\r\nWhy? Because this language was originally designed to appeal to an audience of mostly Java programmers, and because the word \"script\" was popular at the time to refer to lightweight programs. These lightweight \"scripts\" would be the first ones to embed inside of pages on this new thing called the web!\r\n\r\nIn other words, JavaScript was a marketing ploy to try to position this language as a palatable alternative to writing the heavier and more well-known Java of the day. It could just as easily have been called \"WebJava,\" for that matter.\r\n\r\nThere are some superficial resemblances between JavaScript's code and Java code. Those similarities don't particularly come from shared development, but from both languages targeting developers with assumed syntax expectations from C (and to an extent, C++).\r\n\r\nFor example, we use the { to begin a block of code and the } to end that block of code, just like C/C++ and Java. We also use the ; to punctuate the end of a statement.\r\n\r\nIn some ways, legal relationships run even deeper than the syntax. Oracle (via Sun), the company that still owns and runs Java, also owns the official trademark for the name \"JavaScript\" (via Netscape). This trademark is almost never enforced, and likely couldn't be at this point.\r\n\r\nFor these reasons, some have suggested we use JS instead of JavaScript. That is a very common shorthand, if not a good candidate for an official language branding itself. Indeed, these books use JS almost exclusively to refer to the language.\r\n\r\nFurther distancing the language from the Oracle-owned trademark, the official name of the language specified by TC39 and formalized by the ECMA standards body is ECMAScript. And indeed, since 2016, the official language name has also been suffixed by the revision year; as of this writing, that's ECMAScript 2019, or otherwise abbreviated ES2019.\r\n\r\nIn other words, the JavaScript/JS that runs in your browser or in Node.js, is an implementation of the ES2019 standard.\r\n\r\nNote\r\n\r\nDon't use terms like \"JS6\" or \"ES8\" to refer to the language. Some do, but those terms only serve to perpetuate confusion. \"ES20xx\" or just \"JS\" are what you should stick to.\r\n\r\nWhether you call it JavaScript, JS, ECMAScript, or ES2019, it's most definitely not a variant of the Java language!\r\n\r\n\"Java is to JavaScript as ham is to hamster.\" --Jeremy Keith, 2009"}, "id": 104}, {"data": {"uuid": "9bcd5942-13d2-4816-b730-deb59335f45f", "user": 1, "title": "Language Specification", "author": "Kyle Simpson", "created_on": "2023-06-05 21:03:34.729307+00:00", "updated_on": "2023-06-05 21:07:48.651674+00:00", "article_html": "<h2>Language Specification</h2><p>I mentioned TC39, the technical steering committee that manages JS. Their primary task is managing the official specification for the language. They meet regularly to vote on any agreed changes, which they then submit to ECMA, the standards organization.</p><p>JS's syntax and behavior are defined in the ES specification.</p><p>ES2019 happens to be the 10th major numbered specification/revision since JS's inception in 1995, so in the specification's official URL as hosted by ECMA, you'll find \"10.0\":</p><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://www.ecma-international.org/ecma-262/10.0/\">https://www.ecma-international.org/ecma-262/10.0/</a></p><p>The TC39 committee is comprised of between 50 and about 100 different people from a broad section of web-invested companies, such as browser makers (Mozilla, Google, Apple) and device makers (Samsung, etc). All members of the committee are volunteers, though many of them are employees of these companies and so may receive compensation in part for their duties on the committee.</p><p>TC39 meets generally about every other month, usually for about three days, to review work done by members since the last meeting, discuss issues, and vote on proposals. Meeting locations rotate among member companies willing to host.</p><p>All TC39 proposals progress through a five-stage process\u2014of course, since we're programmers, it's 0-based!\u2014Stage 0 through Stage 4. You can read more about the Stage process here: <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://tc39.es/process-document/\">https://tc39.es/process-document/</a></p><p>Stage 0 means roughly, someone on TC39 thinks it's a worthy idea and plans to champion and work on it. That means lots of ideas that non-TC39 members \"propose,\" through informal means such as social media or blog posts, are really \"pre-stage 0.\" You have to get a TC39 member to champion a proposal for it to be considered \"Stage 0\" officially.</p><p>Once a proposal reaches \"Stage 4\" status, it is eligible to be included in the next yearly revision of the language. It can take anywhere from several months to a few years for a proposal to work its way through these stages.</p><p>All proposals are managed in the open, on TC39's Github repository: <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/tc39/proposals\">https://github.com/tc39/proposals</a></p><p>Anyone, whether on TC39 or not, is welcome to participate in these public discussions and the processes for working on the proposals. However, only TC39 members can attend meetings and vote on the proposals and changes. So in effect, the voice of a TC39 member carries a lot of weight in where JS will go.</p><p>Contrary to some established and frustratingly perpetuated myth, there are <em>not</em> multiple versions of JavaScript in the wild. There's just <strong>one JS</strong>, the official standard as maintained by TC39 and ECMA.</p><p>Back in the early 2000s, when Microsoft maintained a forked and reverse-engineered (and not entirely compatible) version of JS called \"JScript,\" there were legitimately \"multiple versions\" of JS. But those days are long gone. It's outdated and inaccurate to make such claims about JS today.</p><p>All major browsers and device makers have committed to keeping their JS implementations compliant with this one central specification. Of course, engines implement features at different times. But it should never be the case that the v8 engine (Chrome's JS engine) implements a specified feature differently or incompatibly as compared to the SpiderMonkey engine (Mozilla's JS engine).</p><p>That means you can learn <strong>one JS</strong>, and rely on that same JS everywhere.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Language Specification", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I mentioned TC39, the technical steering committee that manages JS. Their primary task is managing the official specification for the language. They meet regularly to vote on any agreed changes, which they then submit to ECMA, the standards organization.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS's syntax and behavior are defined in the ES specification.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES2019 happens to be the 10th major numbered specification/revision since JS's inception in 1995, so in the specification's official URL as hosted by ECMA, you'll find \"10.0\":", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "https://www.ecma-international.org/ecma-262/10.0/", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://www.ecma-international.org/ecma-262/10.0/", "class": null, "target": "_blank"}}]}]}, {"type": "paragraph", "content": [{"text": "The TC39 committee is comprised of between 50 and about 100 different people from a broad section of web-invested companies, such as browser makers (Mozilla, Google, Apple) and device makers (Samsung, etc). All members of the committee are volunteers, though many of them are employees of these companies and so may receive compensation in part for their duties on the committee.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "TC39 meets generally about every other month, usually for about three days, to review work done by members since the last meeting, discuss issues, and vote on proposals. Meeting locations rotate among member companies willing to host.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All TC39 proposals progress through a five-stage process\u2014of course, since we're programmers, it's 0-based!\u2014Stage 0 through Stage 4. You can read more about the Stage process here: ", "type": "text"}, {"text": "https://tc39.es/process-document/", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://tc39.es/process-document/", "class": null, "target": "_blank"}}]}]}, {"type": "paragraph", "content": [{"text": "Stage 0 means roughly, someone on TC39 thinks it's a worthy idea and plans to champion and work on it. That means lots of ideas that non-TC39 members \"propose,\" through informal means such as social media or blog posts, are really \"pre-stage 0.\" You have to get a TC39 member to champion a proposal for it to be considered \"Stage 0\" officially.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Once a proposal reaches \"Stage 4\" status, it is eligible to be included in the next yearly revision of the language. It can take anywhere from several months to a few years for a proposal to work its way through these stages.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All proposals are managed in the open, on TC39's Github repository: ", "type": "text"}, {"text": "https://github.com/tc39/proposals", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://github.com/tc39/proposals", "class": null, "target": "_blank"}}]}]}, {"type": "paragraph", "content": [{"text": "Anyone, whether on TC39 or not, is welcome to participate in these public discussions and the processes for working on the proposals. However, only TC39 members can attend meetings and vote on the proposals and changes. So in effect, the voice of a TC39 member carries a lot of weight in where JS will go.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Contrary to some established and frustratingly perpetuated myth, there are ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " multiple versions of JavaScript in the wild. There's just ", "type": "text"}, {"text": "one JS", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", the official standard as maintained by TC39 and ECMA.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Back in the early 2000s, when Microsoft maintained a forked and reverse-engineered (and not entirely compatible) version of JS called \"JScript,\" there were legitimately \"multiple versions\" of JS. But those days are long gone. It's outdated and inaccurate to make such claims about JS today.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All major browsers and device makers have committed to keeping their JS implementations compliant with this one central specification. Of course, engines implement features at different times. But it should never be the case that the v8 engine (Chrome's JS engine) implements a specified feature differently or incompatibly as compared to the SpiderMonkey engine (Mozilla's JS engine).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That means you can learn ", "type": "text"}, {"text": "one JS", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", and rely on that same JS everywhere.", "type": "text"}]}]}, "article_text": "Language Specification\r\n\r\nI mentioned TC39, the technical steering committee that manages JS. Their primary task is managing the official specification for the language. They meet regularly to vote on any agreed changes, which they then submit to ECMA, the standards organization.\r\n\r\nJS's syntax and behavior are defined in the ES specification.\r\n\r\nES2019 happens to be the 10th major numbered specification/revision since JS's inception in 1995, so in the specification's official URL as hosted by ECMA, you'll find \"10.0\":\r\n\r\nhttps://www.ecma-international.org/ecma-262/10.0/\r\n\r\nThe TC39 committee is comprised of between 50 and about 100 different people from a broad section of web-invested companies, such as browser makers (Mozilla, Google, Apple) and device makers (Samsung, etc). All members of the committee are volunteers, though many of them are employees of these companies and so may receive compensation in part for their duties on the committee.\r\n\r\nTC39 meets generally about every other month, usually for about three days, to review work done by members since the last meeting, discuss issues, and vote on proposals. Meeting locations rotate among member companies willing to host.\r\n\r\nAll TC39 proposals progress through a five-stage process\u2014of course, since we're programmers, it's 0-based!\u2014Stage 0 through Stage 4. You can read more about the Stage process here: https://tc39.es/process-document/\r\n\r\nStage 0 means roughly, someone on TC39 thinks it's a worthy idea and plans to champion and work on it. That means lots of ideas that non-TC39 members \"propose,\" through informal means such as social media or blog posts, are really \"pre-stage 0.\" You have to get a TC39 member to champion a proposal for it to be considered \"Stage 0\" officially.\r\n\r\nOnce a proposal reaches \"Stage 4\" status, it is eligible to be included in the next yearly revision of the language. It can take anywhere from several months to a few years for a proposal to work its way through these stages.\r\n\r\nAll proposals are managed in the open, on TC39's Github repository: https://github.com/tc39/proposals\r\n\r\nAnyone, whether on TC39 or not, is welcome to participate in these public discussions and the processes for working on the proposals. However, only TC39 members can attend meetings and vote on the proposals and changes. So in effect, the voice of a TC39 member carries a lot of weight in where JS will go.\r\n\r\nContrary to some established and frustratingly perpetuated myth, there are not multiple versions of JavaScript in the wild. There's just one JS, the official standard as maintained by TC39 and ECMA.\r\n\r\nBack in the early 2000s, when Microsoft maintained a forked and reverse-engineered (and not entirely compatible) version of JS called \"JScript,\" there were legitimately \"multiple versions\" of JS. But those days are long gone. It's outdated and inaccurate to make such claims about JS today.\r\n\r\nAll major browsers and device makers have committed to keeping their JS implementations compliant with this one central specification. Of course, engines implement features at different times. But it should never be the case that the v8 engine (Chrome's JS engine) implements a specified feature differently or incompatibly as compared to the SpiderMonkey engine (Mozilla's JS engine).\r\n\r\nThat means you can learn one JS, and rely on that same JS everywhere."}, "id": 105, "children": [{"data": {"uuid": "9c3b032c-2676-4839-8fda-672619d74d14", "user": 1, "title": "The Web Rules Everything About (JS)", "author": "Kyle Simpson", "created_on": "2023-06-05 21:07:08.341304+00:00", "updated_on": "2023-06-05 21:15:11.718288+00:00", "article_html": "<h3>The Web Rules Everything About (JS)</h3><p>While the array of environments that run JS is constantly expanding (from browsers, to servers (Node.js), to robots, to lightbulbs, to...), the one environment that rules JS is the web. In other words, how JS is implemented for web browsers is, in all practicality, the only reality that matters.</p><p>For the most part, the JS defined in the specification and the JS that runs in browser-based JS engines is the same. But there are some differences that must be considered.</p><p>Sometimes the JS specification will dictate some new or refined behavior, and yet that won't exactly match with how it works in browser-based JS engines. Such a mismatch is historical: JS engines have had 20+ years of observable behaviors around corner cases of features that have come to be relied on by web content. As such, sometimes the JS engines will refuse to conform to a specification-dictated change because it would break that web content.</p><p>In these cases, often TC39 will backtrack and simply choose to conform the specification to the reality of the web. For example, TC39 planned to add a <code>contains(..)</code> method for Arrays, but it was found that this name conflicted with old JS frameworks still in use on some sites, so they changed the name to a non-conflicting <code>includes(..)</code>. The same happened with a comedic/tragic JS <em>community crisis</em> dubbed \"smooshgate,\" where the planned <code>flatten(..)</code> method was eventually renamed <code>flat(..)</code>.</p><p>But occasionally, TC39 will decide the specification should stick firm on some point even though it is unlikely that browser-based JS engines will ever conform.</p><p>The solution? Appendix B, \"Additional ECMAScript Features for Web Browsers\".<sup>[1]</sup> The JS specification includes this appendix to detail out any known mismatches between the official JS specification and the reality of JS on the web. In other words, these are exceptions that are allowed <em>only</em> for web JS; other JS environments must stick to the letter of the law.</p><p>Section B.1 and B.2 cover <em>additions</em> to JS (syntax and APIs) that web JS includes, again for historical reasons, but which TC39 does not plan to formally specify in the core of JS. Examples include <code>0</code>-prefixed octal literals, the global <code>escape(..)</code> / <code>unescape(..)</code> utilities, String \"helpers\" like <code>anchor(..)</code> and <code>blink()</code>, and the RegExp <code>compile(..)</code> method.</p><p>Section B.3 includes some conflicts where code may run in both web and non-web JS engines, but where the behavior <em>could</em> be observably different, resulting in different outcomes. Most of the listed changes involve situations that are labeled as early errors when code is running in strict mode.</p><p>Appendix B <em>gotchas</em> aren't encountered very often, but it's still a good idea to avoid these constructs to be future safe. Wherever possible, adhere to the JS specification and don't rely on behavior that's only applicable in certain JS engine environments.</p><p><sup>[1]</sup> ECMAScript 2019 Language Specification, Appendix B: Additional ECMAScript Features for Web Browsers, <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers\">https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers</a> (latest as of time of this writing in January 2020)</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "The Web Rules Everything About (JS)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "While the array of environments that run JS is constantly expanding (from browsers, to servers (Node.js), to robots, to lightbulbs, to...), the one environment that rules JS is the web. In other words, how JS is implemented for web browsers is, in all practicality, the only reality that matters.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For the most part, the JS defined in the specification and the JS that runs in browser-based JS engines is the same. But there are some differences that must be considered.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Sometimes the JS specification will dictate some new or refined behavior, and yet that won't exactly match with how it works in browser-based JS engines. Such a mismatch is historical: JS engines have had 20+ years of observable behaviors around corner cases of features that have come to be relied on by web content. As such, sometimes the JS engines will refuse to conform to a specification-dictated change because it would break that web content.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In these cases, often TC39 will backtrack and simply choose to conform the specification to the reality of the web. For example, TC39 planned to add a ", "type": "text"}, {"text": "contains(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method for Arrays, but it was found that this name conflicted with old JS frameworks still in use on some sites, so they changed the name to a non-conflicting ", "type": "text"}, {"text": "includes(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The same happened with a comedic/tragic JS ", "type": "text"}, {"text": "community crisis", "type": "text", "marks": [{"type": "italic"}]}, {"text": " dubbed \"smooshgate,\" where the planned ", "type": "text"}, {"text": "flatten(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method was eventually renamed ", "type": "text"}, {"text": "flat(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But occasionally, TC39 will decide the specification should stick firm on some point even though it is unlikely that browser-based JS engines will ever conform.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The solution? Appendix B, \"Additional ECMAScript Features for Web Browsers\".", "type": "text"}, {"text": "[1]", "type": "text", "marks": [{"type": "superscript"}]}, {"text": " The JS specification includes this appendix to detail out any known mismatches between the official JS specification and the reality of JS on the web. In other words, these are exceptions that are allowed ", "type": "text"}, {"text": "only", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for web JS; other JS environments must stick to the letter of the law.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Section B.1 and B.2 cover ", "type": "text"}, {"text": "additions", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to JS (syntax and APIs) that web JS includes, again for historical reasons, but which TC39 does not plan to formally specify in the core of JS. Examples include ", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": "-prefixed octal literals, the global ", "type": "text"}, {"text": "escape(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "unescape(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utilities, String \"helpers\" like ", "type": "text"}, {"text": "anchor(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "blink()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and the RegExp ", "type": "text"}, {"text": "compile(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Section B.3 includes some conflicts where code may run in both web and non-web JS engines, but where the behavior ", "type": "text"}, {"text": "could", "type": "text", "marks": [{"type": "italic"}]}, {"text": " be observably different, resulting in different outcomes. Most of the listed changes involve situations that are labeled as early errors when code is running in strict mode.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Appendix B ", "type": "text"}, {"text": "gotchas", "type": "text", "marks": [{"type": "italic"}]}, {"text": " aren't encountered very often, but it's still a good idea to avoid these constructs to be future safe. Wherever possible, adhere to the JS specification and don't rely on behavior that's only applicable in certain JS engine environments.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "[1]", "type": "text", "marks": [{"type": "superscript"}]}, {"text": " ECMAScript 2019 Language Specification, Appendix B: Additional ECMAScript Features for Web Browsers, ", "type": "text"}, {"text": "https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers", "class": null, "target": "_blank"}}]}, {"text": " (latest as of time of this writing in January 2020)", "type": "text"}]}]}, "article_text": "The Web Rules Everything About (JS)\n\nWhile the array of environments that run JS is constantly expanding (from browsers, to servers (Node.js), to robots, to lightbulbs, to...), the one environment that rules JS is the web. In other words, how JS is implemented for web browsers is, in all practicality, the only reality that matters.\n\nFor the most part, the JS defined in the specification and the JS that runs in browser-based JS engines is the same. But there are some differences that must be considered.\n\nSometimes the JS specification will dictate some new or refined behavior, and yet that won't exactly match with how it works in browser-based JS engines. Such a mismatch is historical: JS engines have had 20+ years of observable behaviors around corner cases of features that have come to be relied on by web content. As such, sometimes the JS engines will refuse to conform to a specification-dictated change because it would break that web content.\n\nIn these cases, often TC39 will backtrack and simply choose to conform the specification to the reality of the web. For example, TC39 planned to add a contains(..) method for Arrays, but it was found that this name conflicted with old JS frameworks still in use on some sites, so they changed the name to a non-conflicting includes(..). The same happened with a comedic/tragic JS community crisis dubbed \"smooshgate,\" where the planned flatten(..) method was eventually renamed flat(..).\n\nBut occasionally, TC39 will decide the specification should stick firm on some point even though it is unlikely that browser-based JS engines will ever conform.\n\nThe solution? Appendix B, \"Additional ECMAScript Features for Web Browsers\".[1] The JS specification includes this appendix to detail out any known mismatches between the official JS specification and the reality of JS on the web. In other words, these are exceptions that are allowed only for web JS; other JS environments must stick to the letter of the law.\n\nSection B.1 and B.2 cover additions to JS (syntax and APIs) that web JS includes, again for historical reasons, but which TC39 does not plan to formally specify in the core of JS. Examples include 0-prefixed octal literals, the global escape(..) / unescape(..) utilities, String \"helpers\" like anchor(..) and blink(), and the RegExp compile(..) method.\n\nSection B.3 includes some conflicts where code may run in both web and non-web JS engines, but where the behavior could be observably different, resulting in different outcomes. Most of the listed changes involve situations that are labeled as early errors when code is running in strict mode.\n\nAppendix B gotchas aren't encountered very often, but it's still a good idea to avoid these constructs to be future safe. Wherever possible, adhere to the JS specification and don't rely on behavior that's only applicable in certain JS engine environments.\n\n[1] ECMAScript 2019 Language Specification, Appendix B: Additional ECMAScript Features for Web Browsers, https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers (latest as of time of this writing in January 2020)"}, "id": 106}, {"data": {"uuid": "36cd1985-ba9d-4d08-9a02-2b22fbc33feb", "user": 1, "title": "Not All (Web) JS...", "author": "Kyle Simpson", "created_on": "2023-06-05 21:16:45.073361+00:00", "updated_on": "2023-06-07 13:50:24.846908+00:00", "article_html": "<h3>Not All (Web) JS...</h3><p>Is this code a JS program?</p><pre><code class=\"language-js\">alert(\"Hello, JS!\");</code></pre><p>Depends on how you look at things. The <code>alert(..)</code> function shown here is not included in the JS specification, but it <em>is</em> in all web JS environments. Yet, you won't find it in Appendix B, so what gives?</p><p>Various JS environments (like browser JS engines, Node.js, etc.) add APIs into the global scope of your JS programs that give you environment-specific capabilities, like being able to pop an alert-style box in the user's browser.</p><p>In fact, a wide range of JS-looking APIs, like <code>fetch(..)</code>, <code>getCurrentLocation(..)</code>, and <code>getUserMedia(..)</code>, are all web APIs that look like JS. In Node.js, we can access hundreds of API methods from various built-in modules, like <code>fs.write(..)</code>.</p><p>Another common example is <code>console.log(..)</code> (and all the other <code>console.*</code> methods!). These are not specified in JS, but because of their universal utility are defined by pretty much every JS environment, according to a roughly agreed consensus.</p><p>So <code>alert(..)</code> and <code>console.log(..)</code> are not defined by JS. But they <em>look</em> like JS. They are functions and object methods and they obey JS syntax rules. The behaviors behind them are controlled by the environment running the JS engine, but on the surface they definitely have to abide by JS to be able to play in the JS playground.</p><p>Most of the cross-browser differences people complain about with \"JS is so inconsistent!\" claims are actually due to differences in how those environment behaviors work, not in how the JS itself works.</p><p>So an <code>alert(..)</code> call <em>is</em> JS, but <code>alert</code> itself is really just a guest, not part of the official JS specification.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Not All (Web) JS...", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Is this code a JS program?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": "js"}, "content": [{"text": "alert(\"Hello, JS!\");", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Depends on how you look at things. The ", "type": "text"}, {"text": "alert(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function shown here is not included in the JS specification, but it ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in all web JS environments. Yet, you won't find it in Appendix B, so what gives?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Various JS environments (like browser JS engines, Node.js, etc.) add APIs into the global scope of your JS programs that give you environment-specific capabilities, like being able to pop an alert-style box in the user's browser.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In fact, a wide range of JS-looking APIs, like ", "type": "text"}, {"text": "fetch(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "getCurrentLocation(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "getUserMedia(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", are all web APIs that look like JS. In Node.js, we can access hundreds of API methods from various built-in modules, like ", "type": "text"}, {"text": "fs.write(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another common example is ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and all the other ", "type": "text"}, {"text": "console.*", "type": "text", "marks": [{"type": "code"}]}, {"text": " methods!). These are not specified in JS, but because of their universal utility are defined by pretty much every JS environment, according to a roughly agreed consensus.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So ", "type": "text"}, {"text": "alert(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "console.log(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " are not defined by JS. But they ", "type": "text"}, {"text": "look", "type": "text", "marks": [{"type": "italic"}]}, {"text": " like JS. They are functions and object methods and they obey JS syntax rules. The behaviors behind them are controlled by the environment running the JS engine, but on the surface they definitely have to abide by JS to be able to play in the JS playground.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Most of the cross-browser differences people complain about with \"JS is so inconsistent!\" claims are actually due to differences in how those environment behaviors work, not in how the JS itself works.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So an ", "type": "text"}, {"text": "alert(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call ", "type": "text"}, {"text": "is", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JS, but ", "type": "text"}, {"text": "alert", "type": "text", "marks": [{"type": "code"}]}, {"text": " itself is really just a guest, not part of the official JS specification.", "type": "text"}]}]}, "article_text": "Not All (Web) JS...\n\nIs this code a JS program?\n\nalert(\"Hello, JS!\");\n\nDepends on how you look at things. The alert(..) function shown here is not included in the JS specification, but it is in all web JS environments. Yet, you won't find it in Appendix B, so what gives?\n\nVarious JS environments (like browser JS engines, Node.js, etc.) add APIs into the global scope of your JS programs that give you environment-specific capabilities, like being able to pop an alert-style box in the user's browser.\n\nIn fact, a wide range of JS-looking APIs, like fetch(..), getCurrentLocation(..), and getUserMedia(..), are all web APIs that look like JS. In Node.js, we can access hundreds of API methods from various built-in modules, like fs.write(..).\n\nAnother common example is console.log(..) (and all the other console.* methods!). These are not specified in JS, but because of their universal utility are defined by pretty much every JS environment, according to a roughly agreed consensus.\n\nSo alert(..) and console.log(..) are not defined by JS. But they look like JS. They are functions and object methods and they obey JS syntax rules. The behaviors behind them are controlled by the environment running the JS engine, but on the surface they definitely have to abide by JS to be able to play in the JS playground.\n\nMost of the cross-browser differences people complain about with \"JS is so inconsistent!\" claims are actually due to differences in how those environment behaviors work, not in how the JS itself works.\n\nSo an alert(..) call is JS, but alert itself is really just a guest, not part of the official JS specification."}, "id": 107}, {"data": {"uuid": "e575d4ff-2980-4a92-89d4-f925b8c8420f", "user": 1, "title": "It's Not Always JS", "author": "Kyle Simpson", "created_on": "2023-06-06 02:37:36.475197+00:00", "updated_on": "2023-06-06 02:42:44.491104+00:00", "article_html": "<h3>It's Not Always JS</h3><p>Using the console/REPL (Read-Evaluate-Print-Loop) in your browser's Developer Tools (or Node) feels like a pretty straightforward JS environment at first glance. But it's not, really.</p><p>Developer Tools are... tools for developers. Their primary purpose is to make life easier for developers. They prioritize DX (Developer Experience). It is <em>not</em> a goal of such tools to accurately and purely reflect all nuances of strict-spec JS behavior. As such, there's many quirks that may act as \"gotchas\" if you're treating the console as a <em>pure</em> JS environment.</p><p>This convenience is a good thing, by the way! I'm glad Developer Tools make developers' lives easier! I'm glad we have nice UX charms like auto-complete of variables/properties, etc. I'm just pointing out that we can't and shouldn't expect such tools to <em>always</em> adhere strictly to the way JS programs are handled, because that's not the purpose of these tools.</p><p>Since such tools vary in behavior from browser to browser, and since they change (sometimes rather frequently), I'm not going to \"hardcode\" any of the specific details into this text, thereby ensuring this book text is outdated quickly.</p><p>But I'll just hint at some examples of quirks that have been true at various points in different JS console environments, to reinforce my point about not assuming native JS behavior while using them:</p><p>* Whether a <code>var</code> or <code>function</code> declaration in the top-level \"global scope\" of the console actually creates a real global variable (and mirrored <code>window</code> property, and vice versa!).</p><p>* What happens with multiple <code>let</code> and <code>const</code> declarations in the top-level \"global scope.\"</p><p>* Whether <code>\"use strict\";</code> on one line-entry (pressing <code>&lt;enter&gt;</code> after) enables strict mode for the rest of that console session, the way it would on the first line of a .js file, as well as whether you can use <code>\"use strict\";</code> beyond the \"first line\" and still get strict mode turned on for that session.</p><p>* How non-strict mode <code>this</code> default-binding works for function calls, and whether the \"global object\" used will contain expected global variables.</p><p><em> How hoisting (see Book 2, </em>Scope &amp; Closures*) works across multiple line entries.</p><p>* ...several others</p><p>The developer console is not trying to pretend to be a JS compiler that handles your entered code exactly the same way the JS engine handles a .js file. It's trying to make it easy for you to quickly enter a few lines of code and see the results immediately. These are entirely different use cases, and as such, it's unreasonable to expect one tool to handle both equally.</p><p>Don't trust what behavior you see in a developer console as representing <em>exact</em> to-the-letter JS semantics; for that, read the specification. Instead, think of the console as a \"JS-friendly\" environment. That's useful in its own right.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "It's Not Always JS", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Using the console/REPL (Read-Evaluate-Print-Loop) in your browser's Developer Tools (or Node) feels like a pretty straightforward JS environment at first glance. But it's not, really.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Developer Tools are... tools for developers. Their primary purpose is to make life easier for developers. They prioritize DX (Developer Experience). It is ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " a goal of such tools to accurately and purely reflect all nuances of strict-spec JS behavior. As such, there's many quirks that may act as \"gotchas\" if you're treating the console as a ", "type": "text"}, {"text": "pure", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JS environment.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This convenience is a good thing, by the way! I'm glad Developer Tools make developers' lives easier! I'm glad we have nice UX charms like auto-complete of variables/properties, etc. I'm just pointing out that we can't and shouldn't expect such tools to ", "type": "text"}, {"text": "always", "type": "text", "marks": [{"type": "italic"}]}, {"text": " adhere strictly to the way JS programs are handled, because that's not the purpose of these tools.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since such tools vary in behavior from browser to browser, and since they change (sometimes rather frequently), I'm not going to \"hardcode\" any of the specific details into this text, thereby ensuring this book text is outdated quickly.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I'll just hint at some examples of quirks that have been true at various points in different JS console environments, to reinforce my point about not assuming native JS behavior while using them:", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "* Whether a ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " declaration in the top-level \"global scope\" of the console actually creates a real global variable (and mirrored ", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " property, and vice versa!).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "* What happens with multiple ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations in the top-level \"global scope.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "* Whether ", "type": "text"}, {"text": "\"use strict\";", "type": "text", "marks": [{"type": "code"}]}, {"text": " on one line-entry (pressing ", "type": "text"}, {"text": "<enter>", "type": "text", "marks": [{"type": "code"}]}, {"text": " after) enables strict mode for the rest of that console session, the way it would on the first line of a .js file, as well as whether you can use ", "type": "text"}, {"text": "\"use strict\";", "type": "text", "marks": [{"type": "code"}]}, {"text": " beyond the \"first line\" and still get strict mode turned on for that session.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "* How non-strict mode ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " default-binding works for function calls, and whether the \"global object\" used will contain expected global variables.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": " How hoisting (see Book 2, ", "type": "text", "marks": [{"type": "italic"}]}, {"text": "Scope & Closures*) works across multiple line entries.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "* ...several others", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The developer console is not trying to pretend to be a JS compiler that handles your entered code exactly the same way the JS engine handles a .js file. It's trying to make it easy for you to quickly enter a few lines of code and see the results immediately. These are entirely different use cases, and as such, it's unreasonable to expect one tool to handle both equally.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't trust what behavior you see in a developer console as representing ", "type": "text"}, {"text": "exact", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to-the-letter JS semantics; for that, read the specification. Instead, think of the console as a \"JS-friendly\" environment. That's useful in its own right.", "type": "text"}]}]}, "article_text": "It's Not Always JS\n\nUsing the console/REPL (Read-Evaluate-Print-Loop) in your browser's Developer Tools (or Node) feels like a pretty straightforward JS environment at first glance. But it's not, really.\n\nDeveloper Tools are... tools for developers. Their primary purpose is to make life easier for developers. They prioritize DX (Developer Experience). It is not a goal of such tools to accurately and purely reflect all nuances of strict-spec JS behavior. As such, there's many quirks that may act as \"gotchas\" if you're treating the console as a pure JS environment.\n\nThis convenience is a good thing, by the way! I'm glad Developer Tools make developers' lives easier! I'm glad we have nice UX charms like auto-complete of variables/properties, etc. I'm just pointing out that we can't and shouldn't expect such tools to always adhere strictly to the way JS programs are handled, because that's not the purpose of these tools.\n\nSince such tools vary in behavior from browser to browser, and since they change (sometimes rather frequently), I'm not going to \"hardcode\" any of the specific details into this text, thereby ensuring this book text is outdated quickly.\n\nBut I'll just hint at some examples of quirks that have been true at various points in different JS console environments, to reinforce my point about not assuming native JS behavior while using them:\n\n* Whether a var or function declaration in the top-level \"global scope\" of the console actually creates a real global variable (and mirrored window property, and vice versa!).\n\n* What happens with multiple let and const declarations in the top-level \"global scope.\"\n\n* Whether \"use strict\"; on one line-entry (pressing <enter> after) enables strict mode for the rest of that console session, the way it would on the first line of a .js file, as well as whether you can use \"use strict\"; beyond the \"first line\" and still get strict mode turned on for that session.\n\n* How non-strict mode this default-binding works for function calls, and whether the \"global object\" used will contain expected global variables.\n\n How hoisting (see Book 2, Scope & Closures*) works across multiple line entries.\n\n* ...several others\n\nThe developer console is not trying to pretend to be a JS compiler that handles your entered code exactly the same way the JS engine handles a .js file. It's trying to make it easy for you to quickly enter a few lines of code and see the results immediately. These are entirely different use cases, and as such, it's unreasonable to expect one tool to handle both equally.\n\nDon't trust what behavior you see in a developer console as representing exact to-the-letter JS semantics; for that, read the specification. Instead, think of the console as a \"JS-friendly\" environment. That's useful in its own right."}, "id": 108}]}, {"data": {"uuid": "a5d058e9-2b0e-4b47-abd6-e1dd34d8644e", "user": 1, "title": "Many Faces", "author": "Kyle Simpson", "created_on": "2023-06-06 02:43:54.466307+00:00", "updated_on": "2023-06-06 02:44:30.916495+00:00", "article_html": "<h2>Many Faces</h2><p>The term \"paradigm\" in programming language context refers to a broad (almost universal) mindset and approach to structuring code. Within a paradigm, there are myriad variations of style and form that distinguish programs, including countless different libraries and frameworks that leave their unique signature on any given code.</p><p>But no matter what a program's individual style may be, the big picture divisions around paradigms are almost always evident at first glance of any program.</p><p>Typical paradigm-level code categories include procedural, object-oriented (OO/classes), and functional (FP):</p><ul><li><p>Procedural style organizes code in a top-down, linear progression through a pre-determined set of operations, usually collected together in related units called procedures.</p></li><li><p>OO style organizes code by collecting logic and data together into units called classes.</p></li><li><p>FP style organizes code into functions (pure computations as opposed to procedures), and the adaptations of those functions as values.</p></li></ul><p>Paradigms are neither right nor wrong. They're orientations that guide and mold how programmers approach problems and solutions, how they structure and maintain their code.</p><p>Some languages are heavily slanted toward one paradigm\u2014C is procedural, Java/C++ are almost entirely class oriented, and Haskell is FP through and through.</p><p>But many languages also support code patterns that can come from, and even mix and match from, different paradigms. So called \"multi-paradigm languages\" offer ultimate flexibility. In some cases, a single program can even have two or more expressions of these paradigms sitting side by side.</p><p>JavaScript is most definitely a multi-paradigm language. You can write procedural, class-oriented, or FP-style code, and you can make those decisions on a line-by-line basis instead of being forced into an all-or-nothing choice.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Many Faces", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The term \"paradigm\" in programming language context refers to a broad (almost universal) mindset and approach to structuring code. Within a paradigm, there are myriad variations of style and form that distinguish programs, including countless different libraries and frameworks that leave their unique signature on any given code.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But no matter what a program's individual style may be, the big picture divisions around paradigms are almost always evident at first glance of any program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Typical paradigm-level code categories include procedural, object-oriented (OO/classes), and functional (FP):", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Procedural style organizes code in a top-down, linear progression through a pre-determined set of operations, usually collected together in related units called procedures.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "OO style organizes code by collecting logic and data together into units called classes.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "FP style organizes code into functions (pure computations as opposed to procedures), and the adaptations of those functions as values.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Paradigms are neither right nor wrong. They're orientations that guide and mold how programmers approach problems and solutions, how they structure and maintain their code.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Some languages are heavily slanted toward one paradigm\u2014C is procedural, Java/C++ are almost entirely class oriented, and Haskell is FP through and through.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But many languages also support code patterns that can come from, and even mix and match from, different paradigms. So called \"multi-paradigm languages\" offer ultimate flexibility. In some cases, a single program can even have two or more expressions of these paradigms sitting side by side.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JavaScript is most definitely a multi-paradigm language. You can write procedural, class-oriented, or FP-style code, and you can make those decisions on a line-by-line basis instead of being forced into an all-or-nothing choice.", "type": "text"}]}]}, "article_text": "Many Faces\n\nThe term \"paradigm\" in programming language context refers to a broad (almost universal) mindset and approach to structuring code. Within a paradigm, there are myriad variations of style and form that distinguish programs, including countless different libraries and frameworks that leave their unique signature on any given code.\n\nBut no matter what a program's individual style may be, the big picture divisions around paradigms are almost always evident at first glance of any program.\n\nTypical paradigm-level code categories include procedural, object-oriented (OO/classes), and functional (FP):\n\nProcedural style organizes code in a top-down, linear progression through a pre-determined set of operations, usually collected together in related units called procedures.\n\nOO style organizes code by collecting logic and data together into units called classes.\n\nFP style organizes code into functions (pure computations as opposed to procedures), and the adaptations of those functions as values.\n\nParadigms are neither right nor wrong. They're orientations that guide and mold how programmers approach problems and solutions, how they structure and maintain their code.\n\nSome languages are heavily slanted toward one paradigm\u2014C is procedural, Java/C++ are almost entirely class oriented, and Haskell is FP through and through.\n\nBut many languages also support code patterns that can come from, and even mix and match from, different paradigms. So called \"multi-paradigm languages\" offer ultimate flexibility. In some cases, a single program can even have two or more expressions of these paradigms sitting side by side.\n\nJavaScript is most definitely a multi-paradigm language. You can write procedural, class-oriented, or FP-style code, and you can make those decisions on a line-by-line basis instead of being forced into an all-or-nothing choice."}, "id": 109}, {"data": {"uuid": "4a20e7c0-dceb-470f-807a-f6c816e5cfab", "user": 1, "title": "Backwards & Forwards", "author": "Kyle Simpson", "created_on": "2023-06-06 03:08:29.993144+00:00", "updated_on": "2023-06-06 03:08:50.513120+00:00", "article_html": "<h2>Backwards &amp; Forwards</h2><p>One of the most foundational principles that guides JavaScript is preservation of <em>backwards compatibility</em>. Many are confused by the implications of this term, and often confuse it with a related but different term: <em>forwards compatibility</em>.</p><p>Let's set the record straight.</p><p>Backwards compatibility means that once something is accepted as valid JS, there will not be a future change to the language that causes that code to become invalid JS. Code written in 1995\u2014however primitive or limited it may have been!\u2014should still work today. As TC39 members often proclaim, \"we don't break the web!\"</p><p>The idea is that JS developers can write code with confidence that their code won't stop working unpredictably because a browser update is released. This makes the decision to choose JS for a program a more wise and safe investment, for years into the future.</p><p>That \"guarantee\" is no small thing. Maintaining backwards compatibility, stretched out across almost 25 years of the language's history, creates an enormous burden and a whole slew of unique challenges. You'd be hard pressed to find many other examples in computing of such a commitment to backwards compatibility.</p><p>The costs of sticking to this principle should not be casually dismissed. It necessarily creates a very high bar to including changing or extending the language; any decision becomes effectively permanent, mistakes and all. Once it's in JS, it can't be taken out because it might break programs, even if we'd really, really like to remove it!</p><p>There are some small exceptions to this rule. JS has had some backwards-incompatible changes, but TC39 is extremely cautious in doing so. They study existing code on the web (via browser data gathering) to estimate the impact of such breakage, and browsers ultimately decide and vote on whether they're willing to take the heat from users for a very small-scale breakage weighed against the benefits of fixing or improving some aspect of the language for many more sites (and users).</p><p>These kinds of changes are rare, and are almost always in corner cases of usage that are unlikely to be observably breaking in many sites.</p><p>Compare <em>backwards compatibility</em> to its counterpart, <em>forwards compatibility</em>. Being forwards-compatible means that including a new addition to the language in a program would not cause that program to break if it were run in an older JS engine. <strong>JS is not forwards-compatible</strong>, despite many wishing such, and even incorrectly believing the myth that it is.</p><p>HTML and CSS, by contrast, are forwards-compatible but not backwards-compatible. If you dug up some HTML or CSS written back in 1995, it's entirely possible it would not work (or work the same) today. But, if you use a new feature from 2019 in a browser from 2010, the page isn't \"broken\" -- the unrecognized CSS/HTML is skipped over, while the rest of the CSS/HTML would be processed accordingly.</p><p>It may seem desirable for forwards-compatibility to be included in programming language design, but it's generally impractical to do so. Markup (HTML) or styling (CSS) are declarative in nature, so it's much easier to \"skip over\" unrecognized declarations with minimal impact to other recognized declarations.</p><p>But chaos and non-determinism would ensue if a programming language engine selectively skipped statements (or even expressions!) that it didn't understand, as it's impossible to ensure that a subsequent part of the program wasn't expecting the skipped-over part to have been processed.</p><p>Though JS isn't, and can't be, forwards-compatible, it's critical to recognize JS's backwards compatibility, including the enduring benefits to the web and the constraints and difficulties it places on JS as a result.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Backwards & Forwards", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One of the most foundational principles that guides JavaScript is preservation of ", "type": "text"}, {"text": "backwards compatibility", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Many are confused by the implications of this term, and often confuse it with a related but different term: ", "type": "text"}, {"text": "forwards compatibility", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's set the record straight.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Backwards compatibility means that once something is accepted as valid JS, there will not be a future change to the language that causes that code to become invalid JS. Code written in 1995\u2014however primitive or limited it may have been!\u2014should still work today. As TC39 members often proclaim, \"we don't break the web!\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The idea is that JS developers can write code with confidence that their code won't stop working unpredictably because a browser update is released. This makes the decision to choose JS for a program a more wise and safe investment, for years into the future.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That \"guarantee\" is no small thing. Maintaining backwards compatibility, stretched out across almost 25 years of the language's history, creates an enormous burden and a whole slew of unique challenges. You'd be hard pressed to find many other examples in computing of such a commitment to backwards compatibility.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The costs of sticking to this principle should not be casually dismissed. It necessarily creates a very high bar to including changing or extending the language; any decision becomes effectively permanent, mistakes and all. Once it's in JS, it can't be taken out because it might break programs, even if we'd really, really like to remove it!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are some small exceptions to this rule. JS has had some backwards-incompatible changes, but TC39 is extremely cautious in doing so. They study existing code on the web (via browser data gathering) to estimate the impact of such breakage, and browsers ultimately decide and vote on whether they're willing to take the heat from users for a very small-scale breakage weighed against the benefits of fixing or improving some aspect of the language for many more sites (and users).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These kinds of changes are rare, and are almost always in corner cases of usage that are unlikely to be observably breaking in many sites.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Compare ", "type": "text"}, {"text": "backwards compatibility", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to its counterpart, ", "type": "text"}, {"text": "forwards compatibility", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". Being forwards-compatible means that including a new addition to the language in a program would not cause that program to break if it were run in an older JS engine. ", "type": "text"}, {"text": "JS is not forwards-compatible", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", despite many wishing such, and even incorrectly believing the myth that it is.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "HTML and CSS, by contrast, are forwards-compatible but not backwards-compatible. If you dug up some HTML or CSS written back in 1995, it's entirely possible it would not work (or work the same) today. But, if you use a new feature from 2019 in a browser from 2010, the page isn't \"broken\" -- the unrecognized CSS/HTML is skipped over, while the rest of the CSS/HTML would be processed accordingly.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It may seem desirable for forwards-compatibility to be included in programming language design, but it's generally impractical to do so. Markup (HTML) or styling (CSS) are declarative in nature, so it's much easier to \"skip over\" unrecognized declarations with minimal impact to other recognized declarations.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But chaos and non-determinism would ensue if a programming language engine selectively skipped statements (or even expressions!) that it didn't understand, as it's impossible to ensure that a subsequent part of the program wasn't expecting the skipped-over part to have been processed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though JS isn't, and can't be, forwards-compatible, it's critical to recognize JS's backwards compatibility, including the enduring benefits to the web and the constraints and difficulties it places on JS as a result.", "type": "text"}]}]}, "article_text": "Backwards & Forwards\n\nOne of the most foundational principles that guides JavaScript is preservation of backwards compatibility. Many are confused by the implications of this term, and often confuse it with a related but different term: forwards compatibility.\n\nLet's set the record straight.\n\nBackwards compatibility means that once something is accepted as valid JS, there will not be a future change to the language that causes that code to become invalid JS. Code written in 1995\u2014however primitive or limited it may have been!\u2014should still work today. As TC39 members often proclaim, \"we don't break the web!\"\n\nThe idea is that JS developers can write code with confidence that their code won't stop working unpredictably because a browser update is released. This makes the decision to choose JS for a program a more wise and safe investment, for years into the future.\n\nThat \"guarantee\" is no small thing. Maintaining backwards compatibility, stretched out across almost 25 years of the language's history, creates an enormous burden and a whole slew of unique challenges. You'd be hard pressed to find many other examples in computing of such a commitment to backwards compatibility.\n\nThe costs of sticking to this principle should not be casually dismissed. It necessarily creates a very high bar to including changing or extending the language; any decision becomes effectively permanent, mistakes and all. Once it's in JS, it can't be taken out because it might break programs, even if we'd really, really like to remove it!\n\nThere are some small exceptions to this rule. JS has had some backwards-incompatible changes, but TC39 is extremely cautious in doing so. They study existing code on the web (via browser data gathering) to estimate the impact of such breakage, and browsers ultimately decide and vote on whether they're willing to take the heat from users for a very small-scale breakage weighed against the benefits of fixing or improving some aspect of the language for many more sites (and users).\n\nThese kinds of changes are rare, and are almost always in corner cases of usage that are unlikely to be observably breaking in many sites.\n\nCompare backwards compatibility to its counterpart, forwards compatibility. Being forwards-compatible means that including a new addition to the language in a program would not cause that program to break if it were run in an older JS engine. JS is not forwards-compatible, despite many wishing such, and even incorrectly believing the myth that it is.\n\nHTML and CSS, by contrast, are forwards-compatible but not backwards-compatible. If you dug up some HTML or CSS written back in 1995, it's entirely possible it would not work (or work the same) today. But, if you use a new feature from 2019 in a browser from 2010, the page isn't \"broken\" -- the unrecognized CSS/HTML is skipped over, while the rest of the CSS/HTML would be processed accordingly.\n\nIt may seem desirable for forwards-compatibility to be included in programming language design, but it's generally impractical to do so. Markup (HTML) or styling (CSS) are declarative in nature, so it's much easier to \"skip over\" unrecognized declarations with minimal impact to other recognized declarations.\n\nBut chaos and non-determinism would ensue if a programming language engine selectively skipped statements (or even expressions!) that it didn't understand, as it's impossible to ensure that a subsequent part of the program wasn't expecting the skipped-over part to have been processed.\n\nThough JS isn't, and can't be, forwards-compatible, it's critical to recognize JS's backwards compatibility, including the enduring benefits to the web and the constraints and difficulties it places on JS as a result."}, "id": 110, "children": [{"data": {"uuid": "725286e2-a5c5-4dd8-b415-51c2509e3090", "user": 1, "title": "Jumping the Gaps", "author": "Kyle Simpson", "created_on": "2023-06-06 03:09:46.104752+00:00", "updated_on": "2023-06-06 20:18:15.696685+00:00", "article_html": "<h3>Jumping the Gaps</h3><p>Since JS is not forwards-compatible, it means that there is always the potential for a gap between code that you can write that's valid JS, and the oldest engine that your site or application needs to support. If you run a program that uses an ES2019 feature in an engine from 2016, you're very likely to see the program break and crash.</p><p>If the feature is a new syntax, the program will in general completely fail to compile and run, usually throwing a syntax error. If the feature is an API (such as ES6's <code>Object.is(..)</code>), the program may run up to a point but then throw a runtime exception and stop once it encounters the reference to the unknown API.</p><p>Does this mean JS developers should always lag behind the pace of progress, using only code that is on the trailing edge of the oldest JS engine environments they need to support? No!</p><p>But it does mean that JS developers need to take special care to address this gap.</p><p>For new and incompatible syntax, the solution is transpiling. Transpiling is a contrived and community-invented term to describe using a tool to convert the source code of a program from one form to another (but still as textual source code). Typically, forwards-compatibility problems related to syntax are solved by using a transpiler (the most common one being Babel (<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://babeljs.io\">https://babeljs.io</a>)) to convert from that newer JS syntax version to an equivalent older syntax.</p><p>For example, a developer may write a snippet of code like:</p><pre class=\"not-prose\"><code class=\"language-js\">if (something) {\r\n    let x = 3;\r\n    console.log(x);\r\n}\r\nelse {\r\n    let x = 4;\r\n    console.log(x);\r\n}</code></pre><p>This is how the code would look in the source code tree for that application. But when producing the file(s) to deploy to the public website, the Babel transpiler might convert that code to look like this:</p><p></p><pre class=\"not-prose\"><code class=\"language-js\">var x$0, x$1;\r\nif (something) {\r\n    x$0 = 3;\r\n    console.log(x$0);\r\n}\r\nelse {\r\n    x$1 = 4;\r\n    console.log(x$1);\r\n}</code></pre><p>The original snippet relied on <code>let</code> to create block-scoped <code>x</code> variables in both the <code>if</code> and <code>else</code> clauses which did not interfere with each other. An equivalent program (with minimal re-working) that Babel can produce just chooses to name two different variables with unique names, producing the same non-interference outcome.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The <code>let</code> keyword was added in ES6 (in 2015). The preceding example of transpiling would only need to apply if an application needed to run in a pre-ES6 supporting JS environment. The example here is just for simplicity of illustration. When ES6 was new, the need for such a transpilation was quite prevalent, but in 2020 it's much less common to need to support pre-ES6 environments. The \"target\" used for transpiliation is thus a sliding window that shifts upward only as decisions are made for a site/application to stop supporting some old browser/engine.</p></td></tr></tbody></table><p>You may wonder: why go to the trouble of using a tool to convert from a newer syntax version to an older one? Couldn't we just write the two variables and skip using the <code>let</code> keyword? The reason is, it's strongly recommended that developers use the latest version of JS so that their code is clean and communicates its ideas most effectively.</p><p>Developers should focus on writing the clean, new syntax forms, and let the tools take care of producing a forwards-compatible version of that code that is suitable to deploy and run on the oldest-supported JS engine environments.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Jumping the Gaps", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since JS is not forwards-compatible, it means that there is always the potential for a gap between code that you can write that's valid JS, and the oldest engine that your site or application needs to support. If you run a program that uses an ES2019 feature in an engine from 2016, you're very likely to see the program break and crash.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If the feature is a new syntax, the program will in general completely fail to compile and run, usually throwing a syntax error. If the feature is an API (such as ES6's ", "type": "text"}, {"text": "Object.is(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "), the program may run up to a point but then throw a runtime exception and stop once it encounters the reference to the unknown API.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Does this mean JS developers should always lag behind the pace of progress, using only code that is on the trailing edge of the oldest JS engine environments they need to support? No!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But it does mean that JS developers need to take special care to address this gap.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For new and incompatible syntax, the solution is transpiling. Transpiling is a contrived and community-invented term to describe using a tool to convert the source code of a program from one form to another (but still as textual source code). Typically, forwards-compatibility problems related to syntax are solved by using a transpiler (the most common one being Babel (", "type": "text"}, {"text": "https://babeljs.io", "type": "text", "marks": [{"type": "link", "attrs": {"href": "https://babeljs.io", "class": null, "target": "_blank"}}]}, {"text": ")) to convert from that newer JS syntax version to an equivalent older syntax.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, a developer may write a snippet of code like:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": "js"}, "content": [{"text": "if (something) {\n    let x = 3;\n    console.log(x);\n}\nelse {\n    let x = 4;\n    console.log(x);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is how the code would look in the source code tree for that application. But when producing the file(s) to deploy to the public website, the Babel transpiler might convert that code to look like this:", "type": "text"}]}, {"type": "paragraph"}, {"type": "codeBlock", "attrs": {"language": "js"}, "content": [{"text": "var x$0, x$1;\nif (something) {\n    x$0 = 3;\n    console.log(x$0);\n}\nelse {\n    x$1 = 4;\n    console.log(x$1);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The original snippet relied on ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " to create block-scoped ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables in both the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "else", "type": "text", "marks": [{"type": "code"}]}, {"text": " clauses which did not interfere with each other. An equivalent program (with minimal re-working) that Babel can produce just chooses to name two different variables with unique names, producing the same non-interference outcome.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword was added in ES6 (in 2015). The preceding example of transpiling would only need to apply if an application needed to run in a pre-ES6 supporting JS environment. The example here is just for simplicity of illustration. When ES6 was new, the need for such a transpilation was quite prevalent, but in 2020 it's much less common to need to support pre-ES6 environments. The \"target\" used for transpiliation is thus a sliding window that shifts upward only as decisions are made for a site/application to stop supporting some old browser/engine.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "You may wonder: why go to the trouble of using a tool to convert from a newer syntax version to an older one? Couldn't we just write the two variables and skip using the ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword? The reason is, it's strongly recommended that developers use the latest version of JS so that their code is clean and communicates its ideas most effectively.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Developers should focus on writing the clean, new syntax forms, and let the tools take care of producing a forwards-compatible version of that code that is suitable to deploy and run on the oldest-supported JS engine environments.", "type": "text"}]}]}, "article_text": "Jumping the Gaps\r\n\r\nSince JS is not forwards-compatible, it means that there is always the potential for a gap between code that you can write that's valid JS, and the oldest engine that your site or application needs to support. If you run a program that uses an ES2019 feature in an engine from 2016, you're very likely to see the program break and crash.\r\n\r\nIf the feature is a new syntax, the program will in general completely fail to compile and run, usually throwing a syntax error. If the feature is an API (such as ES6's Object.is(..)), the program may run up to a point but then throw a runtime exception and stop once it encounters the reference to the unknown API.\r\n\r\nDoes this mean JS developers should always lag behind the pace of progress, using only code that is on the trailing edge of the oldest JS engine environments they need to support? No!\r\n\r\nBut it does mean that JS developers need to take special care to address this gap.\r\n\r\nFor new and incompatible syntax, the solution is transpiling. Transpiling is a contrived and community-invented term to describe using a tool to convert the source code of a program from one form to another (but still as textual source code). Typically, forwards-compatibility problems related to syntax are solved by using a transpiler (the most common one being Babel (https://babeljs.io)) to convert from that newer JS syntax version to an equivalent older syntax.\r\n\r\nFor example, a developer may write a snippet of code like:\r\n\r\nif (something) {\r\n    let x = 3;\r\n    console.log(x);\r\n}\r\nelse {\r\n    let x = 4;\r\n    console.log(x);\r\n}\r\n\r\nThis is how the code would look in the source code tree for that application. But when producing the file(s) to deploy to the public website, the Babel transpiler might convert that code to look like this:\r\n\r\nvar x$0, x$1;\r\nif (something) {\r\n    x$0 = 3;\r\n    console.log(x$0);\r\n}\r\nelse {\r\n    x$1 = 4;\r\n    console.log(x$1);\r\n}\r\n\r\nThe original snippet relied on let to create block-scoped x variables in both the if and else clauses which did not interfere with each other. An equivalent program (with minimal re-working) that Babel can produce just chooses to name two different variables with unique names, producing the same non-interference outcome.\r\n\r\nNOTE:\r\n\r\nThe let keyword was added in ES6 (in 2015). The preceding example of transpiling would only need to apply if an application needed to run in a pre-ES6 supporting JS environment. The example here is just for simplicity of illustration. When ES6 was new, the need for such a transpilation was quite prevalent, but in 2020 it's much less common to need to support pre-ES6 environments. The \"target\" used for transpiliation is thus a sliding window that shifts upward only as decisions are made for a site/application to stop supporting some old browser/engine.\r\n\r\nYou may wonder: why go to the trouble of using a tool to convert from a newer syntax version to an older one? Couldn't we just write the two variables and skip using the let keyword? The reason is, it's strongly recommended that developers use the latest version of JS so that their code is clean and communicates its ideas most effectively.\r\n\r\nDevelopers should focus on writing the clean, new syntax forms, and let the tools take care of producing a forwards-compatible version of that code that is suitable to deploy and run on the oldest-supported JS engine environments."}, "id": 111}, {"data": {"uuid": "7f39de3b-5454-41cf-9cfa-81a43dbb9969", "user": 1, "title": "Filling the Gaps", "author": "Kyle Simpson", "created_on": "2023-06-07 16:49:08.918541+00:00", "updated_on": "2023-06-07 18:04:55.907835+00:00", "article_html": "<h3>Filling the Gaps</h3><p>If the forwards-compatibility issue is not related to new syntax, but rather to a missing API method that was only recently added, the most common solution is to provide a definition for that missing API method that stands in and acts as if the older environment had already had it natively defined. This pattern is called a polyfill (aka \"shim\").</p><p>Consider this code:</p><pre><code class=\"language-js\">// getSomeRecords() returns us a promise for some\n// data it will fetch\nvar pr = getSomeRecords();\n\n// show the UI spinner while we get the data\nstartSpinner();\n\npr\n.then(renderRecords)   // render if successful\n.catch(showError)      // show an error if not\n.finally(hideSpinner)  // always hide the spinner</code></pre><p>This code uses an ES2019 feature, the <code>finally(..)</code> method on the promise prototype. If this code were used in a pre-ES2019 environment, the <code>finally(..)</code> method would not exist, and an error would occur.</p><p>A polyfill for <code>finally(..)</code> in pre-ES2019 environments could look like this:</p><pre><code class=\"language-js\">if (!Promise.prototype.finally) {\n    Promise.prototype.finally = function f(fn){\n        return this.then(\n            function t(v){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        return v;\n                    });\n            },\n            function c(e){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        throw e;\n                    });\n            }\n        );\n    };\n}</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>Warning:</p></th><th colspan=\"1\" rowspan=\"1\"><p></p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>This is only a simple illustration of a basic (not entirely spec-compliant) polyfill for <code>finally(..)</code>. Don't use this polyfill in your code; always use a robust, official polyfill wherever possible, such as the collection of polyfills/shims in ES-Shim. |</p></td><td colspan=\"1\" rowspan=\"1\"><p></p></td></tr></tbody></table><p>The <code>if</code> statement protects the polyfill definition by preventing it from running in any environment where the JS engine has already defined that method. In older environments, the polyfill is defined, but in newer environments the <code>if</code> statement is quietly skipped.</p><p>Transpilers like Babel typically detect which polyfills your code needs and provide them automatically for you. But occasionally you may need to include/define them explicitly, which works similar to the snippet we just looked at.</p><p>Always write code using the most appropriate features to communicate its ideas and intent effectively. In general, this means using the most recent stable JS version. Avoid negatively impacting the code's readability by trying to manually adjust for the syntax/API gaps. That's what tools are for!</p><p>Transpilation and polyfilling are two highly effective techniques for addressing that gap between code that uses the latest stable features in the language and the old environments a site or application needs to still support. Since JS isn't going to stop improving, the gap will never go away. Both techniques should be embraced as a standard part of every JS project's production chain going forward.</p><p></p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Filling the Gaps", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If the forwards-compatibility issue is not related to new syntax, but rather to a missing API method that was only recently added, the most common solution is to provide a definition for that missing API method that stands in and acts as if the older environment had already had it natively defined. This pattern is called a polyfill (aka \"shim\").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider this code:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": "js"}, "content": [{"text": "// getSomeRecords() returns us a promise for some\n// data it will fetch\nvar pr = getSomeRecords();\n\n// show the UI spinner while we get the data\nstartSpinner();\n\npr\n.then(renderRecords)   // render if successful\n.catch(showError)      // show an error if not\n.finally(hideSpinner)  // always hide the spinner", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This code uses an ES2019 feature, the ", "type": "text"}, {"text": "finally(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method on the promise prototype. If this code were used in a pre-ES2019 environment, the ", "type": "text"}, {"text": "finally(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method would not exist, and an error would occur.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A polyfill for ", "type": "text"}, {"text": "finally(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " in pre-ES2019 environments could look like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": "js"}, "content": [{"text": "if (!Promise.prototype.finally) {\n    Promise.prototype.finally = function f(fn){\n        return this.then(\n            function t(v){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        return v;\n                    });\n            },\n            function c(e){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        throw e;\n                    });\n            }\n        );\n    };\n}", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Warning:", "type": "text"}]}]}, {"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph"}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "This is only a simple illustration of a basic (not entirely spec-compliant) polyfill for ", "type": "text"}, {"text": "finally(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Don't use this polyfill in your code; always use a robust, official polyfill wherever possible, such as the collection of polyfills/shims in ES-Shim. |", "type": "text"}]}]}, {"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph"}]}]}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement protects the polyfill definition by preventing it from running in any environment where the JS engine has already defined that method. In older environments, the polyfill is defined, but in newer environments the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement is quietly skipped.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Transpilers like Babel typically detect which polyfills your code needs and provide them automatically for you. But occasionally you may need to include/define them explicitly, which works similar to the snippet we just looked at.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Always write code using the most appropriate features to communicate its ideas and intent effectively. In general, this means using the most recent stable JS version. Avoid negatively impacting the code's readability by trying to manually adjust for the syntax/API gaps. That's what tools are for!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Transpilation and polyfilling are two highly effective techniques for addressing that gap between code that uses the latest stable features in the language and the old environments a site or application needs to still support. Since JS isn't going to stop improving, the gap will never go away. Both techniques should be embraced as a standard part of every JS project's production chain going forward.", "type": "text"}]}, {"type": "paragraph"}]}, "article_text": "Filling the Gaps\n\nIf the forwards-compatibility issue is not related to new syntax, but rather to a missing API method that was only recently added, the most common solution is to provide a definition for that missing API method that stands in and acts as if the older environment had already had it natively defined. This pattern is called a polyfill (aka \"shim\").\n\nConsider this code:\n\n// getSomeRecords() returns us a promise for some\n// data it will fetch\nvar pr = getSomeRecords();\n\n// show the UI spinner while we get the data\nstartSpinner();\n\npr\n.then(renderRecords)   // render if successful\n.catch(showError)      // show an error if not\n.finally(hideSpinner)  // always hide the spinner\n\nThis code uses an ES2019 feature, the finally(..) method on the promise prototype. If this code were used in a pre-ES2019 environment, the finally(..) method would not exist, and an error would occur.\n\nA polyfill for finally(..) in pre-ES2019 environments could look like this:\n\nif (!Promise.prototype.finally) {\n    Promise.prototype.finally = function f(fn){\n        return this.then(\n            function t(v){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        return v;\n                    });\n            },\n            function c(e){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        throw e;\n                    });\n            }\n        );\n    };\n}\n\nWarning:\n\nThis is only a simple illustration of a basic (not entirely spec-compliant) polyfill for finally(..). Don't use this polyfill in your code; always use a robust, official polyfill wherever possible, such as the collection of polyfills/shims in ES-Shim. |\n\nThe if statement protects the polyfill definition by preventing it from running in any environment where the JS engine has already defined that method. In older environments, the polyfill is defined, but in newer environments the if statement is quietly skipped.\n\nTranspilers like Babel typically detect which polyfills your code needs and provide them automatically for you. But occasionally you may need to include/define them explicitly, which works similar to the snippet we just looked at.\n\nAlways write code using the most appropriate features to communicate its ideas and intent effectively. In general, this means using the most recent stable JS version. Avoid negatively impacting the code's readability by trying to manually adjust for the syntax/API gaps. That's what tools are for!\n\nTranspilation and polyfilling are two highly effective techniques for addressing that gap between code that uses the latest stable features in the language and the old environments a site or application needs to still support. Since JS isn't going to stop improving, the gap will never go away. Both techniques should be embraced as a standard part of every JS project's production chain going forward."}, "id": 112}]}, {"data": {"uuid": "6a15a8fa-f423-4d74-b1b5-46835813ba5a", "user": 1, "title": "What's in an Interpretation?", "author": "Kyle Simpson", "created_on": "2023-06-07 18:05:24.675984+00:00", "updated_on": "2023-06-07 18:08:31.174384+00:00", "article_html": "<h2>What's in an Interpretation?</h2><p>A long-debated question for code written in JS: is it an interpreted script or a compiled program? The majority opinion seems to be that JS is an interpreted (scripting) language. But the truth is more complicated than that.</p><p>For much of the history of programming languages, \"interpreted\" languages and \"scripting\" languages have been looked down on as inferior compared to their compiled counterparts. The reasons for this acrimony are numerous, including the perception that there is a lack of performance optimization, as well as dislike of certain language characteristics, such as scripting languages generally using dynamic typing instead of the \"more mature\" statically typed languages.</p><p>Languages regarded as \"compiled\" usually produce a portable (binary) representation of the program that is distributed for execution later. Since we don't really observe that kind of model with JS (we distribute the source code, not the binary form), many claim that disqualifies JS from the category. In reality, the distribution model for a program's \"executable\" form has become drastically more varied and also less relevant over the last few decades; to the question at hand, it doesn't really matter so much anymore what form of a program gets passed around.</p><p>These misinformed claims and criticisms should be set aside. The real reason it matters to have a clear picture on whether JS is interpreted or compiled relates to the nature of how errors are handled.</p><p>Historically, scripted or interpreted languages were executed in generally a top-down and line-by-line fashion; there's typically not an initial pass through the program to process it before execution begins (see Figure 1).</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig1.png\"><p><em>Fig. 1: Interpreted/Scripted Execution</em> <br></p><p>In scripted or interpreted languages, an error on line 5 of a program won't be discovered until lines 1 through 4 have already executed. Notably, the error on line 5 might be due to a runtime condition, such as some variable or value having an unsuitable value for an operation, or it may be due to a malformed statement/command on that line. Depending on context, deferring error handling to the line the error occurs on may be a desirable or undesirable effect.</p><p>Compare that to languages which do go through a processing step (typically, called parsing) before any execution occurs, as illustrated in Figure 2:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig2.png\"><p><em>Fig. 2: Parsing + Compilation + Execution</em> </p><p>In this processing model, an invalid command (such as broken syntax) on line 5 would be caught during the parsing phase, before any execution has begun, and none of the program would run. For catching syntax (or otherwise \"static\") errors, generally it's preferred to know about them ahead of any doomed partial execution.</p><p>So what do \"parsed\" languages have in common with \"compiled\" languages? First, all compiled languages are parsed. So a parsed language is quite a ways down the road toward being compiled already. In classic compilation theory, the last remaining step after parsing is code generation: producing an executable form.</p><p>Once any source program has been fully parsed, it's very common that its subsequent execution will, in some form or fashion, include a translation from the parsed form of the program\u2014usually called an Abstract Syntax Tree (AST)\u2014to that executable form.</p><p>In other words, parsed languages usually also perform code generation before execution, so it's not that much of a stretch to say that, in spirit, they're compiled languages.</p><p>JS source code is parsed before it is executed. The specification requires as much, because it calls for \"early errors\"\u2014statically determined errors in code, such as a duplicate parameter name\u2014to be reported before the code starts executing. Those errors cannot be recognized without the code having been parsed.</p><p>So <strong>JS is a parsed language</strong>, but is it <em>compiled</em>?</p><p>The answer is closer to yes than no. The parsed JS is converted to an optimized (binary) form, and that \"code\" is subsequently executed (Figure 2); the engine does not commonly switch back into line-by-line execution (like Figure 1) mode after it has finished all the hard work of parsing\u2014most languages/engines wouldn't, because that would be highly inefficient.</p><p>To be specific, this \"compilation\" produces a binary byte code (of sorts), which is then handed to the \"JS virtual machine\" to execute. Some like to say this VM is \"interpreting\" the byte code. But then that means Java, and a dozen other JVM-driven languages, for that matter, are interpreted rather than compiled. Of course, that contradicts the typical assertion that Java/etc are compiled languages. </p><p>Interestingly, while Java and JavaScript are very different languages, the question of interpreted/compiled is pretty closely related between them!</p><p>Another wrinkle is that JS engines can employ multiple passes of JIT (Just-In-Time) processing/optimization on the generated code (post parsing), which again could reasonably be labeled either \"compilation\" or \"interpretation\" depending on perspective. It's actually a fantastically complex situation under the hood of a JS engine.</p><p>So what do these nitty-gritty details boil down to? Step back and consider the entire flow of a JS source program:</p><ol><li><p>After a program leaves a developer's editor, it gets transpiled by Babel, then packed by Webpack (and perhaps half a dozen other build processes), then it gets delivered in that very different form to a JS engine.</p></li><li><p>The JS engine parses the code to an AST.</p></li><li><p>Then the engine converts that AST to a kind-of byte code, a binary intermediate representation (IR), which is then refined/converted even further by the optimizing JIT compiler.</p></li><li><p>Finally, the JS VM executes the program.</p></li></ol><p>To visualize those steps, again:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig3.png\"><p><em>Fig. 3: Parsing, Compiling, and Executing JS</em> </p><p>Is JS handled more like an interpreted, line-by-line script, as in Figure 1, or is it handled more like a compiled language that's processed in one-to-several passes first, before execution (as in Figures 2 and 3)?</p><p>I think it's clear that in spirit, if not in practice, <strong>JS is a compiled language</strong>.</p><p>And again, the reason that matters is, since JS is compiled, we are informed of static errors (such as malformed syntax) before our code is executed. That is a substantively different interaction model than we get with traditional \"scripting\" programs, and arguably more helpful!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "What's in an Interpretation?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A long-debated question for code written in JS: is it an interpreted script or a compiled program? The majority opinion seems to be that JS is an interpreted (scripting) language. But the truth is more complicated than that.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For much of the history of programming languages, \"interpreted\" languages and \"scripting\" languages have been looked down on as inferior compared to their compiled counterparts. The reasons for this acrimony are numerous, including the perception that there is a lack of performance optimization, as well as dislike of certain language characteristics, such as scripting languages generally using dynamic typing instead of the \"more mature\" statically typed languages.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Languages regarded as \"compiled\" usually produce a portable (binary) representation of the program that is distributed for execution later. Since we don't really observe that kind of model with JS (we distribute the source code, not the binary form), many claim that disqualifies JS from the category. In reality, the distribution model for a program's \"executable\" form has become drastically more varied and also less relevant over the last few decades; to the question at hand, it doesn't really matter so much anymore what form of a program gets passed around.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These misinformed claims and criticisms should be set aside. The real reason it matters to have a clear picture on whether JS is interpreted or compiled relates to the nature of how errors are handled.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Historically, scripted or interpreted languages were executed in generally a top-down and line-by-line fashion; there's typically not an initial pass through the program to process it before execution begins (see Figure 1).", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig1.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 1: Interpreted/Scripted Execution", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"type": "hardBreak"}]}, {"type": "paragraph", "content": [{"text": "In scripted or interpreted languages, an error on line 5 of a program won't be discovered until lines 1 through 4 have already executed. Notably, the error on line 5 might be due to a runtime condition, such as some variable or value having an unsuitable value for an operation, or it may be due to a malformed statement/command on that line. Depending on context, deferring error handling to the line the error occurs on may be a desirable or undesirable effect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Compare that to languages which do go through a processing step (typically, called parsing) before any execution occurs, as illustrated in Figure 2:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig2.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 2: Parsing + Compilation + Execution", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this processing model, an invalid command (such as broken syntax) on line 5 would be caught during the parsing phase, before any execution has begun, and none of the program would run. For catching syntax (or otherwise \"static\") errors, generally it's preferred to know about them ahead of any doomed partial execution.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So what do \"parsed\" languages have in common with \"compiled\" languages? First, all compiled languages are parsed. So a parsed language is quite a ways down the road toward being compiled already. In classic compilation theory, the last remaining step after parsing is code generation: producing an executable form.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Once any source program has been fully parsed, it's very common that its subsequent execution will, in some form or fashion, include a translation from the parsed form of the program\u2014usually called an Abstract Syntax Tree (AST)\u2014to that executable form.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, parsed languages usually also perform code generation before execution, so it's not that much of a stretch to say that, in spirit, they're compiled languages.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS source code is parsed before it is executed. The specification requires as much, because it calls for \"early errors\"\u2014statically determined errors in code, such as a duplicate parameter name\u2014to be reported before the code starts executing. Those errors cannot be recognized without the code having been parsed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So ", "type": "text"}, {"text": "JS is a parsed language", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", but is it ", "type": "text"}, {"text": "compiled", "type": "text", "marks": [{"type": "italic"}]}, {"text": "?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The answer is closer to yes than no. The parsed JS is converted to an optimized (binary) form, and that \"code\" is subsequently executed (Figure 2); the engine does not commonly switch back into line-by-line execution (like Figure 1) mode after it has finished all the hard work of parsing\u2014most languages/engines wouldn't, because that would be highly inefficient.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To be specific, this \"compilation\" produces a binary byte code (of sorts), which is then handed to the \"JS virtual machine\" to execute. Some like to say this VM is \"interpreting\" the byte code. But then that means Java, and a dozen other JVM-driven languages, for that matter, are interpreted rather than compiled. Of course, that contradicts the typical assertion that Java/etc are compiled languages. ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Interestingly, while Java and JavaScript are very different languages, the question of interpreted/compiled is pretty closely related between them!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another wrinkle is that JS engines can employ multiple passes of JIT (Just-In-Time) processing/optimization on the generated code (post parsing), which again could reasonably be labeled either \"compilation\" or \"interpretation\" depending on perspective. It's actually a fantastically complex situation under the hood of a JS engine.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So what do these nitty-gritty details boil down to? Step back and consider the entire flow of a JS source program:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "After a program leaves a developer's editor, it gets transpiled by Babel, then packed by Webpack (and perhaps half a dozen other build processes), then it gets delivered in that very different form to a JS engine.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The JS engine parses the code to an AST.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Then the engine converts that AST to a kind-of byte code, a binary intermediate representation (IR), which is then refined/converted even further by the optimizing JIT compiler.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Finally, the JS VM executes the program.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "To visualize those steps, again:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig3.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 3: Parsing, Compiling, and Executing JS", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Is JS handled more like an interpreted, line-by-line script, as in Figure 1, or is it handled more like a compiled language that's processed in one-to-several passes first, before execution (as in Figures 2 and 3)?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I think it's clear that in spirit, if not in practice, ", "type": "text"}, {"text": "JS is a compiled language", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And again, the reason that matters is, since JS is compiled, we are informed of static errors (such as malformed syntax) before our code is executed. That is a substantively different interaction model than we get with traditional \"scripting\" programs, and arguably more helpful!", "type": "text"}]}]}, "article_text": "What's in an Interpretation?\n\nA long-debated question for code written in JS: is it an interpreted script or a compiled program? The majority opinion seems to be that JS is an interpreted (scripting) language. But the truth is more complicated than that.\n\nFor much of the history of programming languages, \"interpreted\" languages and \"scripting\" languages have been looked down on as inferior compared to their compiled counterparts. The reasons for this acrimony are numerous, including the perception that there is a lack of performance optimization, as well as dislike of certain language characteristics, such as scripting languages generally using dynamic typing instead of the \"more mature\" statically typed languages.\n\nLanguages regarded as \"compiled\" usually produce a portable (binary) representation of the program that is distributed for execution later. Since we don't really observe that kind of model with JS (we distribute the source code, not the binary form), many claim that disqualifies JS from the category. In reality, the distribution model for a program's \"executable\" form has become drastically more varied and also less relevant over the last few decades; to the question at hand, it doesn't really matter so much anymore what form of a program gets passed around.\n\nThese misinformed claims and criticisms should be set aside. The real reason it matters to have a clear picture on whether JS is interpreted or compiled relates to the nature of how errors are handled.\n\nHistorically, scripted or interpreted languages were executed in generally a top-down and line-by-line fashion; there's typically not an initial pass through the program to process it before execution begins (see Figure 1).\n\nFig. 1: Interpreted/Scripted Execution \n\n\nIn scripted or interpreted languages, an error on line 5 of a program won't be discovered until lines 1 through 4 have already executed. Notably, the error on line 5 might be due to a runtime condition, such as some variable or value having an unsuitable value for an operation, or it may be due to a malformed statement/command on that line. Depending on context, deferring error handling to the line the error occurs on may be a desirable or undesirable effect.\n\nCompare that to languages which do go through a processing step (typically, called parsing) before any execution occurs, as illustrated in Figure 2:\n\nFig. 2: Parsing + Compilation + Execution \n\nIn this processing model, an invalid command (such as broken syntax) on line 5 would be caught during the parsing phase, before any execution has begun, and none of the program would run. For catching syntax (or otherwise \"static\") errors, generally it's preferred to know about them ahead of any doomed partial execution.\n\nSo what do \"parsed\" languages have in common with \"compiled\" languages? First, all compiled languages are parsed. So a parsed language is quite a ways down the road toward being compiled already. In classic compilation theory, the last remaining step after parsing is code generation: producing an executable form.\n\nOnce any source program has been fully parsed, it's very common that its subsequent execution will, in some form or fashion, include a translation from the parsed form of the program\u2014usually called an Abstract Syntax Tree (AST)\u2014to that executable form.\n\nIn other words, parsed languages usually also perform code generation before execution, so it's not that much of a stretch to say that, in spirit, they're compiled languages.\n\nJS source code is parsed before it is executed. The specification requires as much, because it calls for \"early errors\"\u2014statically determined errors in code, such as a duplicate parameter name\u2014to be reported before the code starts executing. Those errors cannot be recognized without the code having been parsed.\n\nSo JS is a parsed language, but is it compiled?\n\nThe answer is closer to yes than no. The parsed JS is converted to an optimized (binary) form, and that \"code\" is subsequently executed (Figure 2); the engine does not commonly switch back into line-by-line execution (like Figure 1) mode after it has finished all the hard work of parsing\u2014most languages/engines wouldn't, because that would be highly inefficient.\n\nTo be specific, this \"compilation\" produces a binary byte code (of sorts), which is then handed to the \"JS virtual machine\" to execute. Some like to say this VM is \"interpreting\" the byte code. But then that means Java, and a dozen other JVM-driven languages, for that matter, are interpreted rather than compiled. Of course, that contradicts the typical assertion that Java/etc are compiled languages. \n\nInterestingly, while Java and JavaScript are very different languages, the question of interpreted/compiled is pretty closely related between them!\n\nAnother wrinkle is that JS engines can employ multiple passes of JIT (Just-In-Time) processing/optimization on the generated code (post parsing), which again could reasonably be labeled either \"compilation\" or \"interpretation\" depending on perspective. It's actually a fantastically complex situation under the hood of a JS engine.\n\nSo what do these nitty-gritty details boil down to? Step back and consider the entire flow of a JS source program:\n\nAfter a program leaves a developer's editor, it gets transpiled by Babel, then packed by Webpack (and perhaps half a dozen other build processes), then it gets delivered in that very different form to a JS engine.\n\nThe JS engine parses the code to an AST.\n\nThen the engine converts that AST to a kind-of byte code, a binary intermediate representation (IR), which is then refined/converted even further by the optimizing JIT compiler.\n\nFinally, the JS VM executes the program.\n\nTo visualize those steps, again:\n\nFig. 3: Parsing, Compiling, and Executing JS \n\nIs JS handled more like an interpreted, line-by-line script, as in Figure 1, or is it handled more like a compiled language that's processed in one-to-several passes first, before execution (as in Figures 2 and 3)?\n\nI think it's clear that in spirit, if not in practice, JS is a compiled language.\n\nAnd again, the reason that matters is, since JS is compiled, we are informed of static errors (such as malformed syntax) before our code is executed. That is a substantively different interaction model than we get with traditional \"scripting\" programs, and arguably more helpful!"}, "id": 113, "children": [{"data": {"uuid": "6396ffa1-5dbb-4e02-bcac-61a2d389d5ba", "user": 1, "title": "Web Assembly (WASM)", "author": "Kyle Simpson", "created_on": "2023-06-07 18:16:14.043386+00:00", "updated_on": "2023-06-07 18:16:41.136927+00:00", "article_html": "<h3>Web Assembly (WASM)</h3><p>One dominating concern that has driven a significant amount of JS's evolution is performance, both how quickly JS can be parsed/compiled and how quickly that compiled code can be executed.</p><p>In 2013, engineers from Mozilla Firefox demonstrated a port of the Unreal 3 game engine from C to JS. The ability for this code to run in a browser JS engine at full 60fps performance was predicated on a set of optimizations that the JS engine could perform specifically because the JS version of the Unreal engine's code used a style of code that favored a subset of the JS language, named \"ASM.js\".</p><p>This subset is valid JS written in ways that are somewhat uncommon in normal coding, but which signal certain important typing information to the engine that allow it to make key optimizations. ASM.js was introduced as one way of addressing the pressures on the runtime performance of JS.</p><p>But it's important to note that ASM.js was never intended to be code that was authored by developers, but rather a representation of a program having been transpiled from another language (such as C), where these typing \"annotations\" were inserted automatically by the tooling.</p><p>Several years after ASM.js demonstrated the validity of tooling-created versions of programs that can be processed more efficiently by the JS engine, another group of engineers (also, initially, from Mozilla) released Web Assembly (WASM).</p><p>WASM is similar to ASM.js in that its original intent was to provide a path for non-JS programs (C, etc.) to be converted to a form that could run in the JS engine. Unlike ASM.js, WASM chose to additionally get around some of the inherent delays in JS parsing/compilation before a program can execute, by representing the program in a form that is entirely unlike JS.</p><p>WASM is a representation format more akin to Assembly (hence, its name) that can be processed by a JS engine by skipping the parsing/compilation that the JS engine normally does. The parsing/compilation of a WASM-targeted program happen ahead of time (AOT); what's distributed is a binary-packed program ready for the JS engine to execute with very minimal processing.</p><p>An initial motivation for WASM was clearly the potential performance improvements. While that continues to be a focus, WASM is additionally motivated by the desire to bring more parity for non-JS languages to the web platform. For example, if a language like Go supports threaded programming, but JS (the language) does not, WASM offers the potential for such a Go program to be converted to a form the JS engine can understand, without needing a threads feature in the JS language itself.</p><p>In other words, WASM relieves the pressure to add features to JS that are mostly/exclusively intended to be used by transpiled programs from other languages. That means JS feature development can be judged (by TC39) without being skewed by interests/demands in other language ecosystems, while still letting those languages have a viable path onto the web.</p><p>Another perspective on WASM that's emerging is, interestingly, not even directly related to the web (W). WASM is evolving to become a cross-platform virtual machine (VM) of sorts, where programs can be compiled once and run in a variety of different system environments.</p><p>So, WASM isn't only for the web, and WASM also isn't JS. Ironically, even though WASM runs in the JS engine, the JS language is one of the least suitable languages to source WASM programs with, because WASM relies heavily on static typing information. Even TypeScript (TS)\u2014ostensibly, JS + static types\u2014is not quite suitable (as it stands) to transpile to WASM, though language variants like AssemblyScript are attempting to bridge the gap between JS/TS and WASM.</p><p>This book isn't about WASM, so I won't spend much more time discussing it, except to make one final point. <em>Some</em> folks have suggested WASM points to a future where JS is excised from, or minimized in, the web. These folks often harbor ill feelings about JS, and want some other language\u2014any other language!\u2014to replace it. Since WASM lets other languages run in the JS engine, on its face this isn't an entirely fanciful fairytale.</p><p>But let me just state simply: WASM will not replace JS. WASM significantly augments what the web (including JS) can accomplish. That's a great thing, entirely orthogonal to whether some people will use it as an escape hatch from having to write JS.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Web Assembly (WASM)", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One dominating concern that has driven a significant amount of JS's evolution is performance, both how quickly JS can be parsed/compiled and how quickly that compiled code can be executed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In 2013, engineers from Mozilla Firefox demonstrated a port of the Unreal 3 game engine from C to JS. The ability for this code to run in a browser JS engine at full 60fps performance was predicated on a set of optimizations that the JS engine could perform specifically because the JS version of the Unreal engine's code used a style of code that favored a subset of the JS language, named \"ASM.js\".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This subset is valid JS written in ways that are somewhat uncommon in normal coding, but which signal certain important typing information to the engine that allow it to make key optimizations. ASM.js was introduced as one way of addressing the pressures on the runtime performance of JS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But it's important to note that ASM.js was never intended to be code that was authored by developers, but rather a representation of a program having been transpiled from another language (such as C), where these typing \"annotations\" were inserted automatically by the tooling.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Several years after ASM.js demonstrated the validity of tooling-created versions of programs that can be processed more efficiently by the JS engine, another group of engineers (also, initially, from Mozilla) released Web Assembly (WASM).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "WASM is similar to ASM.js in that its original intent was to provide a path for non-JS programs (C, etc.) to be converted to a form that could run in the JS engine. Unlike ASM.js, WASM chose to additionally get around some of the inherent delays in JS parsing/compilation before a program can execute, by representing the program in a form that is entirely unlike JS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "WASM is a representation format more akin to Assembly (hence, its name) that can be processed by a JS engine by skipping the parsing/compilation that the JS engine normally does. The parsing/compilation of a WASM-targeted program happen ahead of time (AOT); what's distributed is a binary-packed program ready for the JS engine to execute with very minimal processing.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An initial motivation for WASM was clearly the potential performance improvements. While that continues to be a focus, WASM is additionally motivated by the desire to bring more parity for non-JS languages to the web platform. For example, if a language like Go supports threaded programming, but JS (the language) does not, WASM offers the potential for such a Go program to be converted to a form the JS engine can understand, without needing a threads feature in the JS language itself.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, WASM relieves the pressure to add features to JS that are mostly/exclusively intended to be used by transpiled programs from other languages. That means JS feature development can be judged (by TC39) without being skewed by interests/demands in other language ecosystems, while still letting those languages have a viable path onto the web.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another perspective on WASM that's emerging is, interestingly, not even directly related to the web (W). WASM is evolving to become a cross-platform virtual machine (VM) of sorts, where programs can be compiled once and run in a variety of different system environments.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So, WASM isn't only for the web, and WASM also isn't JS. Ironically, even though WASM runs in the JS engine, the JS language is one of the least suitable languages to source WASM programs with, because WASM relies heavily on static typing information. Even TypeScript (TS)\u2014ostensibly, JS + static types\u2014is not quite suitable (as it stands) to transpile to WASM, though language variants like AssemblyScript are attempting to bridge the gap between JS/TS and WASM.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This book isn't about WASM, so I won't spend much more time discussing it, except to make one final point. ", "type": "text"}, {"text": "Some", "type": "text", "marks": [{"type": "italic"}]}, {"text": " folks have suggested WASM points to a future where JS is excised from, or minimized in, the web. These folks often harbor ill feelings about JS, and want some other language\u2014any other language!\u2014to replace it. Since WASM lets other languages run in the JS engine, on its face this isn't an entirely fanciful fairytale.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But let me just state simply: WASM will not replace JS. WASM significantly augments what the web (including JS) can accomplish. That's a great thing, entirely orthogonal to whether some people will use it as an escape hatch from having to write JS.", "type": "text"}]}]}, "article_text": "Web Assembly (WASM)\n\nOne dominating concern that has driven a significant amount of JS's evolution is performance, both how quickly JS can be parsed/compiled and how quickly that compiled code can be executed.\n\nIn 2013, engineers from Mozilla Firefox demonstrated a port of the Unreal 3 game engine from C to JS. The ability for this code to run in a browser JS engine at full 60fps performance was predicated on a set of optimizations that the JS engine could perform specifically because the JS version of the Unreal engine's code used a style of code that favored a subset of the JS language, named \"ASM.js\".\n\nThis subset is valid JS written in ways that are somewhat uncommon in normal coding, but which signal certain important typing information to the engine that allow it to make key optimizations. ASM.js was introduced as one way of addressing the pressures on the runtime performance of JS.\n\nBut it's important to note that ASM.js was never intended to be code that was authored by developers, but rather a representation of a program having been transpiled from another language (such as C), where these typing \"annotations\" were inserted automatically by the tooling.\n\nSeveral years after ASM.js demonstrated the validity of tooling-created versions of programs that can be processed more efficiently by the JS engine, another group of engineers (also, initially, from Mozilla) released Web Assembly (WASM).\n\nWASM is similar to ASM.js in that its original intent was to provide a path for non-JS programs (C, etc.) to be converted to a form that could run in the JS engine. Unlike ASM.js, WASM chose to additionally get around some of the inherent delays in JS parsing/compilation before a program can execute, by representing the program in a form that is entirely unlike JS.\n\nWASM is a representation format more akin to Assembly (hence, its name) that can be processed by a JS engine by skipping the parsing/compilation that the JS engine normally does. The parsing/compilation of a WASM-targeted program happen ahead of time (AOT); what's distributed is a binary-packed program ready for the JS engine to execute with very minimal processing.\n\nAn initial motivation for WASM was clearly the potential performance improvements. While that continues to be a focus, WASM is additionally motivated by the desire to bring more parity for non-JS languages to the web platform. For example, if a language like Go supports threaded programming, but JS (the language) does not, WASM offers the potential for such a Go program to be converted to a form the JS engine can understand, without needing a threads feature in the JS language itself.\n\nIn other words, WASM relieves the pressure to add features to JS that are mostly/exclusively intended to be used by transpiled programs from other languages. That means JS feature development can be judged (by TC39) without being skewed by interests/demands in other language ecosystems, while still letting those languages have a viable path onto the web.\n\nAnother perspective on WASM that's emerging is, interestingly, not even directly related to the web (W). WASM is evolving to become a cross-platform virtual machine (VM) of sorts, where programs can be compiled once and run in a variety of different system environments.\n\nSo, WASM isn't only for the web, and WASM also isn't JS. Ironically, even though WASM runs in the JS engine, the JS language is one of the least suitable languages to source WASM programs with, because WASM relies heavily on static typing information. Even TypeScript (TS)\u2014ostensibly, JS + static types\u2014is not quite suitable (as it stands) to transpile to WASM, though language variants like AssemblyScript are attempting to bridge the gap between JS/TS and WASM.\n\nThis book isn't about WASM, so I won't spend much more time discussing it, except to make one final point. Some folks have suggested WASM points to a future where JS is excised from, or minimized in, the web. These folks often harbor ill feelings about JS, and want some other language\u2014any other language!\u2014to replace it. Since WASM lets other languages run in the JS engine, on its face this isn't an entirely fanciful fairytale.\n\nBut let me just state simply: WASM will not replace JS. WASM significantly augments what the web (including JS) can accomplish. That's a great thing, entirely orthogonal to whether some people will use it as an escape hatch from having to write JS."}, "id": 114}]}, {"data": {"uuid": "20f527f4-5e1a-47da-8471-db19c1dd386a", "user": 1, "title": "Strictly Speaking", "author": "Kyle Simpson", "created_on": "2023-06-07 18:17:14.973503+00:00", "updated_on": "2023-06-07 18:17:47.428029+00:00", "article_html": "<h2><em>Strict</em>ly Speaking</h2><p>Back in 2009 with the release of ES5, JS added <em>strict mode</em> as an opt-in mechanism for encouraging better JS programs.</p><p>The benefits of strict mode far outweigh the costs, but old habits die hard and the inertia of existing (aka \"legacy\") code bases is really hard to shift. So sadly, more than 10 years later, strict mode's <em>optionality</em> means that it's still not necessarily the default for JS programmers.</p><p>Why strict mode? Strict mode shouldn't be thought of as a restriction on what you can't do, but rather as a guide to the best way to do things so that the JS engine has the best chance of optimizing and efficiently running the code. Most JS code is worked on by teams of developers, so the <em>strict</em>-ness of strict mode (along with tooling like linters!) often helps collaboration on code by avoiding some of the more problematic mistakes that slip by in non-strict mode.</p><p>Most strict mode controls are in the form of <em>early errors</em>, meaning errors that aren't strictly syntax errors but are still thrown at compile time (before the code is run). For example, strict mode disallows naming two function parameters the same, and results in an early error. Some other strict mode controls are only observable at runtime, such as how <code>this</code> defaults to <code>undefined</code> instead of the global object.</p><p>Rather than fighting and arguing with strict mode, like a kid who just wants to defy whatever their parents tell them not to do, the best mindset is that strict mode is like a linter reminding you how JS <em>should</em> be written to have the highest quality and best chance at performance. If you find yourself feeling handcuffed, trying to work around strict mode, that should be a blaring red warning flag that you need to back up and rethink the whole approach.</p><p>Strict mode is switched on per file with a special pragma (nothing allowed before it except comments/whitespace):</p><pre><code>// only whitespace and comments are allowed\n// before the use-strict pragma\n\"use strict\";\n// the rest of the file runs in strict mode</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Something to be aware of is that even a stray <code>;</code> all by itself appearing before the strict mode pragma will render the pragma useless; no errors are thrown because it's valid JS to have a string literal expression in a statement position, but it also will silently <em>not</em> turn on strict mode!</p></td></tr></tbody></table><p>Strict mode can alternatively be turned on per-function scope, with exactly the same rules about its surroundings:</p><pre><code>function someOperations() {\n    // whitespace and comments are fine here\n    \"use strict\";\n\n    // all this code will run in strict mode\n}</code></pre><p>Interestingly, if a file has strict mode turned on, the function-level strict mode pragmas are disallowed. So you have to pick one or the other.</p><p>The <strong>only</strong> valid reason to use a per-function approach to strict mode is when you are converting an existing non-strict mode program file and need to make the changes little by little over time. Otherwise, it's vastly better to simply turn strict mode on for the entire file/program.</p><p>Many have wondered if there would ever be a time when JS made strict mode the default? The answer is, almost certainly not. As we discussed earlier around backwards compatibility, if a JS engine update started assuming code was strict mode even if it's not marked as such, it's possible that this code would break as a result of strict mode's controls.</p><p>However, there are a few factors that reduce the future impact of this non-default \"obscurity\" of strict mode.</p><p>For one, virtually all transpiled code ends up in strict mode even if the original source code isn't written as such. Most JS code in production has been transpiled, so that means most JS is already adhering to strict mode. It's possible to undo that assumption, but you really have to go out of your way to do so, so it's highly unlikely.</p><p>Moreover, a wide shift is happening toward more/most new JS code being written using the ES6 module format. ES6 modules assume strict mode, so all code in such files is automatically defaulted to strict mode.</p><p>Taken together, strict mode is largely the de facto default even though technically it's not actually the default.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Strict", "type": "text", "marks": [{"type": "italic"}]}, {"text": "ly Speaking", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Back in 2009 with the release of ES5, JS added ", "type": "text"}, {"text": "strict mode", "type": "text", "marks": [{"type": "italic"}]}, {"text": " as an opt-in mechanism for encouraging better JS programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The benefits of strict mode far outweigh the costs, but old habits die hard and the inertia of existing (aka \"legacy\") code bases is really hard to shift. So sadly, more than 10 years later, strict mode's ", "type": "text"}, {"text": "optionality", "type": "text", "marks": [{"type": "italic"}]}, {"text": " means that it's still not necessarily the default for JS programmers.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Why strict mode? Strict mode shouldn't be thought of as a restriction on what you can't do, but rather as a guide to the best way to do things so that the JS engine has the best chance of optimizing and efficiently running the code. Most JS code is worked on by teams of developers, so the ", "type": "text"}, {"text": "strict", "type": "text", "marks": [{"type": "italic"}]}, {"text": "-ness of strict mode (along with tooling like linters!) often helps collaboration on code by avoiding some of the more problematic mistakes that slip by in non-strict mode.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Most strict mode controls are in the form of ", "type": "text"}, {"text": "early errors", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", meaning errors that aren't strictly syntax errors but are still thrown at compile time (before the code is run). For example, strict mode disallows naming two function parameters the same, and results in an early error. Some other strict mode controls are only observable at runtime, such as how ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " defaults to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of the global object.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Rather than fighting and arguing with strict mode, like a kid who just wants to defy whatever their parents tell them not to do, the best mindset is that strict mode is like a linter reminding you how JS ", "type": "text"}, {"text": "should", "type": "text", "marks": [{"type": "italic"}]}, {"text": " be written to have the highest quality and best chance at performance. If you find yourself feeling handcuffed, trying to work around strict mode, that should be a blaring red warning flag that you need to back up and rethink the whole approach.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Strict mode is switched on per file with a special pragma (nothing allowed before it except comments/whitespace):", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// only whitespace and comments are allowed\n// before the use-strict pragma\n\"use strict\";\n// the rest of the file runs in strict mode", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Something to be aware of is that even a stray ", "type": "text"}, {"text": ";", "type": "text", "marks": [{"type": "code"}]}, {"text": " all by itself appearing before the strict mode pragma will render the pragma useless; no errors are thrown because it's valid JS to have a string literal expression in a statement position, but it also will silently ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "italic"}]}, {"text": " turn on strict mode!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Strict mode can alternatively be turned on per-function scope, with exactly the same rules about its surroundings:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function someOperations() {\n    // whitespace and comments are fine here\n    \"use strict\";\n\n    // all this code will run in strict mode\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Interestingly, if a file has strict mode turned on, the function-level strict mode pragmas are disallowed. So you have to pick one or the other.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "only", "type": "text", "marks": [{"type": "bold"}]}, {"text": " valid reason to use a per-function approach to strict mode is when you are converting an existing non-strict mode program file and need to make the changes little by little over time. Otherwise, it's vastly better to simply turn strict mode on for the entire file/program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Many have wondered if there would ever be a time when JS made strict mode the default? The answer is, almost certainly not. As we discussed earlier around backwards compatibility, if a JS engine update started assuming code was strict mode even if it's not marked as such, it's possible that this code would break as a result of strict mode's controls.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However, there are a few factors that reduce the future impact of this non-default \"obscurity\" of strict mode.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For one, virtually all transpiled code ends up in strict mode even if the original source code isn't written as such. Most JS code in production has been transpiled, so that means most JS is already adhering to strict mode. It's possible to undo that assumption, but you really have to go out of your way to do so, so it's highly unlikely.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Moreover, a wide shift is happening toward more/most new JS code being written using the ES6 module format. ES6 modules assume strict mode, so all code in such files is automatically defaulted to strict mode.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Taken together, strict mode is largely the de facto default even though technically it's not actually the default.", "type": "text"}]}]}, "article_text": "Strictly Speaking\n\nBack in 2009 with the release of ES5, JS added strict mode as an opt-in mechanism for encouraging better JS programs.\n\nThe benefits of strict mode far outweigh the costs, but old habits die hard and the inertia of existing (aka \"legacy\") code bases is really hard to shift. So sadly, more than 10 years later, strict mode's optionality means that it's still not necessarily the default for JS programmers.\n\nWhy strict mode? Strict mode shouldn't be thought of as a restriction on what you can't do, but rather as a guide to the best way to do things so that the JS engine has the best chance of optimizing and efficiently running the code. Most JS code is worked on by teams of developers, so the strict-ness of strict mode (along with tooling like linters!) often helps collaboration on code by avoiding some of the more problematic mistakes that slip by in non-strict mode.\n\nMost strict mode controls are in the form of early errors, meaning errors that aren't strictly syntax errors but are still thrown at compile time (before the code is run). For example, strict mode disallows naming two function parameters the same, and results in an early error. Some other strict mode controls are only observable at runtime, such as how this defaults to undefined instead of the global object.\n\nRather than fighting and arguing with strict mode, like a kid who just wants to defy whatever their parents tell them not to do, the best mindset is that strict mode is like a linter reminding you how JS should be written to have the highest quality and best chance at performance. If you find yourself feeling handcuffed, trying to work around strict mode, that should be a blaring red warning flag that you need to back up and rethink the whole approach.\n\nStrict mode is switched on per file with a special pragma (nothing allowed before it except comments/whitespace):\n\n// only whitespace and comments are allowed\n// before the use-strict pragma\n\"use strict\";\n// the rest of the file runs in strict mode\n\nWARNING:\n\nSomething to be aware of is that even a stray ; all by itself appearing before the strict mode pragma will render the pragma useless; no errors are thrown because it's valid JS to have a string literal expression in a statement position, but it also will silently not turn on strict mode!\n\nStrict mode can alternatively be turned on per-function scope, with exactly the same rules about its surroundings:\n\nfunction someOperations() {\n    // whitespace and comments are fine here\n    \"use strict\";\n\n    // all this code will run in strict mode\n}\n\nInterestingly, if a file has strict mode turned on, the function-level strict mode pragmas are disallowed. So you have to pick one or the other.\n\nThe only valid reason to use a per-function approach to strict mode is when you are converting an existing non-strict mode program file and need to make the changes little by little over time. Otherwise, it's vastly better to simply turn strict mode on for the entire file/program.\n\nMany have wondered if there would ever be a time when JS made strict mode the default? The answer is, almost certainly not. As we discussed earlier around backwards compatibility, if a JS engine update started assuming code was strict mode even if it's not marked as such, it's possible that this code would break as a result of strict mode's controls.\n\nHowever, there are a few factors that reduce the future impact of this non-default \"obscurity\" of strict mode.\n\nFor one, virtually all transpiled code ends up in strict mode even if the original source code isn't written as such. Most JS code in production has been transpiled, so that means most JS is already adhering to strict mode. It's possible to undo that assumption, but you really have to go out of your way to do so, so it's highly unlikely.\n\nMoreover, a wide shift is happening toward more/most new JS code being written using the ES6 module format. ES6 modules assume strict mode, so all code in such files is automatically defaulted to strict mode.\n\nTaken together, strict mode is largely the de facto default even though technically it's not actually the default."}, "id": 115}, {"data": {"uuid": "025d7cd7-bd78-4938-b7bc-308a12f2e3bd", "user": 1, "title": "Defined", "author": "Kyle Simpson", "created_on": "2023-06-07 18:18:08.985644+00:00", "updated_on": "2023-06-07 18:18:57.910670+00:00", "article_html": "<h2>Defined</h2><p>JS is an implementation of the ECMAScript standard (version ES2019 as of this writing), which is guided by the TC39 committee and hosted by ECMA. It runs in browsers and other JS environments such as Node.js.</p><p>JS is a multi-paradigm language, meaning the syntax and capabilities allow a developer to mix and match (and bend and reshape!) concepts from various major paradigms, such as procedural, object-oriented (OO/classes), and functional (FP).</p><p>JS is a compiled language, meaning the tools (including the JS engine) process and verify a program (reporting any errors!) before it executes.</p><p>With our language now <em>defined</em>, let's start getting to know its ins and outs.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Defined", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS is an implementation of the ECMAScript standard (version ES2019 as of this writing), which is guided by the TC39 committee and hosted by ECMA. It runs in browsers and other JS environments such as Node.js.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS is a multi-paradigm language, meaning the syntax and capabilities allow a developer to mix and match (and bend and reshape!) concepts from various major paradigms, such as procedural, object-oriented (OO/classes), and functional (FP).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS is a compiled language, meaning the tools (including the JS engine) process and verify a program (reporting any errors!) before it executes.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With our language now ", "type": "text"}, {"text": "defined", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", let's start getting to know its ins and outs.", "type": "text"}]}]}, "article_text": "Defined\n\nJS is an implementation of the ECMAScript standard (version ES2019 as of this writing), which is guided by the TC39 committee and hosted by ECMA. It runs in browsers and other JS environments such as Node.js.\n\nJS is a multi-paradigm language, meaning the syntax and capabilities allow a developer to mix and match (and bend and reshape!) concepts from various major paradigms, such as procedural, object-oriented (OO/classes), and functional (FP).\n\nJS is a compiled language, meaning the tools (including the JS engine) process and verify a program (reporting any errors!) before it executes.\n\nWith our language now defined, let's start getting to know its ins and outs."}, "id": 116}]}, {"data": {"uuid": "586ff244-5019-4c7b-82fc-e598b471232c", "user": 1, "title": "Chapter 2: Surveying JS", "author": "Kyle Simpson", "created_on": "2023-06-07 18:43:45.792111+00:00", "updated_on": "2023-06-07 18:44:08.129501+00:00", "article_html": "<h1>Chapter 2: Surveying JS</h1><p>The best way to learn JS is to start writing JS.</p><p>To do that, you need to know how the language works, and that's what we'll focus on here. Even if you've programmed in other languages before, take your time getting comfortable with JS, and make sure to practice each piece.</p><p>This chapter is not an exhaustive reference on every bit of syntax of the JS language. It's also not intended to be a complete \"intro to JS\" primer.</p><p>Instead, we're just going to survey some of the major topic areas of the language. Our goal is to get a better <em>feel</em> for it, so that we can move forward writing our own programs with more confidence. We'll revisit many of these topics in successively more detail as you go through the rest of this book, and the rest of the series.</p><p>Please don't expect this chapter to be a quick read. It's long and there's plenty of detail to chew on. Take your time.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>If you're still getting familiar with JS, I suggest you reserve plenty of extra time to work through this chapter. Take each section and ponder and explore the topic for awhile. Look through existing JS programs and compare what you see in them to the code and explanations (and opinions!) presented here. You will get a lot more out of the rest of the book and series with a solid foundation of JS's <em>nature</em>.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 2: Surveying JS", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The best way to learn JS is to start writing JS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To do that, you need to know how the language works, and that's what we'll focus on here. Even if you've programmed in other languages before, take your time getting comfortable with JS, and make sure to practice each piece.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This chapter is not an exhaustive reference on every bit of syntax of the JS language. It's also not intended to be a complete \"intro to JS\" primer.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Instead, we're just going to survey some of the major topic areas of the language. Our goal is to get a better ", "type": "text"}, {"text": "feel", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for it, so that we can move forward writing our own programs with more confidence. We'll revisit many of these topics in successively more detail as you go through the rest of this book, and the rest of the series.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Please don't expect this chapter to be a quick read. It's long and there's plenty of detail to chew on. Take your time.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "If you're still getting familiar with JS, I suggest you reserve plenty of extra time to work through this chapter. Take each section and ponder and explore the topic for awhile. Look through existing JS programs and compare what you see in them to the code and explanations (and opinions!) presented here. You will get a lot more out of the rest of the book and series with a solid foundation of JS's ", "type": "text"}, {"text": "nature", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}]}]}]}]}, "article_text": "Chapter 2: Surveying JS\n\nThe best way to learn JS is to start writing JS.\n\nTo do that, you need to know how the language works, and that's what we'll focus on here. Even if you've programmed in other languages before, take your time getting comfortable with JS, and make sure to practice each piece.\n\nThis chapter is not an exhaustive reference on every bit of syntax of the JS language. It's also not intended to be a complete \"intro to JS\" primer.\n\nInstead, we're just going to survey some of the major topic areas of the language. Our goal is to get a better feel for it, so that we can move forward writing our own programs with more confidence. We'll revisit many of these topics in successively more detail as you go through the rest of this book, and the rest of the series.\n\nPlease don't expect this chapter to be a quick read. It's long and there's plenty of detail to chew on. Take your time.\n\nTIP:\n\nIf you're still getting familiar with JS, I suggest you reserve plenty of extra time to work through this chapter. Take each section and ponder and explore the topic for awhile. Look through existing JS programs and compare what you see in them to the code and explanations (and opinions!) presented here. You will get a lot more out of the rest of the book and series with a solid foundation of JS's nature."}, "id": 117, "children": [{"data": {"uuid": "cf0dc25a-8fb6-4a4b-9c86-0494c0aa94f2", "user": 1, "title": "Each File is a Program", "author": "Kyle Simpson", "created_on": "2023-06-07 18:45:13.641386+00:00", "updated_on": "2023-06-07 18:45:45.464796+00:00", "article_html": "<h2>Each File is a Program</h2><p>Almost every website (web application) you use is comprised of many different JS files (typically with the .js file extension). It's tempting to think of the whole thing (the application) as one program. But JS sees it differently.</p><p>In JS, each standalone file is its own separate program.</p><p>The reason this matters is primarily around error handling. Since JS treats files as programs, one file may fail (during parse/compile or execution) and that will not necessarily prevent the next file from being processed. Obviously, if your application depends on five .js files, and one of them fails, the overall application will probably only partially operate, at best. It's important to ensure that each file works properly, and that to whatever extent possible, they handle failure in other files as gracefully as possible.</p><p>It may surprise you to consider separate .js files as separate JS programs. From the perspective of your usage of an application, it sure seems like one big program. That's because the execution of the application allows these individual <em>programs</em> to cooperate and act as one program.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Many projects use build process tools that end up combining separate files from the project into a single file to be delivered to a web page. When this happens, JS treats this single combined file as the entire program.</p></td></tr></tbody></table><p>The only way multiple standalone .js files act as a single program is by sharing their state (and access to their public functionality) via the \"global scope.\" They mix together in this global scope namespace, so at runtime they act as a whole.</p><p>Since ES6, JS has also supported a module format in addition to the typical standalone JS program format. Modules are also file-based. If a file is loaded via module-loading mechanism such as an <code>import</code> statement or a <code>&lt;script type=module&gt;</code> tag, all its code is treated as a single module.</p><p>Though you wouldn't typically think about a module\u2014a collection of state and publicly exposed methods to operate on that state\u2014as a standalone program, JS does in fact still treat each module separately. Similar to how \"global scope\" allows standalone files to mix together at runtime, importing a module into another allows runtime interoperation between them.</p><p>Regardless of which code organization pattern (and loading mechanism) is used for a file (standalone or module), you should still think of each file as its own (mini) program, which may then cooperate with other (mini) programs to perform the functions of your overall application.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Each File is a Program", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Almost every website (web application) you use is comprised of many different JS files (typically with the .js file extension). It's tempting to think of the whole thing (the application) as one program. But JS sees it differently.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In JS, each standalone file is its own separate program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The reason this matters is primarily around error handling. Since JS treats files as programs, one file may fail (during parse/compile or execution) and that will not necessarily prevent the next file from being processed. Obviously, if your application depends on five .js files, and one of them fails, the overall application will probably only partially operate, at best. It's important to ensure that each file works properly, and that to whatever extent possible, they handle failure in other files as gracefully as possible.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It may surprise you to consider separate .js files as separate JS programs. From the perspective of your usage of an application, it sure seems like one big program. That's because the execution of the application allows these individual ", "type": "text"}, {"text": "programs", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to cooperate and act as one program.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Many projects use build process tools that end up combining separate files from the project into a single file to be delivered to a web page. When this happens, JS treats this single combined file as the entire program.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "The only way multiple standalone .js files act as a single program is by sharing their state (and access to their public functionality) via the \"global scope.\" They mix together in this global scope namespace, so at runtime they act as a whole.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since ES6, JS has also supported a module format in addition to the typical standalone JS program format. Modules are also file-based. If a file is loaded via module-loading mechanism such as an ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement or a ", "type": "text"}, {"text": "<script type=module>", "type": "text", "marks": [{"type": "code"}]}, {"text": " tag, all its code is treated as a single module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though you wouldn't typically think about a module\u2014a collection of state and publicly exposed methods to operate on that state\u2014as a standalone program, JS does in fact still treat each module separately. Similar to how \"global scope\" allows standalone files to mix together at runtime, importing a module into another allows runtime interoperation between them.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Regardless of which code organization pattern (and loading mechanism) is used for a file (standalone or module), you should still think of each file as its own (mini) program, which may then cooperate with other (mini) programs to perform the functions of your overall application.", "type": "text"}]}]}, "article_text": "Each File is a Program\n\nAlmost every website (web application) you use is comprised of many different JS files (typically with the .js file extension). It's tempting to think of the whole thing (the application) as one program. But JS sees it differently.\n\nIn JS, each standalone file is its own separate program.\n\nThe reason this matters is primarily around error handling. Since JS treats files as programs, one file may fail (during parse/compile or execution) and that will not necessarily prevent the next file from being processed. Obviously, if your application depends on five .js files, and one of them fails, the overall application will probably only partially operate, at best. It's important to ensure that each file works properly, and that to whatever extent possible, they handle failure in other files as gracefully as possible.\n\nIt may surprise you to consider separate .js files as separate JS programs. From the perspective of your usage of an application, it sure seems like one big program. That's because the execution of the application allows these individual programs to cooperate and act as one program.\n\nNOTE:\n\nMany projects use build process tools that end up combining separate files from the project into a single file to be delivered to a web page. When this happens, JS treats this single combined file as the entire program.\n\nThe only way multiple standalone .js files act as a single program is by sharing their state (and access to their public functionality) via the \"global scope.\" They mix together in this global scope namespace, so at runtime they act as a whole.\n\nSince ES6, JS has also supported a module format in addition to the typical standalone JS program format. Modules are also file-based. If a file is loaded via module-loading mechanism such as an import statement or a <script type=module> tag, all its code is treated as a single module.\n\nThough you wouldn't typically think about a module\u2014a collection of state and publicly exposed methods to operate on that state\u2014as a standalone program, JS does in fact still treat each module separately. Similar to how \"global scope\" allows standalone files to mix together at runtime, importing a module into another allows runtime interoperation between them.\n\nRegardless of which code organization pattern (and loading mechanism) is used for a file (standalone or module), you should still think of each file as its own (mini) program, which may then cooperate with other (mini) programs to perform the functions of your overall application."}, "id": 118}, {"data": {"uuid": "cc1f6a63-038a-4d43-964d-f9f97a091e80", "user": 1, "title": "Values", "author": "Kyle Simpson", "created_on": "2023-06-07 18:46:04.706607+00:00", "updated_on": "2023-06-07 18:46:44.417649+00:00", "article_html": "<h2>Values</h2><p>The most fundamental unit of information in a program is a value. Values are data. They're how the program maintains state. Values come in two forms in JS: <strong>primitive</strong> and <strong>object</strong>.</p><p>Values are embedded in programs using <em>literals</em>:</p><pre><code>greeting(\"My name is Kyle.\");</code></pre><p>In this program, the value <code>\"My name is Kyle.\"</code> is a primitive string literal; strings are ordered collections of characters, usually used to represent words and sentences.</p><p>I used the double-quote <code>\"</code> character to <em>delimit</em> (surround, separate, define) the string value. But I could have used the single-quote <code>'</code> character as well. The choice of which quote character is entirely stylistic. The important thing, for the sake of code readability and maintainability, is to pick one and to use it consistently throughout the program.</p><p>Another option to delimit a string literal is to use the back-tick <code>`</code> character. However, this choice is not merely stylistic; there's a behavioral difference as well. Consider:</p><pre><code>console.log(\"My name is ${ firstName }.\");\n// My name is ${ firstName }.\n\nconsole.log('My name is ${ firstName }.');\n// My name is ${ firstName }.\n\nconsole.log(`My name is ${ firstName }.`);\n// My name is Kyle.</code></pre><p>Assuming this program has already defined a variable <code>firstName</code> with the string value <code>\"Kyle\"</code>, the <code>`</code>-delimited string then resolves the variable expression (indicated with <code>${ .. }</code>) to its current value. This is called <strong>interpolation</strong>.</p><p>The back-tick <code>`</code>-delimited string can be used without including interpolated expressions, but that defeats the whole purpose of that alternate string literal syntax:</p><pre><code>console.log(\n    `Am I confusing you by omitting interpolation?`\n);\n// Am I confusing you by omitting interpolation?</code></pre><p>The better approach is to use <code>\"</code> or <code>'</code> (again, pick one and stick to it!) for strings <em>unless you need</em> interpolation; reserve <code>`</code> only for strings that will include interpolated expressions.</p><p>Other than strings, JS programs often contain other primitive literal values such as booleans and numbers:</p><pre><code>while (false) {\n    console.log(3.141592);\n}</code></pre><p><code>while</code> represents a loop type, a way to repeat operations <em>while</em> its condition is true.</p><p>In this case, the loop will never run (and nothing will be printed), because we used the <code>false</code> boolean value as the loop conditional. <code>true</code> would have resulted in a loop that keeps going forever, so be careful!</p><p>The number <code>3.141592</code> is, as you may know, an approximation of mathematical PI to the first six digits. Rather than embed such a value, however, you would typically use the predefined <code>Math.PI</code> value for that purpose. Another variation on numbers is the <code>bigint</code> (big-integer) primitive type, which is used for storing arbitrarily large numbers.</p><p>Numbers are most often used in programs for counting steps, such as loop iterations, and accessing information in numeric positions (i.e., an array index). We'll cover arrays/objects in a little bit, but as an example, if there was an array called <code>names</code>, we could access the element in its second position like this:</p><pre><code>console.log(`My name is ${ names[1] }.`);\n// My name is Kyle.</code></pre><p>We used <code>1</code> for the element in the second position, instead of <code>2</code>, because like in most programming languages, JS array indices are 0-based (<code>0</code> is the first position).</p><p>In addition to strings, numbers, and booleans, two other <em>primitive</em> values in JS programs are <code>null</code> and <code>undefined</code>. While there are differences between them (some historic and some contemporary), for the most part both values serve the purpose of indicating <em>emptiness</em> (or absence) of a value.</p><p>Many developers prefer to treat them both consistently in this fashion, which is to say that the values are assumed to be indistinguishable. If care is taken, this is often possible. However, it's safest and best to use only <code>undefined</code> as the single empty value, even though <code>null</code> seems attractive in that it's shorter to type!</p><pre><code>while (value != undefined) {\n    console.log(\"Still got something!\");\n}</code></pre><p>The final primitive value to be aware of is a symbol, which is a special-purpose value that behaves as a hidden unguessable value. Symbols are almost exclusively used as special keys on objects:</p><pre><code>hitchhikersGuide[ Symbol(\"meaning of life\") ];\n// 42</code></pre><p>You won't encounter direct usage of symbols very often in typical JS programs. They're mostly used in low-level code such as in libraries and frameworks.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Values", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The most fundamental unit of information in a program is a value. Values are data. They're how the program maintains state. Values come in two forms in JS: ", "type": "text"}, {"text": "primitive", "type": "text", "marks": [{"type": "bold"}]}, {"text": " and ", "type": "text"}, {"text": "object", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Values are embedded in programs using ", "type": "text"}, {"text": "literals", "type": "text", "marks": [{"type": "italic"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "greeting(\"My name is Kyle.\");", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this program, the value ", "type": "text"}, {"text": "\"My name is Kyle.\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a primitive string literal; strings are ordered collections of characters, usually used to represent words and sentences.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I used the double-quote ", "type": "text"}, {"text": "\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " character to ", "type": "text"}, {"text": "delimit", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (surround, separate, define) the string value. But I could have used the single-quote ", "type": "text"}, {"text": "'", "type": "text", "marks": [{"type": "code"}]}, {"text": " character as well. The choice of which quote character is entirely stylistic. The important thing, for the sake of code readability and maintainability, is to pick one and to use it consistently throughout the program.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another option to delimit a string literal is to use the back-tick ", "type": "text"}, {"text": "`", "type": "text", "marks": [{"type": "code"}]}, {"text": " character. However, this choice is not merely stylistic; there's a behavioral difference as well. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "console.log(\"My name is ${ firstName }.\");\n// My name is ${ firstName }.\n\nconsole.log('My name is ${ firstName }.');\n// My name is ${ firstName }.\n\nconsole.log(`My name is ${ firstName }.`);\n// My name is Kyle.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Assuming this program has already defined a variable ", "type": "text"}, {"text": "firstName", "type": "text", "marks": [{"type": "code"}]}, {"text": " with the string value ", "type": "text"}, {"text": "\"Kyle\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the ", "type": "text"}, {"text": "`", "type": "text", "marks": [{"type": "code"}]}, {"text": "-delimited string then resolves the variable expression (indicated with ", "type": "text"}, {"text": "${ .. }", "type": "text", "marks": [{"type": "code"}]}, {"text": ") to its current value. This is called ", "type": "text"}, {"text": "interpolation", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The back-tick ", "type": "text"}, {"text": "`", "type": "text", "marks": [{"type": "code"}]}, {"text": "-delimited string can be used without including interpolated expressions, but that defeats the whole purpose of that alternate string literal syntax:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "console.log(\n    `Am I confusing you by omitting interpolation?`\n);\n// Am I confusing you by omitting interpolation?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The better approach is to use ", "type": "text"}, {"text": "\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "'", "type": "text", "marks": [{"type": "code"}]}, {"text": " (again, pick one and stick to it!) for strings ", "type": "text"}, {"text": "unless you need", "type": "text", "marks": [{"type": "italic"}]}, {"text": " interpolation; reserve ", "type": "text"}, {"text": "`", "type": "text", "marks": [{"type": "code"}]}, {"text": " only for strings that will include interpolated expressions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Other than strings, JS programs often contain other primitive literal values such as booleans and numbers:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "while (false) {\n    console.log(3.141592);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "while", "type": "text", "marks": [{"type": "code"}]}, {"text": " represents a loop type, a way to repeat operations ", "type": "text"}, {"text": "while", "type": "text", "marks": [{"type": "italic"}]}, {"text": " its condition is true.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this case, the loop will never run (and nothing will be printed), because we used the ", "type": "text"}, {"text": "false", "type": "text", "marks": [{"type": "code"}]}, {"text": " boolean value as the loop conditional. ", "type": "text"}, {"text": "true", "type": "text", "marks": [{"type": "code"}]}, {"text": " would have resulted in a loop that keeps going forever, so be careful!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The number ", "type": "text"}, {"text": "3.141592", "type": "text", "marks": [{"type": "code"}]}, {"text": " is, as you may know, an approximation of mathematical PI to the first six digits. Rather than embed such a value, however, you would typically use the predefined ", "type": "text"}, {"text": "Math.PI", "type": "text", "marks": [{"type": "code"}]}, {"text": " value for that purpose. Another variation on numbers is the ", "type": "text"}, {"text": "bigint", "type": "text", "marks": [{"type": "code"}]}, {"text": " (big-integer) primitive type, which is used for storing arbitrarily large numbers.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Numbers are most often used in programs for counting steps, such as loop iterations, and accessing information in numeric positions (i.e., an array index). We'll cover arrays/objects in a little bit, but as an example, if there was an array called ", "type": "text"}, {"text": "names", "type": "text", "marks": [{"type": "code"}]}, {"text": ", we could access the element in its second position like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "console.log(`My name is ${ names[1] }.`);\n// My name is Kyle.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We used ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": " for the element in the second position, instead of ", "type": "text"}, {"text": "2", "type": "text", "marks": [{"type": "code"}]}, {"text": ", because like in most programming languages, JS array indices are 0-based (", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": " is the first position).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In addition to strings, numbers, and booleans, two other ", "type": "text"}, {"text": "primitive", "type": "text", "marks": [{"type": "italic"}]}, {"text": " values in JS programs are ", "type": "text"}, {"text": "null", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ". While there are differences between them (some historic and some contemporary), for the most part both values serve the purpose of indicating ", "type": "text"}, {"text": "emptiness", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (or absence) of a value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Many developers prefer to treat them both consistently in this fashion, which is to say that the values are assumed to be indistinguishable. If care is taken, this is often possible. However, it's safest and best to use only ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": " as the single empty value, even though ", "type": "text"}, {"text": "null", "type": "text", "marks": [{"type": "code"}]}, {"text": " seems attractive in that it's shorter to type!", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "while (value != undefined) {\n    console.log(\"Still got something!\");\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The final primitive value to be aware of is a symbol, which is a special-purpose value that behaves as a hidden unguessable value. Symbols are almost exclusively used as special keys on objects:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "hitchhikersGuide[ Symbol(\"meaning of life\") ];\n// 42", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You won't encounter direct usage of symbols very often in typical JS programs. They're mostly used in low-level code such as in libraries and frameworks.", "type": "text"}]}]}, "article_text": "Values\n\nThe most fundamental unit of information in a program is a value. Values are data. They're how the program maintains state. Values come in two forms in JS: primitive and object.\n\nValues are embedded in programs using literals:\n\ngreeting(\"My name is Kyle.\");\n\nIn this program, the value \"My name is Kyle.\" is a primitive string literal; strings are ordered collections of characters, usually used to represent words and sentences.\n\nI used the double-quote \" character to delimit (surround, separate, define) the string value. But I could have used the single-quote ' character as well. The choice of which quote character is entirely stylistic. The important thing, for the sake of code readability and maintainability, is to pick one and to use it consistently throughout the program.\n\nAnother option to delimit a string literal is to use the back-tick ` character. However, this choice is not merely stylistic; there's a behavioral difference as well. Consider:\n\nconsole.log(\"My name is ${ firstName }.\");\n// My name is ${ firstName }.\n\nconsole.log('My name is ${ firstName }.');\n// My name is ${ firstName }.\n\nconsole.log(`My name is ${ firstName }.`);\n// My name is Kyle.\n\nAssuming this program has already defined a variable firstName with the string value \"Kyle\", the `-delimited string then resolves the variable expression (indicated with ${ .. }) to its current value. This is called interpolation.\n\nThe back-tick `-delimited string can be used without including interpolated expressions, but that defeats the whole purpose of that alternate string literal syntax:\n\nconsole.log(\n    `Am I confusing you by omitting interpolation?`\n);\n// Am I confusing you by omitting interpolation?\n\nThe better approach is to use \" or ' (again, pick one and stick to it!) for strings unless you need interpolation; reserve ` only for strings that will include interpolated expressions.\n\nOther than strings, JS programs often contain other primitive literal values such as booleans and numbers:\n\nwhile (false) {\n    console.log(3.141592);\n}\n\nwhile represents a loop type, a way to repeat operations while its condition is true.\n\nIn this case, the loop will never run (and nothing will be printed), because we used the false boolean value as the loop conditional. true would have resulted in a loop that keeps going forever, so be careful!\n\nThe number 3.141592 is, as you may know, an approximation of mathematical PI to the first six digits. Rather than embed such a value, however, you would typically use the predefined Math.PI value for that purpose. Another variation on numbers is the bigint (big-integer) primitive type, which is used for storing arbitrarily large numbers.\n\nNumbers are most often used in programs for counting steps, such as loop iterations, and accessing information in numeric positions (i.e., an array index). We'll cover arrays/objects in a little bit, but as an example, if there was an array called names, we could access the element in its second position like this:\n\nconsole.log(`My name is ${ names[1] }.`);\n// My name is Kyle.\n\nWe used 1 for the element in the second position, instead of 2, because like in most programming languages, JS array indices are 0-based (0 is the first position).\n\nIn addition to strings, numbers, and booleans, two other primitive values in JS programs are null and undefined. While there are differences between them (some historic and some contemporary), for the most part both values serve the purpose of indicating emptiness (or absence) of a value.\n\nMany developers prefer to treat them both consistently in this fashion, which is to say that the values are assumed to be indistinguishable. If care is taken, this is often possible. However, it's safest and best to use only undefined as the single empty value, even though null seems attractive in that it's shorter to type!\n\nwhile (value != undefined) {\n    console.log(\"Still got something!\");\n}\n\nThe final primitive value to be aware of is a symbol, which is a special-purpose value that behaves as a hidden unguessable value. Symbols are almost exclusively used as special keys on objects:\n\nhitchhikersGuide[ Symbol(\"meaning of life\") ];\n// 42\n\nYou won't encounter direct usage of symbols very often in typical JS programs. They're mostly used in low-level code such as in libraries and frameworks."}, "id": 119, "children": [{"data": {"uuid": "a725524a-0ae8-465f-87b7-e69dd24c6e29", "user": 1, "title": "Arrays And Objects", "author": "Kyle Simpson", "created_on": "2023-06-07 18:47:14.448121+00:00", "updated_on": "2023-06-07 18:47:38.553798+00:00", "article_html": "<h3>Arrays And Objects</h3><p>Besides primitives, the other value type in JS is an object value.</p><p>As mentioned earlier, arrays are a special type of object that's comprised of an ordered and numerically indexed list of data:</p><pre><code>var names = [ \"Frank\", \"Kyle\", \"Peter\", \"Susan\" ];\n\nnames.length;\n// 4\n\nnames[0];\n// Frank\n\nnames[1];\n// Kyle</code></pre><p>JS arrays can hold any value type, either primitive or object (including other arrays). As we'll see toward the end of Chapter 3, even functions are values that can be held in arrays or objects.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Functions, like arrays, are a special kind (aka, sub-type) of object. We'll cover functions in more detail in a bit.</p></td></tr></tbody></table><p>Objects are more general: an unordered, keyed collection of any various values. In other words, you access the element by a string location name (aka \"key\" or \"property\") rather than by its numeric position (as with arrays). For example:</p><pre><code>var me = {\n    first: \"Kyle\",\n    last: \"Simpson\",\n    age: 39,\n    specialties: [ \"JS\", \"Table Tennis\" ]\n};\n\nconsole.log(`My name is ${ me.first }.`);</code></pre><p>Here, <code>me</code> represents an object, and <code>first</code> represents the name of a location of information in that object (value collection). Another syntax option that accesses information in an object by its property/key uses the square-brackets <code>[ ]</code>, such as <code>me[\"first\"]</code>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Arrays And Objects", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Besides primitives, the other value type in JS is an object value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As mentioned earlier, arrays are a special type of object that's comprised of an ordered and numerically indexed list of data:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var names = [ \"Frank\", \"Kyle\", \"Peter\", \"Susan\" ];\n\nnames.length;\n// 4\n\nnames[0];\n// Frank\n\nnames[1];\n// Kyle", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS arrays can hold any value type, either primitive or object (including other arrays). As we'll see toward the end of Chapter 3, even functions are values that can be held in arrays or objects.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Functions, like arrays, are a special kind (aka, sub-type) of object. We'll cover functions in more detail in a bit.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Objects are more general: an unordered, keyed collection of any various values. In other words, you access the element by a string location name (aka \"key\" or \"property\") rather than by its numeric position (as with arrays). For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var me = {\n    first: \"Kyle\",\n    last: \"Simpson\",\n    age: 39,\n    specialties: [ \"JS\", \"Table Tennis\" ]\n};\n\nconsole.log(`My name is ${ me.first }.`);", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, ", "type": "text"}, {"text": "me", "type": "text", "marks": [{"type": "code"}]}, {"text": " represents an object, and ", "type": "text"}, {"text": "first", "type": "text", "marks": [{"type": "code"}]}, {"text": " represents the name of a location of information in that object (value collection). Another syntax option that accesses information in an object by its property/key uses the square-brackets ", "type": "text"}, {"text": "[ ]", "type": "text", "marks": [{"type": "code"}]}, {"text": ", such as ", "type": "text"}, {"text": "me[\"first\"]", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Arrays And Objects\n\nBesides primitives, the other value type in JS is an object value.\n\nAs mentioned earlier, arrays are a special type of object that's comprised of an ordered and numerically indexed list of data:\n\nvar names = [ \"Frank\", \"Kyle\", \"Peter\", \"Susan\" ];\n\nnames.length;\n// 4\n\nnames[0];\n// Frank\n\nnames[1];\n// Kyle\n\nJS arrays can hold any value type, either primitive or object (including other arrays). As we'll see toward the end of Chapter 3, even functions are values that can be held in arrays or objects.\n\nNOTE:\n\nFunctions, like arrays, are a special kind (aka, sub-type) of object. We'll cover functions in more detail in a bit.\n\nObjects are more general: an unordered, keyed collection of any various values. In other words, you access the element by a string location name (aka \"key\" or \"property\") rather than by its numeric position (as with arrays). For example:\n\nvar me = {\n    first: \"Kyle\",\n    last: \"Simpson\",\n    age: 39,\n    specialties: [ \"JS\", \"Table Tennis\" ]\n};\n\nconsole.log(`My name is ${ me.first }.`);\n\nHere, me represents an object, and first represents the name of a location of information in that object (value collection). Another syntax option that accesses information in an object by its property/key uses the square-brackets [ ], such as me[\"first\"]."}, "id": 120}, {"data": {"uuid": "8168be0d-0681-4bfb-ad18-a81b70d95782", "user": 1, "title": "Value Type Determination", "author": "Kyle Simpson", "created_on": "2023-06-07 18:47:54.696806+00:00", "updated_on": "2023-06-07 18:48:16.662136+00:00", "article_html": "<h3>Value Type Determination</h3><p>For distinguishing values, the <code>typeof</code> operator tells you its built-in type, if primitive, or <code>\"object\"</code> otherwise:</p><pre><code>typeof 42;                  // \"number\"\ntypeof \"abc\";               // \"string\"\ntypeof true;                // \"boolean\"\ntypeof undefined;           // \"undefined\"\ntypeof null;                // \"object\" -- oops, bug!\ntypeof { \"a\": 1 };          // \"object\"\ntypeof [1,2,3];             // \"object\"\ntypeof function hello(){};  // \"function\"</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>WARNING:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p><code>typeof null</code> unfortunately returns <code>\"object\"</code> instead of the expected <code>\"null\"</code>. Also, <code>typeof</code> returns the specific <code>\"function\"</code> for functions, but not the expected <code>\"array\"</code> for arrays.</p></td></tr></tbody></table><p>Converting from one value type to another, such as from string to number, is referred to in JS as \"coercion.\" We'll cover this in more detail later in this chapter.</p><p>Primitive values and object values behave differently when they're assigned or passed around. We'll cover these details in Appendix A, \"Values vs References.\"</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Value Type Determination", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For distinguishing values, the ", "type": "text"}, {"text": "typeof", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator tells you its built-in type, if primitive, or ", "type": "text"}, {"text": "\"object\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " otherwise:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "typeof 42;                  // \"number\"\ntypeof \"abc\";               // \"string\"\ntypeof true;                // \"boolean\"\ntypeof undefined;           // \"undefined\"\ntypeof null;                // \"object\" -- oops, bug!\ntypeof { \"a\": 1 };          // \"object\"\ntypeof [1,2,3];             // \"object\"\ntypeof function hello(){};  // \"function\"", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "WARNING:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "typeof null", "type": "text", "marks": [{"type": "code"}]}, {"text": " unfortunately returns ", "type": "text"}, {"text": "\"object\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of the expected ", "type": "text"}, {"text": "\"null\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Also, ", "type": "text"}, {"text": "typeof", "type": "text", "marks": [{"type": "code"}]}, {"text": " returns the specific ", "type": "text"}, {"text": "\"function\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " for functions, but not the expected ", "type": "text"}, {"text": "\"array\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " for arrays.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Converting from one value type to another, such as from string to number, is referred to in JS as \"coercion.\" We'll cover this in more detail later in this chapter.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Primitive values and object values behave differently when they're assigned or passed around. We'll cover these details in Appendix A, \"Values vs References.\"", "type": "text"}]}]}, "article_text": "Value Type Determination\n\nFor distinguishing values, the typeof operator tells you its built-in type, if primitive, or \"object\" otherwise:\n\ntypeof 42;                  // \"number\"\ntypeof \"abc\";               // \"string\"\ntypeof true;                // \"boolean\"\ntypeof undefined;           // \"undefined\"\ntypeof null;                // \"object\" -- oops, bug!\ntypeof { \"a\": 1 };          // \"object\"\ntypeof [1,2,3];             // \"object\"\ntypeof function hello(){};  // \"function\"\n\nWARNING:\n\ntypeof null unfortunately returns \"object\" instead of the expected \"null\". Also, typeof returns the specific \"function\" for functions, but not the expected \"array\" for arrays.\n\nConverting from one value type to another, such as from string to number, is referred to in JS as \"coercion.\" We'll cover this in more detail later in this chapter.\n\nPrimitive values and object values behave differently when they're assigned or passed around. We'll cover these details in Appendix A, \"Values vs References.\""}, "id": 121}]}, {"data": {"uuid": "07b4ffac-6511-4ec2-b3db-a2b3012ce1e5", "user": 1, "title": "Declaring and Using Variables", "author": "Kyle Simpson", "created_on": "2023-06-07 18:48:34.328861+00:00", "updated_on": "2023-06-07 18:49:05.715357+00:00", "article_html": "<h2>Declaring and Using Variables</h2><p>To be explicit about something that may not have been obvious in the previous section: in JS programs, values can either appear as literal values (as many of the preceding examples illustrate), or they can be held in variables; think of variables as just containers for values.</p><p>Variables have to be declared (created) to be used. There are various syntax forms that declare variables (aka, \"identifiers\"), and each form has different implied behaviors.</p><p>For example, consider the <code>var</code> statement:</p><pre><code>var myName = \"Kyle\";\nvar age;</code></pre><p>The <code>var</code> keyword declares a variable to be used in that part of the program, and optionally allows an initial assignment of a value.</p><p>Another similar keyword is <code>let</code>:</p><pre><code>let myName = \"Kyle\";\nlet age;</code></pre><p>The <code>let</code> keyword has some differences to <code>var</code>, with the most obvious being that <code>let</code> allows a more limited access to the variable than <code>var</code>. This is called \"block scoping\" as opposed to regular or function scoping.</p><p>Consider:</p><pre><code>var adult = true;\n\nif (adult) {\n    var myName = \"Kyle\";\n    let age = 39;\n    console.log(\"Shhh, this is a secret!\");\n}\n\nconsole.log(myName);\n// Kyle\n\nconsole.log(age);\n// Error!</code></pre><p>The attempt to access <code>age</code> outside of the <code>if</code> statement results in an error, because <code>age</code> was block-scoped to the <code>if</code>, whereas <code>myName</code> was not.</p><p>Block-scoping is very useful for limiting how widespread variable declarations are in our programs, which helps prevent accidental overlap of their names.</p><p>But <code>var</code> is still useful in that it communicates \"this variable will be seen by a wider scope (of the whole function)\". Both declaration forms can be appropriate in any given part of a program, depending on the circumstances.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>It's very common to suggest that <code>var</code> should be avoided in favor of <code>let</code> (or <code>const</code>!), generally because of perceived confusion over how the scoping behavior of <code>var</code> has worked since the beginning of JS. I believe this to be overly restrictive advice and ultimately unhelpful. It's assuming you are unable to learn and use a feature properly in combination with other features. I believe you <em>can</em> and <em>should</em> learn any features available, and use them where appropriate!</p></td></tr></tbody></table><p>A third declaration form is <code>const</code>. It's like <code>let</code> but has an additional limitation that it must be given a value at the moment it's declared, and cannot be re-assigned a different value later.</p><p>Consider:</p><pre><code>const myBirthday = true;\nlet age = 39;\n\nif (myBirthday) {\n    age = age + 1;    // OK!\n    myBirthday = false;  // Error!\n}</code></pre><p>The <code>myBirthday</code> constant is not allowed to be re-assigned.</p><p><code>const</code> declared variables are not \"unchangeable\", they just cannot be re-assigned. It's ill-advised to use <code>const</code> with object values, because those values can still be changed even though the variable can't be re-assigned. This leads to potential confusion down the line, so I think it's wise to avoid situations like:</p><pre><code>const actors = [\n    \"Morgan Freeman\", \"Jennifer Aniston\"\n];\n\nactors[2] = \"Tom Cruise\";   // OK :(\nactors = [];                // Error!</code></pre><p>The best semantic use of a <code>const</code> is when you have a simple primitive value that you want to give a useful name to, such as using <code>myBirthday</code> instead of <code>true</code>. This makes programs easier to read.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>If you stick to using <code>const</code> only with primitive values, you avoid any confusion of re-assignment (not allowed) vs. mutation (allowed)! That's the safest and best way to use <code>const</code>.</p></td></tr></tbody></table><p>Besides <code>var</code> / <code>let</code> / <code>const</code>, there are other syntactic forms that declare identifiers (variables) in various scopes. For example:</p><pre><code>function hello(myName) {\n    console.log(`Hello, ${ myName }.`);\n}\n\nhello(\"Kyle\");\n// Hello, Kyle.</code></pre><p>The identifier <code>hello</code> is created in the outer scope, and it's also automatically associated so that it references the function. But the named parameter <code>myName</code> is created only inside the function, and thus is only accessible inside that function's scope. <code>hello</code> and <code>myName</code> generally behave as <code>var</code>-declared.</p><p>Another syntax that declares a variable is a <code>catch</code> clause:</p><pre><code>try {\n    someError();\n}\ncatch (err) {\n    console.log(err);\n}</code></pre><p>The <code>err</code> is a block-scoped variable that exists only inside the <code>catch</code> clause, as if it had been declared with <code>let</code>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Declaring and Using Variables", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To be explicit about something that may not have been obvious in the previous section: in JS programs, values can either appear as literal values (as many of the preceding examples illustrate), or they can be held in variables; think of variables as just containers for values.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Variables have to be declared (created) to be used. There are various syntax forms that declare variables (aka, \"identifiers\"), and each form has different implied behaviors.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For example, consider the ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var myName = \"Kyle\";\nvar age;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword declares a variable to be used in that part of the program, and optionally allows an initial assignment of a value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another similar keyword is ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "let myName = \"Kyle\";\nlet age;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword has some differences to ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ", with the most obvious being that ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " allows a more limited access to the variable than ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": ". This is called \"block scoping\" as opposed to regular or function scoping.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var adult = true;\n\nif (adult) {\n    var myName = \"Kyle\";\n    let age = 39;\n    console.log(\"Shhh, this is a secret!\");\n}\n\nconsole.log(myName);\n// Kyle\n\nconsole.log(age);\n// Error!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The attempt to access ", "type": "text"}, {"text": "age", "type": "text", "marks": [{"type": "code"}]}, {"text": " outside of the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement results in an error, because ", "type": "text"}, {"text": "age", "type": "text", "marks": [{"type": "code"}]}, {"text": " was block-scoped to the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": ", whereas ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " was not.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Block-scoping is very useful for limiting how widespread variable declarations are in our programs, which helps prevent accidental overlap of their names.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " is still useful in that it communicates \"this variable will be seen by a wider scope (of the whole function)\". Both declaration forms can be appropriate in any given part of a program, depending on the circumstances.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "It's very common to suggest that ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " should be avoided in favor of ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " (or ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": "!), generally because of perceived confusion over how the scoping behavior of ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " has worked since the beginning of JS. I believe this to be overly restrictive advice and ultimately unhelpful. It's assuming you are unable to learn and use a feature properly in combination with other features. I believe you ", "type": "text"}, {"text": "can", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "should", "type": "text", "marks": [{"type": "italic"}]}, {"text": " learn any features available, and use them where appropriate!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "A third declaration form is ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ". It's like ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " but has an additional limitation that it must be given a value at the moment it's declared, and cannot be re-assigned a different value later.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const myBirthday = true;\nlet age = 39;\n\nif (myBirthday) {\n    age = age + 1;    // OK!\n    myBirthday = false;  // Error!\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "myBirthday", "type": "text", "marks": [{"type": "code"}]}, {"text": " constant is not allowed to be re-assigned.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declared variables are not \"unchangeable\", they just cannot be re-assigned. It's ill-advised to use ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " with object values, because those values can still be changed even though the variable can't be re-assigned. This leads to potential confusion down the line, so I think it's wise to avoid situations like:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const actors = [\n    \"Morgan Freeman\", \"Jennifer Aniston\"\n];\n\nactors[2] = \"Tom Cruise\";   // OK :(\nactors = [];                // Error!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The best semantic use of a ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " is when you have a simple primitive value that you want to give a useful name to, such as using ", "type": "text"}, {"text": "myBirthday", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead of ", "type": "text"}, {"text": "true", "type": "text", "marks": [{"type": "code"}]}, {"text": ". This makes programs easier to read.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "If you stick to using ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " only with primitive values, you avoid any confusion of re-assignment (not allowed) vs. mutation (allowed)! That's the safest and best way to use ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Besides ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": ", there are other syntactic forms that declare identifiers (variables) in various scopes. For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function hello(myName) {\n    console.log(`Hello, ${ myName }.`);\n}\n\nhello(\"Kyle\");\n// Hello, Kyle.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The identifier ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " is created in the outer scope, and it's also automatically associated so that it references the function. But the named parameter ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is created only inside the function, and thus is only accessible inside that function's scope. ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " generally behave as ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "-declared.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another syntax that declares a variable is a ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "try {\n    someError();\n}\ncatch (err) {\n    console.log(err);\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "err", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a block-scoped variable that exists only inside the ", "type": "text"}, {"text": "catch", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause, as if it had been declared with ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Declaring and Using Variables\n\nTo be explicit about something that may not have been obvious in the previous section: in JS programs, values can either appear as literal values (as many of the preceding examples illustrate), or they can be held in variables; think of variables as just containers for values.\n\nVariables have to be declared (created) to be used. There are various syntax forms that declare variables (aka, \"identifiers\"), and each form has different implied behaviors.\n\nFor example, consider the var statement:\n\nvar myName = \"Kyle\";\nvar age;\n\nThe var keyword declares a variable to be used in that part of the program, and optionally allows an initial assignment of a value.\n\nAnother similar keyword is let:\n\nlet myName = \"Kyle\";\nlet age;\n\nThe let keyword has some differences to var, with the most obvious being that let allows a more limited access to the variable than var. This is called \"block scoping\" as opposed to regular or function scoping.\n\nConsider:\n\nvar adult = true;\n\nif (adult) {\n    var myName = \"Kyle\";\n    let age = 39;\n    console.log(\"Shhh, this is a secret!\");\n}\n\nconsole.log(myName);\n// Kyle\n\nconsole.log(age);\n// Error!\n\nThe attempt to access age outside of the if statement results in an error, because age was block-scoped to the if, whereas myName was not.\n\nBlock-scoping is very useful for limiting how widespread variable declarations are in our programs, which helps prevent accidental overlap of their names.\n\nBut var is still useful in that it communicates \"this variable will be seen by a wider scope (of the whole function)\". Both declaration forms can be appropriate in any given part of a program, depending on the circumstances.\n\nNOTE:\n\nIt's very common to suggest that var should be avoided in favor of let (or const!), generally because of perceived confusion over how the scoping behavior of var has worked since the beginning of JS. I believe this to be overly restrictive advice and ultimately unhelpful. It's assuming you are unable to learn and use a feature properly in combination with other features. I believe you can and should learn any features available, and use them where appropriate!\n\nA third declaration form is const. It's like let but has an additional limitation that it must be given a value at the moment it's declared, and cannot be re-assigned a different value later.\n\nConsider:\n\nconst myBirthday = true;\nlet age = 39;\n\nif (myBirthday) {\n    age = age + 1;    // OK!\n    myBirthday = false;  // Error!\n}\n\nThe myBirthday constant is not allowed to be re-assigned.\n\nconst declared variables are not \"unchangeable\", they just cannot be re-assigned. It's ill-advised to use const with object values, because those values can still be changed even though the variable can't be re-assigned. This leads to potential confusion down the line, so I think it's wise to avoid situations like:\n\nconst actors = [\n    \"Morgan Freeman\", \"Jennifer Aniston\"\n];\n\nactors[2] = \"Tom Cruise\";   // OK :(\nactors = [];                // Error!\n\nThe best semantic use of a const is when you have a simple primitive value that you want to give a useful name to, such as using myBirthday instead of true. This makes programs easier to read.\n\nTIP:\n\nIf you stick to using const only with primitive values, you avoid any confusion of re-assignment (not allowed) vs. mutation (allowed)! That's the safest and best way to use const.\n\nBesides var / let / const, there are other syntactic forms that declare identifiers (variables) in various scopes. For example:\n\nfunction hello(myName) {\n    console.log(`Hello, ${ myName }.`);\n}\n\nhello(\"Kyle\");\n// Hello, Kyle.\n\nThe identifier hello is created in the outer scope, and it's also automatically associated so that it references the function. But the named parameter myName is created only inside the function, and thus is only accessible inside that function's scope. hello and myName generally behave as var-declared.\n\nAnother syntax that declares a variable is a catch clause:\n\ntry {\n    someError();\n}\ncatch (err) {\n    console.log(err);\n}\n\nThe err is a block-scoped variable that exists only inside the catch clause, as if it had been declared with let."}, "id": 122}, {"data": {"uuid": "21642e60-2e5e-4211-8c3d-52ac093aa98d", "user": 1, "title": "Functions", "author": "Kyle Simpson", "created_on": "2023-06-07 18:49:32.847964+00:00", "updated_on": "2023-06-07 18:50:04.884980+00:00", "article_html": "<h2>Functions</h2><p>The word \"function\" has a variety of meanings in programming. For example, in the world of Functional Programming, \"function\" has a precise mathematical definition and implies a strict set of rules to abide by.</p><p>In JS, we should consider \"function\" to take the broader meaning of another related term: \"procedure.\" A procedure is a collection of statements that can be invoked one or more times, may be provided some inputs, and may give back one or more outputs.</p><p>From the early days of JS, function definition looked like:</p><pre><code>function awesomeFunction(coolThings) {\n    // ..\n    return amazingStuff;\n}</code></pre><p>This is called a function declaration because it appears as a statement by itself, not as an expression in another statement. The association between the identifier <code>awesomeFunction</code> and the function value happens during the compile phase of the code, before that code is executed.</p><p>In contrast to a function declaration statement, a function expression can be defined and assigned like this:</p><pre><code>// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function(coolThings) {\n    // ..\n    return amazingStuff;\n};</code></pre><p>This function is an expression that is assigned to the variable <code>awesomeFunction</code>. Different from the function declaration form, a function expression is not associated with its identifier until that statement during runtime.</p><p>It's extremely important to note that in JS, functions are values that can be assigned (as shown in this snippet) and passed around. In fact, JS functions are a special type of the object value type. Not all languages treat functions as values, but it's essential for a language to support the functional programming pattern, as JS does.</p><p>JS functions can receive parameter input:</p><pre><code>function greeting(myName) {\n    console.log(`Hello, ${ myName }!`);\n}\n\ngreeting(\"Kyle\");   // Hello, Kyle!</code></pre><p>In this snippet, <code>myName</code> is called a parameter, which acts as a local variable inside the function. Functions can be defined to receive any number of parameters, from none upward, as you see fit. Each parameter is assigned the argument value that you pass in that position (<code>\"Kyle\"</code>, here) of the call.</p><p>Functions also can return values using the <code>return</code> keyword:</p><pre><code>function greeting(myName) {\n    return `Hello, ${ myName }!`;\n}\n\nvar msg = greeting(\"Kyle\");\n\nconsole.log(msg);   // Hello, Kyle!</code></pre><p>You can only <code>return</code> a single value, but if you have more values to return, you can wrap them up into a single object/array.</p><p>Since functions are values, they can be assigned as properties on objects:</p><pre><code>var whatToSay = {\n    greeting() {\n        console.log(\"Hello!\");\n    },\n    question() {\n        console.log(\"What's your name?\");\n    },\n    answer() {\n        console.log(\"My name is Kyle.\");\n    }\n};\n\nwhatToSay.greeting();\n// Hello!</code></pre><p>In this snippet, references to three functions (<code>greeting()</code>, <code>question()</code>, and <code>answer()</code>) are included in the object held by <code>whatToSay</code>. Each function can be called by accessing the property to retrieve the function reference value. Compare this straightforward style of defining functions on an object to the more sophisticated <code>class</code> syntax discussed later in this chapter.</p><p>There are many varied forms that <code>function</code>s take in JS. We dig into these variations in Appendix A, \"So Many Function Forms.\"</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Functions", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The word \"function\" has a variety of meanings in programming. For example, in the world of Functional Programming, \"function\" has a precise mathematical definition and implies a strict set of rules to abide by.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In JS, we should consider \"function\" to take the broader meaning of another related term: \"procedure.\" A procedure is a collection of statements that can be invoked one or more times, may be provided some inputs, and may give back one or more outputs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "From the early days of JS, function definition looked like:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function awesomeFunction(coolThings) {\n    // ..\n    return amazingStuff;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is called a function declaration because it appears as a statement by itself, not as an expression in another statement. The association between the identifier ", "type": "text"}, {"text": "awesomeFunction", "type": "text", "marks": [{"type": "code"}]}, {"text": " and the function value happens during the compile phase of the code, before that code is executed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In contrast to a function declaration statement, a function expression can be defined and assigned like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function(coolThings) {\n    // ..\n    return amazingStuff;\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This function is an expression that is assigned to the variable ", "type": "text"}, {"text": "awesomeFunction", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Different from the function declaration form, a function expression is not associated with its identifier until that statement during runtime.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's extremely important to note that in JS, functions are values that can be assigned (as shown in this snippet) and passed around. In fact, JS functions are a special type of the object value type. Not all languages treat functions as values, but it's essential for a language to support the functional programming pattern, as JS does.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS functions can receive parameter input:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function greeting(myName) {\n    console.log(`Hello, ${ myName }!`);\n}\n\ngreeting(\"Kyle\");   // Hello, Kyle!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this snippet, ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is called a parameter, which acts as a local variable inside the function. Functions can be defined to receive any number of parameters, from none upward, as you see fit. Each parameter is assigned the argument value that you pass in that position (", "type": "text"}, {"text": "\"Kyle\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", here) of the call.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Functions also can return values using the ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function greeting(myName) {\n    return `Hello, ${ myName }!`;\n}\n\nvar msg = greeting(\"Kyle\");\n\nconsole.log(msg);   // Hello, Kyle!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You can only ", "type": "text"}, {"text": "return", "type": "text", "marks": [{"type": "code"}]}, {"text": " a single value, but if you have more values to return, you can wrap them up into a single object/array.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since functions are values, they can be assigned as properties on objects:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var whatToSay = {\n    greeting() {\n        console.log(\"Hello!\");\n    },\n    question() {\n        console.log(\"What's your name?\");\n    },\n    answer() {\n        console.log(\"My name is Kyle.\");\n    }\n};\n\nwhatToSay.greeting();\n// Hello!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this snippet, references to three functions (", "type": "text"}, {"text": "greeting()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "question()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "answer()", "type": "text", "marks": [{"type": "code"}]}, {"text": ") are included in the object held by ", "type": "text"}, {"text": "whatToSay", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Each function can be called by accessing the property to retrieve the function reference value. Compare this straightforward style of defining functions on an object to the more sophisticated ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " syntax discussed later in this chapter.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are many varied forms that ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": "s take in JS. We dig into these variations in Appendix A, \"So Many Function Forms.\"", "type": "text"}]}]}, "article_text": "Functions\n\nThe word \"function\" has a variety of meanings in programming. For example, in the world of Functional Programming, \"function\" has a precise mathematical definition and implies a strict set of rules to abide by.\n\nIn JS, we should consider \"function\" to take the broader meaning of another related term: \"procedure.\" A procedure is a collection of statements that can be invoked one or more times, may be provided some inputs, and may give back one or more outputs.\n\nFrom the early days of JS, function definition looked like:\n\nfunction awesomeFunction(coolThings) {\n    // ..\n    return amazingStuff;\n}\n\nThis is called a function declaration because it appears as a statement by itself, not as an expression in another statement. The association between the identifier awesomeFunction and the function value happens during the compile phase of the code, before that code is executed.\n\nIn contrast to a function declaration statement, a function expression can be defined and assigned like this:\n\n// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function(coolThings) {\n    // ..\n    return amazingStuff;\n};\n\nThis function is an expression that is assigned to the variable awesomeFunction. Different from the function declaration form, a function expression is not associated with its identifier until that statement during runtime.\n\nIt's extremely important to note that in JS, functions are values that can be assigned (as shown in this snippet) and passed around. In fact, JS functions are a special type of the object value type. Not all languages treat functions as values, but it's essential for a language to support the functional programming pattern, as JS does.\n\nJS functions can receive parameter input:\n\nfunction greeting(myName) {\n    console.log(`Hello, ${ myName }!`);\n}\n\ngreeting(\"Kyle\");   // Hello, Kyle!\n\nIn this snippet, myName is called a parameter, which acts as a local variable inside the function. Functions can be defined to receive any number of parameters, from none upward, as you see fit. Each parameter is assigned the argument value that you pass in that position (\"Kyle\", here) of the call.\n\nFunctions also can return values using the return keyword:\n\nfunction greeting(myName) {\n    return `Hello, ${ myName }!`;\n}\n\nvar msg = greeting(\"Kyle\");\n\nconsole.log(msg);   // Hello, Kyle!\n\nYou can only return a single value, but if you have more values to return, you can wrap them up into a single object/array.\n\nSince functions are values, they can be assigned as properties on objects:\n\nvar whatToSay = {\n    greeting() {\n        console.log(\"Hello!\");\n    },\n    question() {\n        console.log(\"What's your name?\");\n    },\n    answer() {\n        console.log(\"My name is Kyle.\");\n    }\n};\n\nwhatToSay.greeting();\n// Hello!\n\nIn this snippet, references to three functions (greeting(), question(), and answer()) are included in the object held by whatToSay. Each function can be called by accessing the property to retrieve the function reference value. Compare this straightforward style of defining functions on an object to the more sophisticated class syntax discussed later in this chapter.\n\nThere are many varied forms that functions take in JS. We dig into these variations in Appendix A, \"So Many Function Forms.\""}, "id": 123}, {"data": {"uuid": "11b72683-9d2d-4853-830f-3c2d9726438a", "user": 1, "title": "Comparisons", "author": "Kyle Simpson", "created_on": "2023-06-07 18:51:03.082660+00:00", "updated_on": "2023-06-07 18:51:19.810661+00:00", "article_html": "<h2>Comparisons</h2><p>Making decisions in programs requires comparing values to determine their identity and relationship to each other. JS has several mechanisms to enable value comparison, so let's take a closer look at them.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Comparisons", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Making decisions in programs requires comparing values to determine their identity and relationship to each other. JS has several mechanisms to enable value comparison, so let's take a closer look at them.", "type": "text"}]}]}, "article_text": "Comparisons\n\nMaking decisions in programs requires comparing values to determine their identity and relationship to each other. JS has several mechanisms to enable value comparison, so let's take a closer look at them."}, "id": 124, "children": [{"data": {"uuid": "9e4ef545-ef45-4f61-b541-544d4e0e070c", "user": 1, "title": "Equal...ish", "author": "Kyle Simpson", "created_on": "2023-06-07 18:51:36.521016+00:00", "updated_on": "2023-06-07 18:52:04.822605+00:00", "article_html": "<h3>Equal...ish</h3><p>The most common comparison in JS programs asks the question, \"Is this X value <em>the same as</em> that Y value?\" What exactly does \"the same as\" really mean to JS, though?</p><p>For ergonomic and historical reasons, the meaning is more complicated than the obvious <em>exact identity</em> sort of matching. Sometimes an equality comparison intends <em>exact</em> matching, but other times the desired comparison is a bit broader, allowing <em>closely similar</em> or <em>interchangeable</em> matching. In other words, we must be aware of the nuanced differences between an <strong>equality</strong> comparison and an <strong>equivalence</strong> comparison.</p><p>If you've spent any time working with and reading about JS, you've certainly seen the so-called \"triple-equals\" <code>===</code> operator, also described as the \"strict equality\" operator. That seems rather straightforward, right? Surely, \"strict\" means strict, as in narrow and <em>exact</em>.</p><p>Not <em>exact</em>ly.</p><p>Yes, most values participating in an <code>===</code> equality comparison will fit with that <em>exact same</em> intuition. Consider some examples:</p><pre><code>3 === 3.0;              // true\n\"yes\" === \"yes\";        // true\nnull === null;          // true\nfalse === false;        // true\n\n42 === \"42\";            // false\n\"hello\" === \"Hello\";    // false\ntrue === 1;             // false\n0 === null;             // false\n\"\" === null;            // false\nnull === undefined;     // false</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Another way <code>===</code>'s equality comparison is often described is, \"checking both the value and the type\". In several of the examples we've looked at so far, like <code>42 === \"42\"</code>, the <em>type</em> of both values (number, string, etc.) does seem to be the distinguishing factor. There's more to it than that, though. <strong>All</strong> value comparisons in JS consider the type of the values being compared, not <em>just</em> the <code>===</code> operator. Specifically, <code>===</code> disallows any sort of type conversion (aka, \"coercion\") in its comparison, where other JS comparisons <em>do</em> allow coercion.</p></td></tr></tbody></table><p>But the <code>===</code> operator does have some nuance to it, a fact many JS developers gloss over, to their detriment. The <code>===</code> operator is designed to <em>lie</em> in two cases of special values: <code>NaN</code> and <code>-0</code>. Consider:</p><pre><code>NaN === NaN;            // false\n0 === -0;               // true</code></pre><p>In the case of <code>NaN</code>, the <code>===</code> operator <em>lies</em> and says that an occurrence of <code>NaN</code> is not equal to another <code>NaN</code>. In the case of <code>-0</code> (yes, this is a real, distinct value you can use intentionally in your programs!), the <code>===</code> operator <em>lies</em> and says it's equal to the regular <code>0</code> value.</p><p>Since the <em>lying</em> about such comparisons can be bothersome, it's best to avoid using <code>===</code> for them. For <code>NaN</code> comparisons, use the <code>Number.isNaN(..)</code> utility, which does not <em>lie</em>. For <code>-0</code> comparison, use the <code>Object.is(..)</code> utility, which also does not <em>lie</em>. <code>Object.is(..)</code> can also be used for non-<em>lying</em> <code>NaN</code> checks, if you prefer. Humorously, you could think of <code>Object.is(..)</code> as the \"quadruple-equals\" <code>====</code>, the really-really-strict comparison!</p><p>There are deeper historical and technical reasons for these <em>lies</em>, but that doesn't change the fact that <code>===</code> is not actually <em>strictly exactly equal</em> comparison, in the <em>strictest</em> sense.</p><p>The story gets even more complicated when we consider comparisons of object values (non-primitives). Consider:</p><pre><code>[ 1, 2, 3 ] === [ 1, 2, 3 ];    // false\n{ a: 42 } === { a: 42 }         // false\n(x =&gt; x * 2) === (x =&gt; x * 2)   // false</code></pre><p>What's going on here?</p><p>It may seem reasonable to assume that an equality check considers the <em>nature</em> or <em>contents</em> of the value; after all, <code>42 === 42</code> considers the actual <code>42</code> value and compares it. But when it comes to objects, a content-aware comparison is generally referred to as \"structural equality.\"</p><p>JS does not define <code>===</code> as <em>structural equality</em> for object values. Instead, <code>===</code> uses <em>identity equality</em> for object values.</p><p>In JS, all object values are held by reference (see \"Values vs References\" in Appendix A), are assigned and passed by reference-copy, <strong>and</strong> to our current discussion, are compared by reference (identity) equality. Consider:</p><pre><code>var x = [ 1, 2, 3 ];\n\n// assignment is by reference-copy, so\n// y references the *same* array as x,\n// not another copy of it.\nvar y = x;\n\ny === x;              // true\ny === [ 1, 2, 3 ];    // false\nx === [ 1, 2, 3 ];    // false</code></pre><p>In this snippet, <code>y === x</code> is true because both variables hold a reference to the same initial array. But the <code>=== [1,2,3]</code> comparisons both fail because <code>y</code> and <code>x</code>, respectively, are being compared to new <em>different</em> arrays <code>[1,2,3]</code>. The array structure and contents don't matter in this comparison, only the <strong>reference identity</strong>.</p><p>JS does not provide a mechanism for structural equality comparison of object values, only reference identity comparison. To do structural equality comparison, you'll need to implement the checks yourself.</p><p>But beware, it's more complicated than you'll assume. For example, how might you determine if two function references are \"structurally equivalent\"? Even stringifying to compare their source code text wouldn't take into account things like closure. JS doesn't provide structural equality comparison because it's almost intractable to handle all the corner cases!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Equal...ish", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The most common comparison in JS programs asks the question, \"Is this X value ", "type": "text"}, {"text": "the same as", "type": "text", "marks": [{"type": "italic"}]}, {"text": " that Y value?\" What exactly does \"the same as\" really mean to JS, though?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For ergonomic and historical reasons, the meaning is more complicated than the obvious ", "type": "text"}, {"text": "exact identity", "type": "text", "marks": [{"type": "italic"}]}, {"text": " sort of matching. Sometimes an equality comparison intends ", "type": "text"}, {"text": "exact", "type": "text", "marks": [{"type": "italic"}]}, {"text": " matching, but other times the desired comparison is a bit broader, allowing ", "type": "text"}, {"text": "closely similar", "type": "text", "marks": [{"type": "italic"}]}, {"text": " or ", "type": "text"}, {"text": "interchangeable", "type": "text", "marks": [{"type": "italic"}]}, {"text": " matching. In other words, we must be aware of the nuanced differences between an ", "type": "text"}, {"text": "equality", "type": "text", "marks": [{"type": "bold"}]}, {"text": " comparison and an ", "type": "text"}, {"text": "equivalence", "type": "text", "marks": [{"type": "bold"}]}, {"text": " comparison.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you've spent any time working with and reading about JS, you've certainly seen the so-called \"triple-equals\" ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator, also described as the \"strict equality\" operator. That seems rather straightforward, right? Surely, \"strict\" means strict, as in narrow and ", "type": "text"}, {"text": "exact", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Not ", "type": "text"}, {"text": "exact", "type": "text", "marks": [{"type": "italic"}]}, {"text": "ly.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Yes, most values participating in an ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " equality comparison will fit with that ", "type": "text"}, {"text": "exact same", "type": "text", "marks": [{"type": "italic"}]}, {"text": " intuition. Consider some examples:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "3 === 3.0;              // true\n\"yes\" === \"yes\";        // true\nnull === null;          // true\nfalse === false;        // true\n\n42 === \"42\";            // false\n\"hello\" === \"Hello\";    // false\ntrue === 1;             // false\n0 === null;             // false\n\"\" === null;            // false\nnull === undefined;     // false", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Another way ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": "'s equality comparison is often described is, \"checking both the value and the type\". In several of the examples we've looked at so far, like ", "type": "text"}, {"text": "42 === \"42\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the ", "type": "text"}, {"text": "type", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of both values (number, string, etc.) does seem to be the distinguishing factor. There's more to it than that, though. ", "type": "text"}, {"text": "All", "type": "text", "marks": [{"type": "bold"}]}, {"text": " value comparisons in JS consider the type of the values being compared, not ", "type": "text"}, {"text": "just", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator. Specifically, ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " disallows any sort of type conversion (aka, \"coercion\") in its comparison, where other JS comparisons ", "type": "text"}, {"text": "do", "type": "text", "marks": [{"type": "italic"}]}, {"text": " allow coercion.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "But the ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator does have some nuance to it, a fact many JS developers gloss over, to their detriment. The ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator is designed to ", "type": "text"}, {"text": "lie", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in two cases of special values: ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "-0", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "NaN === NaN;            // false\n0 === -0;               // true", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the case of ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator ", "type": "text"}, {"text": "lies", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and says that an occurrence of ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not equal to another ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}, {"text": ". In the case of ", "type": "text"}, {"text": "-0", "type": "text", "marks": [{"type": "code"}]}, {"text": " (yes, this is a real, distinct value you can use intentionally in your programs!), the ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator ", "type": "text"}, {"text": "lies", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and says it's equal to the regular ", "type": "text"}, {"text": "0", "type": "text", "marks": [{"type": "code"}]}, {"text": " value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since the ", "type": "text"}, {"text": "lying", "type": "text", "marks": [{"type": "italic"}]}, {"text": " about such comparisons can be bothersome, it's best to avoid using ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " for them. For ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}, {"text": " comparisons, use the ", "type": "text"}, {"text": "Number.isNaN(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility, which does not ", "type": "text"}, {"text": "lie", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". For ", "type": "text"}, {"text": "-0", "type": "text", "marks": [{"type": "code"}]}, {"text": " comparison, use the ", "type": "text"}, {"text": "Object.is(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility, which also does not ", "type": "text"}, {"text": "lie", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". ", "type": "text"}, {"text": "Object.is(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " can also be used for non-", "type": "text"}, {"text": "lying", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "NaN", "type": "text", "marks": [{"type": "code"}]}, {"text": " checks, if you prefer. Humorously, you could think of ", "type": "text"}, {"text": "Object.is(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " as the \"quadruple-equals\" ", "type": "text"}, {"text": "====", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the really-really-strict comparison!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are deeper historical and technical reasons for these ", "type": "text"}, {"text": "lies", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", but that doesn't change the fact that ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not actually ", "type": "text"}, {"text": "strictly exactly equal", "type": "text", "marks": [{"type": "italic"}]}, {"text": " comparison, in the ", "type": "text"}, {"text": "strictest", "type": "text", "marks": [{"type": "italic"}]}, {"text": " sense.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The story gets even more complicated when we consider comparisons of object values (non-primitives). Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "[ 1, 2, 3 ] === [ 1, 2, 3 ];    // false\n{ a: 42 } === { a: 42 }         // false\n(x => x * 2) === (x => x * 2)   // false", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "What's going on here?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It may seem reasonable to assume that an equality check considers the ", "type": "text"}, {"text": "nature", "type": "text", "marks": [{"type": "italic"}]}, {"text": " or ", "type": "text"}, {"text": "contents", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of the value; after all, ", "type": "text"}, {"text": "42 === 42", "type": "text", "marks": [{"type": "code"}]}, {"text": " considers the actual ", "type": "text"}, {"text": "42", "type": "text", "marks": [{"type": "code"}]}, {"text": " value and compares it. But when it comes to objects, a content-aware comparison is generally referred to as \"structural equality.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS does not define ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " as ", "type": "text"}, {"text": "structural equality", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for object values. Instead, ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " uses ", "type": "text"}, {"text": "identity equality", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for object values.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In JS, all object values are held by reference (see \"Values vs References\" in Appendix A), are assigned and passed by reference-copy, ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "bold"}]}, {"text": " to our current discussion, are compared by reference (identity) equality. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var x = [ 1, 2, 3 ];\n\n// assignment is by reference-copy, so\n// y references the *same* array as x,\n// not another copy of it.\nvar y = x;\n\ny === x;              // true\ny === [ 1, 2, 3 ];    // false\nx === [ 1, 2, 3 ];    // false", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this snippet, ", "type": "text"}, {"text": "y === x", "type": "text", "marks": [{"type": "code"}]}, {"text": " is true because both variables hold a reference to the same initial array. But the ", "type": "text"}, {"text": "=== [1,2,3]", "type": "text", "marks": [{"type": "code"}]}, {"text": " comparisons both fail because ", "type": "text"}, {"text": "y", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": ", respectively, are being compared to new ", "type": "text"}, {"text": "different", "type": "text", "marks": [{"type": "italic"}]}, {"text": " arrays ", "type": "text"}, {"text": "[1,2,3]", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The array structure and contents don't matter in this comparison, only the ", "type": "text"}, {"text": "reference identity", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS does not provide a mechanism for structural equality comparison of object values, only reference identity comparison. To do structural equality comparison, you'll need to implement the checks yourself.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But beware, it's more complicated than you'll assume. For example, how might you determine if two function references are \"structurally equivalent\"? Even stringifying to compare their source code text wouldn't take into account things like closure. JS doesn't provide structural equality comparison because it's almost intractable to handle all the corner cases!", "type": "text"}]}]}, "article_text": "Equal...ish\n\nThe most common comparison in JS programs asks the question, \"Is this X value the same as that Y value?\" What exactly does \"the same as\" really mean to JS, though?\n\nFor ergonomic and historical reasons, the meaning is more complicated than the obvious exact identity sort of matching. Sometimes an equality comparison intends exact matching, but other times the desired comparison is a bit broader, allowing closely similar or interchangeable matching. In other words, we must be aware of the nuanced differences between an equality comparison and an equivalence comparison.\n\nIf you've spent any time working with and reading about JS, you've certainly seen the so-called \"triple-equals\" === operator, also described as the \"strict equality\" operator. That seems rather straightforward, right? Surely, \"strict\" means strict, as in narrow and exact.\n\nNot exactly.\n\nYes, most values participating in an === equality comparison will fit with that exact same intuition. Consider some examples:\n\n3 === 3.0;              // true\n\"yes\" === \"yes\";        // true\nnull === null;          // true\nfalse === false;        // true\n\n42 === \"42\";            // false\n\"hello\" === \"Hello\";    // false\ntrue === 1;             // false\n0 === null;             // false\n\"\" === null;            // false\nnull === undefined;     // false\n\nNOTE:\n\nAnother way ==='s equality comparison is often described is, \"checking both the value and the type\". In several of the examples we've looked at so far, like 42 === \"42\", the type of both values (number, string, etc.) does seem to be the distinguishing factor. There's more to it than that, though. All value comparisons in JS consider the type of the values being compared, not just the === operator. Specifically, === disallows any sort of type conversion (aka, \"coercion\") in its comparison, where other JS comparisons do allow coercion.\n\nBut the === operator does have some nuance to it, a fact many JS developers gloss over, to their detriment. The === operator is designed to lie in two cases of special values: NaN and -0. Consider:\n\nNaN === NaN;            // false\n0 === -0;               // true\n\nIn the case of NaN, the === operator lies and says that an occurrence of NaN is not equal to another NaN. In the case of -0 (yes, this is a real, distinct value you can use intentionally in your programs!), the === operator lies and says it's equal to the regular 0 value.\n\nSince the lying about such comparisons can be bothersome, it's best to avoid using === for them. For NaN comparisons, use the Number.isNaN(..) utility, which does not lie. For -0 comparison, use the Object.is(..) utility, which also does not lie. Object.is(..) can also be used for non-lying NaN checks, if you prefer. Humorously, you could think of Object.is(..) as the \"quadruple-equals\" ====, the really-really-strict comparison!\n\nThere are deeper historical and technical reasons for these lies, but that doesn't change the fact that === is not actually strictly exactly equal comparison, in the strictest sense.\n\nThe story gets even more complicated when we consider comparisons of object values (non-primitives). Consider:\n\n[ 1, 2, 3 ] === [ 1, 2, 3 ];    // false\n{ a: 42 } === { a: 42 }         // false\n(x => x * 2) === (x => x * 2)   // false\n\nWhat's going on here?\n\nIt may seem reasonable to assume that an equality check considers the nature or contents of the value; after all, 42 === 42 considers the actual 42 value and compares it. But when it comes to objects, a content-aware comparison is generally referred to as \"structural equality.\"\n\nJS does not define === as structural equality for object values. Instead, === uses identity equality for object values.\n\nIn JS, all object values are held by reference (see \"Values vs References\" in Appendix A), are assigned and passed by reference-copy, and to our current discussion, are compared by reference (identity) equality. Consider:\n\nvar x = [ 1, 2, 3 ];\n\n// assignment is by reference-copy, so\n// y references the *same* array as x,\n// not another copy of it.\nvar y = x;\n\ny === x;              // true\ny === [ 1, 2, 3 ];    // false\nx === [ 1, 2, 3 ];    // false\n\nIn this snippet, y === x is true because both variables hold a reference to the same initial array. But the === [1,2,3] comparisons both fail because y and x, respectively, are being compared to new different arrays [1,2,3]. The array structure and contents don't matter in this comparison, only the reference identity.\n\nJS does not provide a mechanism for structural equality comparison of object values, only reference identity comparison. To do structural equality comparison, you'll need to implement the checks yourself.\n\nBut beware, it's more complicated than you'll assume. For example, how might you determine if two function references are \"structurally equivalent\"? Even stringifying to compare their source code text wouldn't take into account things like closure. JS doesn't provide structural equality comparison because it's almost intractable to handle all the corner cases!"}, "id": 125}, {"data": {"uuid": "969924d6-7d45-4765-9ef2-1a1cee9fa8a0", "user": 1, "title": "Coercive Comparisons", "author": "Kyle Simpson", "created_on": "2023-06-07 18:52:49.757814+00:00", "updated_on": "2023-06-07 18:53:19.666528+00:00", "article_html": "<h3>Coercive Comparisons</h3><p>Coercion means a value of one type being converted to its respective representation in another type (to whatever extent possible). As we'll discuss in Chapter 4, coercion is a core pillar of the JS language, not some optional feature that can reasonably be avoided.</p><p>But where coercion meets comparison operators (like equality), confusion and frustration unfortunately crop up more often than not.</p><p>Few JS features draw more ire in the broader JS community than the <code>==</code> operator, generally referred to as the \"loose equality\" operator. The majority of all writing and public discourse on JS condemns this operator as poorly designed and dangerous/bug-ridden when used in JS programs. Even the creator of the language himself, Brendan Eich, has lamented how it was designed as a big mistake.</p><p>From what I can tell, most of this frustration comes from a pretty short list of confusing corner cases, but a deeper problem is the extremely widespread misconception that it performs its comparisons without considering the types of its compared values.</p><p>The <code>==</code> operator performs an equality comparison similarly to how the <code>===</code> performs it. In fact, both operators consider the type of the values being compared. And if the comparison is between the same value type, both <code>==</code> and <code>===</code> <strong>do exactly the same thing, no difference whatsoever.</strong></p><p>If the value types being compared are different, the <code>==</code> differs from <code>===</code> in that it allows coercion before the comparison. In other words, they both want to compare values of like types, but <code>==</code> allows type conversions <em>first</em>, and once the types have been converted to be the same on both sides, then <code>==</code> does the same thing as <code>===</code>. Instead of \"loose equality,\" the <code>==</code> operator should be described as \"coercive equality.\"</p><p>Consider:</p><pre><code>42 == \"42\";             // true\n1 == true;              // true</code></pre><p>In both comparisons, the value types are different, so the <code>==</code> causes the non-number values (<code>\"42\"</code> and <code>true</code>) to be converted to numbers (<code>42</code> and <code>1</code>, respectively) before the comparisons are made.</p><p>Just being aware of this nature of <code>==</code>\u2014that it prefers primitive numeric comparisons\u2014helps you avoid most of the troublesome corner cases, such as staying away from a gotchas like <code>\"\" == 0</code> or <code>0 == false</code>.</p><p>You may be thinking, \"Oh, well, I will just always avoid any coercive equality comparison (using <code>===</code> instead) to avoid those corner cases\"! Eh, sorry, that's not quite as likely as you would hope.</p><p>There's a pretty good chance that you'll use relational comparison operators like <code>&lt;</code>, <code>&gt;</code> (and even <code>&lt;=</code> and <code>&gt;=</code>).</p><p>Just like <code>==</code>, these operators will perform as if they're \"strict\" if the types being relationally compared already match, but they'll allow coercion first (generally, to numbers) if the types differ.</p><p>Consider:</p><pre><code>var arr = [ \"1\", \"10\", \"100\", \"1000\" ];\nfor (let i = 0; i &lt; arr.length &amp;&amp; arr[i] &lt; 500; i++) {\n    // will run 3 times\n}</code></pre><p>The <code>i &lt; arr.length</code> comparison is \"safe\" from coercion because <code>i</code> and <code>arr.length</code> are always numbers. The <code>arr[i] &lt; 500</code> invokes coercion, though, because the <code>arr[i]</code> values are all strings. Those comparisons thus become <code>1 &lt; 500</code>, <code>10 &lt; 500</code>, <code>100 &lt; 500</code>, and <code>1000 &lt; 500</code>. Since that fourth one is false, the loop stops after its third iteration.</p><p>These relational operators typically use numeric comparisons, except in the case where <strong>both</strong> values being compared are already strings; in this case, they use alphabetical (dictionary-like) comparison of the strings:</p><pre><code>var x = \"10\";\nvar y = \"9\";\n\nx &lt; y;      // true, watch out!</code></pre><p>There's no way to get these relational operators to avoid coercion, other than to just never use mismatched types in the comparisons. That's perhaps admirable as a goal, but it's still pretty likely you're going to run into a case where the types <em>may</em> differ.</p><p>The wiser approach is not to avoid coercive comparisons, but to embrace and learn their ins and outs.</p><p>Coercive comparisons crop up in other places in JS, such as conditionals (<code>if</code>, etc.), which we'll revisit in Appendix A, \"Coercive Conditional Comparison.\"</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Coercive Comparisons", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Coercion means a value of one type being converted to its respective representation in another type (to whatever extent possible). As we'll discuss in Chapter 4, coercion is a core pillar of the JS language, not some optional feature that can reasonably be avoided.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But where coercion meets comparison operators (like equality), confusion and frustration unfortunately crop up more often than not.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Few JS features draw more ire in the broader JS community than the ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator, generally referred to as the \"loose equality\" operator. The majority of all writing and public discourse on JS condemns this operator as poorly designed and dangerous/bug-ridden when used in JS programs. Even the creator of the language himself, Brendan Eich, has lamented how it was designed as a big mistake.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "From what I can tell, most of this frustration comes from a pretty short list of confusing corner cases, but a deeper problem is the extremely widespread misconception that it performs its comparisons without considering the types of its compared values.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator performs an equality comparison similarly to how the ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " performs it. In fact, both operators consider the type of the values being compared. And if the comparison is between the same value type, both ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " ", "type": "text"}, {"text": "do exactly the same thing, no difference whatsoever.", "type": "text", "marks": [{"type": "bold"}]}]}, {"type": "paragraph", "content": [{"text": "If the value types being compared are different, the ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " differs from ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " in that it allows coercion before the comparison. In other words, they both want to compare values of like types, but ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " allows type conversions ", "type": "text"}, {"text": "first", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and once the types have been converted to be the same on both sides, then ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " does the same thing as ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Instead of \"loose equality,\" the ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator should be described as \"coercive equality.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "42 == \"42\";             // true\n1 == true;              // true", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In both comparisons, the value types are different, so the ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " causes the non-number values (", "type": "text"}, {"text": "\"42\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "true", "type": "text", "marks": [{"type": "code"}]}, {"text": ") to be converted to numbers (", "type": "text"}, {"text": "42", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": ", respectively) before the comparisons are made.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Just being aware of this nature of ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": "\u2014that it prefers primitive numeric comparisons\u2014helps you avoid most of the troublesome corner cases, such as staying away from a gotchas like ", "type": "text"}, {"text": "\"\" == 0", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "0 == false", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You may be thinking, \"Oh, well, I will just always avoid any coercive equality comparison (using ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead) to avoid those corner cases\"! Eh, sorry, that's not quite as likely as you would hope.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's a pretty good chance that you'll use relational comparison operators like ", "type": "text"}, {"text": "<", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": ">", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and even ", "type": "text"}, {"text": "<=", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": ">=", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Just like ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": ", these operators will perform as if they're \"strict\" if the types being relationally compared already match, but they'll allow coercion first (generally, to numbers) if the types differ.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var arr = [ \"1\", \"10\", \"100\", \"1000\" ];\nfor (let i = 0; i < arr.length && arr[i] < 500; i++) {\n    // will run 3 times\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "i < arr.length", "type": "text", "marks": [{"type": "code"}]}, {"text": " comparison is \"safe\" from coercion because ", "type": "text"}, {"text": "i", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "arr.length", "type": "text", "marks": [{"type": "code"}]}, {"text": " are always numbers. The ", "type": "text"}, {"text": "arr[i] < 500", "type": "text", "marks": [{"type": "code"}]}, {"text": " invokes coercion, though, because the ", "type": "text"}, {"text": "arr[i]", "type": "text", "marks": [{"type": "code"}]}, {"text": " values are all strings. Those comparisons thus become ", "type": "text"}, {"text": "1 < 500", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "10 < 500", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "100 < 500", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "1000 < 500", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Since that fourth one is false, the loop stops after its third iteration.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These relational operators typically use numeric comparisons, except in the case where ", "type": "text"}, {"text": "both", "type": "text", "marks": [{"type": "bold"}]}, {"text": " values being compared are already strings; in this case, they use alphabetical (dictionary-like) comparison of the strings:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var x = \"10\";\nvar y = \"9\";\n\nx < y;      // true, watch out!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's no way to get these relational operators to avoid coercion, other than to just never use mismatched types in the comparisons. That's perhaps admirable as a goal, but it's still pretty likely you're going to run into a case where the types ", "type": "text"}, {"text": "may", "type": "text", "marks": [{"type": "italic"}]}, {"text": " differ.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The wiser approach is not to avoid coercive comparisons, but to embrace and learn their ins and outs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Coercive comparisons crop up in other places in JS, such as conditionals (", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": ", etc.), which we'll revisit in Appendix A, \"Coercive Conditional Comparison.\"", "type": "text"}]}]}, "article_text": "Coercive Comparisons\n\nCoercion means a value of one type being converted to its respective representation in another type (to whatever extent possible). As we'll discuss in Chapter 4, coercion is a core pillar of the JS language, not some optional feature that can reasonably be avoided.\n\nBut where coercion meets comparison operators (like equality), confusion and frustration unfortunately crop up more often than not.\n\nFew JS features draw more ire in the broader JS community than the == operator, generally referred to as the \"loose equality\" operator. The majority of all writing and public discourse on JS condemns this operator as poorly designed and dangerous/bug-ridden when used in JS programs. Even the creator of the language himself, Brendan Eich, has lamented how it was designed as a big mistake.\n\nFrom what I can tell, most of this frustration comes from a pretty short list of confusing corner cases, but a deeper problem is the extremely widespread misconception that it performs its comparisons without considering the types of its compared values.\n\nThe == operator performs an equality comparison similarly to how the === performs it. In fact, both operators consider the type of the values being compared. And if the comparison is between the same value type, both == and === do exactly the same thing, no difference whatsoever.\n\nIf the value types being compared are different, the == differs from === in that it allows coercion before the comparison. In other words, they both want to compare values of like types, but == allows type conversions first, and once the types have been converted to be the same on both sides, then == does the same thing as ===. Instead of \"loose equality,\" the == operator should be described as \"coercive equality.\"\n\nConsider:\n\n42 == \"42\";             // true\n1 == true;              // true\n\nIn both comparisons, the value types are different, so the == causes the non-number values (\"42\" and true) to be converted to numbers (42 and 1, respectively) before the comparisons are made.\n\nJust being aware of this nature of ==\u2014that it prefers primitive numeric comparisons\u2014helps you avoid most of the troublesome corner cases, such as staying away from a gotchas like \"\" == 0 or 0 == false.\n\nYou may be thinking, \"Oh, well, I will just always avoid any coercive equality comparison (using === instead) to avoid those corner cases\"! Eh, sorry, that's not quite as likely as you would hope.\n\nThere's a pretty good chance that you'll use relational comparison operators like <, > (and even <= and >=).\n\nJust like ==, these operators will perform as if they're \"strict\" if the types being relationally compared already match, but they'll allow coercion first (generally, to numbers) if the types differ.\n\nConsider:\n\nvar arr = [ \"1\", \"10\", \"100\", \"1000\" ];\nfor (let i = 0; i < arr.length && arr[i] < 500; i++) {\n    // will run 3 times\n}\n\nThe i < arr.length comparison is \"safe\" from coercion because i and arr.length are always numbers. The arr[i] < 500 invokes coercion, though, because the arr[i] values are all strings. Those comparisons thus become 1 < 500, 10 < 500, 100 < 500, and 1000 < 500. Since that fourth one is false, the loop stops after its third iteration.\n\nThese relational operators typically use numeric comparisons, except in the case where both values being compared are already strings; in this case, they use alphabetical (dictionary-like) comparison of the strings:\n\nvar x = \"10\";\nvar y = \"9\";\n\nx < y;      // true, watch out!\n\nThere's no way to get these relational operators to avoid coercion, other than to just never use mismatched types in the comparisons. That's perhaps admirable as a goal, but it's still pretty likely you're going to run into a case where the types may differ.\n\nThe wiser approach is not to avoid coercive comparisons, but to embrace and learn their ins and outs.\n\nCoercive comparisons crop up in other places in JS, such as conditionals (if, etc.), which we'll revisit in Appendix A, \"Coercive Conditional Comparison.\""}, "id": 126}]}, {"data": {"uuid": "e33c3b23-698f-46ce-9a2b-da7b0fd41593", "user": 1, "title": "How We Organize in JS", "author": "Kyle Simpson", "created_on": "2023-06-07 18:53:44.722182+00:00", "updated_on": "2023-06-07 18:54:04.404892+00:00", "article_html": "<h2>How We Organize in JS</h2><p>Two major patterns for organizing code (data and behavior) are used broadly across the JS ecosystem: classes and modules. These patterns are not mutually exclusive; many programs can and do use both. Other programs will stick with just one pattern, or even neither!</p><p>In some respects, these patterns are very different. But interestingly, in other ways, they're just different sides of the same coin. Being proficient in JS requires understanding both patterns and where they are appropriate (and not!).</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "How We Organize in JS", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Two major patterns for organizing code (data and behavior) are used broadly across the JS ecosystem: classes and modules. These patterns are not mutually exclusive; many programs can and do use both. Other programs will stick with just one pattern, or even neither!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In some respects, these patterns are very different. But interestingly, in other ways, they're just different sides of the same coin. Being proficient in JS requires understanding both patterns and where they are appropriate (and not!).", "type": "text"}]}]}, "article_text": "How We Organize in JS\n\nTwo major patterns for organizing code (data and behavior) are used broadly across the JS ecosystem: classes and modules. These patterns are not mutually exclusive; many programs can and do use both. Other programs will stick with just one pattern, or even neither!\n\nIn some respects, these patterns are very different. But interestingly, in other ways, they're just different sides of the same coin. Being proficient in JS requires understanding both patterns and where they are appropriate (and not!)."}, "id": 127, "children": [{"data": {"uuid": "2e861b93-c028-4dda-9600-0fd35e192eab", "user": 1, "title": "Classes", "author": "Kyle Simpson", "created_on": "2023-06-07 18:54:25.100419+00:00", "updated_on": "2023-06-07 18:54:50.212635+00:00", "article_html": "<h3>Classes</h3><p>The terms \"object-oriented,\" \"class-oriented,\" and \"classes\" are all very loaded full of detail and nuance; they're not universal in definition.</p><p>We will use a common and somewhat traditional definition here, the one most likely familiar to those with backgrounds in \"object-oriented\" languages like C++ and Java.</p><p>A class in a program is a definition of a \"type\" of custom data structure that includes both data and behaviors that operate on that data. Classes define how such a data structure works, but classes are not themselves concrete values. To get a concrete value that you can use in the program, a class must be <em>instantiated</em> (with the <code>new</code> keyword) one or more times.</p><p>Consider:</p><pre><code>class Page {\n    constructor(text) {\n        this.text = text;\n    }\n\n    print() {\n        console.log(this.text);\n    }\n}\n\nclass Notebook {\n    constructor() {\n        this.pages = [];\n    }\n\n    addPage(text) {\n        var page = new Page(text);\n        this.pages.push(page);\n    }\n\n    print() {\n        for (let page of this.pages) {\n            page.print();\n        }\n    }\n}\n\nvar mathNotes = new Notebook();\nmathNotes.addPage(\"Arithmetic: + - * / ...\");\nmathNotes.addPage(\"Trigonometry: sin cos tan ...\");\n\nmathNotes.print();\n// ..</code></pre><p>In the <code>Page</code> class, the data is a string of text stored in a <code>this.text</code> member property. The behavior is <code>print()</code>, a method that dumps the text to the console.</p><p>For the <code>Notebook</code> class, the data is an array of <code>Page</code> instances. The behavior is <code>addPage(..)</code>, a method that instantiates new <code>Page</code> pages and adds them to the list, as well as <code>print()</code> (which prints out all the pages in the notebook).</p><p>The statement <code>mathNotes = new Notebook()</code> creates an instance of the <code>Notebook</code> class, and <code>page = new Page(text)</code> is where instances of the <code>Page</code> class are created.</p><p>Behavior (methods) can only be called on instances (not the classes themselves), such as <code>mathNotes.addPage(..)</code> and <code>page.print()</code>.</p><p>The <code>class</code> mechanism allows packaging data (<code>text</code> and <code>pages</code>) to be organized together with their behaviors (e.g., <code>addPage(..)</code> and <code>print()</code>). The same program could have been built without any <code>class</code> definitions, but it would likely have been much less organized, harder to read and reason about, and more susceptible to bugs and subpar maintenance.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Classes", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The terms \"object-oriented,\" \"class-oriented,\" and \"classes\" are all very loaded full of detail and nuance; they're not universal in definition.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We will use a common and somewhat traditional definition here, the one most likely familiar to those with backgrounds in \"object-oriented\" languages like C++ and Java.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A class in a program is a definition of a \"type\" of custom data structure that includes both data and behaviors that operate on that data. Classes define how such a data structure works, but classes are not themselves concrete values. To get a concrete value that you can use in the program, a class must be ", "type": "text"}, {"text": "instantiated", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (with the ", "type": "text"}, {"text": "new", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword) one or more times.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "class Page {\n    constructor(text) {\n        this.text = text;\n    }\n\n    print() {\n        console.log(this.text);\n    }\n}\n\nclass Notebook {\n    constructor() {\n        this.pages = [];\n    }\n\n    addPage(text) {\n        var page = new Page(text);\n        this.pages.push(page);\n    }\n\n    print() {\n        for (let page of this.pages) {\n            page.print();\n        }\n    }\n}\n\nvar mathNotes = new Notebook();\nmathNotes.addPage(\"Arithmetic: + - * / ...\");\nmathNotes.addPage(\"Trigonometry: sin cos tan ...\");\n\nmathNotes.print();\n// ..", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the ", "type": "text"}, {"text": "Page", "type": "text", "marks": [{"type": "code"}]}, {"text": " class, the data is a string of text stored in a ", "type": "text"}, {"text": "this.text", "type": "text", "marks": [{"type": "code"}]}, {"text": " member property. The behavior is ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", a method that dumps the text to the console.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For the ", "type": "text"}, {"text": "Notebook", "type": "text", "marks": [{"type": "code"}]}, {"text": " class, the data is an array of ", "type": "text"}, {"text": "Page", "type": "text", "marks": [{"type": "code"}]}, {"text": " instances. The behavior is ", "type": "text"}, {"text": "addPage(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ", a method that instantiates new ", "type": "text"}, {"text": "Page", "type": "text", "marks": [{"type": "code"}]}, {"text": " pages and adds them to the list, as well as ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": " (which prints out all the pages in the notebook).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The statement ", "type": "text"}, {"text": "mathNotes = new Notebook()", "type": "text", "marks": [{"type": "code"}]}, {"text": " creates an instance of the ", "type": "text"}, {"text": "Notebook", "type": "text", "marks": [{"type": "code"}]}, {"text": " class, and ", "type": "text"}, {"text": "page = new Page(text)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is where instances of the ", "type": "text"}, {"text": "Page", "type": "text", "marks": [{"type": "code"}]}, {"text": " class are created.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Behavior (methods) can only be called on instances (not the classes themselves), such as ", "type": "text"}, {"text": "mathNotes.addPage(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "page.print()", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " mechanism allows packaging data (", "type": "text"}, {"text": "text", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "pages", "type": "text", "marks": [{"type": "code"}]}, {"text": ") to be organized together with their behaviors (e.g., ", "type": "text"}, {"text": "addPage(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": "). The same program could have been built without any ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " definitions, but it would likely have been much less organized, harder to read and reason about, and more susceptible to bugs and subpar maintenance.", "type": "text"}]}]}, "article_text": "Classes\n\nThe terms \"object-oriented,\" \"class-oriented,\" and \"classes\" are all very loaded full of detail and nuance; they're not universal in definition.\n\nWe will use a common and somewhat traditional definition here, the one most likely familiar to those with backgrounds in \"object-oriented\" languages like C++ and Java.\n\nA class in a program is a definition of a \"type\" of custom data structure that includes both data and behaviors that operate on that data. Classes define how such a data structure works, but classes are not themselves concrete values. To get a concrete value that you can use in the program, a class must be instantiated (with the new keyword) one or more times.\n\nConsider:\n\nclass Page {\n    constructor(text) {\n        this.text = text;\n    }\n\n    print() {\n        console.log(this.text);\n    }\n}\n\nclass Notebook {\n    constructor() {\n        this.pages = [];\n    }\n\n    addPage(text) {\n        var page = new Page(text);\n        this.pages.push(page);\n    }\n\n    print() {\n        for (let page of this.pages) {\n            page.print();\n        }\n    }\n}\n\nvar mathNotes = new Notebook();\nmathNotes.addPage(\"Arithmetic: + - * / ...\");\nmathNotes.addPage(\"Trigonometry: sin cos tan ...\");\n\nmathNotes.print();\n// ..\n\nIn the Page class, the data is a string of text stored in a this.text member property. The behavior is print(), a method that dumps the text to the console.\n\nFor the Notebook class, the data is an array of Page instances. The behavior is addPage(..), a method that instantiates new Page pages and adds them to the list, as well as print() (which prints out all the pages in the notebook).\n\nThe statement mathNotes = new Notebook() creates an instance of the Notebook class, and page = new Page(text) is where instances of the Page class are created.\n\nBehavior (methods) can only be called on instances (not the classes themselves), such as mathNotes.addPage(..) and page.print().\n\nThe class mechanism allows packaging data (text and pages) to be organized together with their behaviors (e.g., addPage(..) and print()). The same program could have been built without any class definitions, but it would likely have been much less organized, harder to read and reason about, and more susceptible to bugs and subpar maintenance."}, "id": 128, "children": [{"data": {"uuid": "126abb2e-cb0e-41b0-b73d-91005c361911", "user": 1, "title": "Class Inheritance", "author": "Kyle Simpson", "created_on": "2023-06-07 18:55:09.362122+00:00", "updated_on": "2023-06-07 18:55:38.692138+00:00", "article_html": "<h4>Class Inheritance</h4><p>Another aspect inherent to traditional \"class-oriented\" design, though a bit less commonly used in JS, is \"inheritance\" (and \"polymorphism\"). Consider:</p><pre><code>class Publication {\n    constructor(title,author,pubDate) {\n        this.title = title;\n        this.author = author;\n        this.pubDate = pubDate;\n    }\n\n    print() {\n        console.log(`\n            Title: ${ this.title }\n            By: ${ this.author }\n            ${ this.pubDate }\n        `);\n    }\n}</code></pre><p>This <code>Publication</code> class defines a set of common behavior that any publication might need.</p><p>Now let's consider more specific types of publication, like <code>Book</code> and <code>BlogPost</code>:</p><pre><code>class Book extends Publication {\n    constructor(bookDetails) {\n        super(\n            bookDetails.title,\n            bookDetails.author,\n            bookDetails.publishedOn\n        );\n        this.publisher = bookDetails.publisher;\n        this.ISBN = bookDetails.ISBN;\n    }\n\n    print() {\n        super.print();\n        console.log(`\n            Publisher: ${ this.publisher }\n            ISBN: ${ this.ISBN }\n        `);\n    }\n}\n\nclass BlogPost extends Publication {\n    constructor(title,author,pubDate,URL) {\n        super(title,author,pubDate);\n        this.URL = URL;\n    }\n\n    print() {\n        super.print();\n        console.log(this.URL);\n    }\n}</code></pre><p>Both <code>Book</code> and <code>BlogPost</code> use the <code>extends</code> clause to <em>extend</em> the general definition of <code>Publication</code> to include additional behavior. The <code>super(..)</code> call in each constructor delegates to the parent <code>Publication</code> class's constructor for its initialization work, and then they do more specific things according to their respective publication type (aka, \"sub-class\" or \"child class\").</p><p>Now consider using these child classes:</p><pre><code>var YDKJS = new Book({\n    title: \"You Don't Know JS\",\n    author: \"Kyle Simpson\",\n    publishedOn: \"June 2014\",\n    publisher: \"O'Reilly\",\n    ISBN: \"123456-789\"\n});\n\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\n\nvar forAgainstLet = new BlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let</code></pre><p>Notice that both child class instances have a <code>print()</code> method, which was an override of the <em>inherited</em> <code>print()</code> method from the parent <code>Publication</code> class. Each of those overridden child class <code>print()</code> methods call <code>super.print()</code> to invoke the inherited version of the <code>print()</code> method.</p><p>The fact that both the inherited and overridden methods can have the same name and co-exist is called <em>polymorphism</em>.</p><p>Inheritance is a powerful tool for organizing data/behavior in separate logical units (classes), but allowing the child class to cooperate with the parent by accessing/using its behavior and data.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Class Inheritance", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another aspect inherent to traditional \"class-oriented\" design, though a bit less commonly used in JS, is \"inheritance\" (and \"polymorphism\"). Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "class Publication {\n    constructor(title,author,pubDate) {\n        this.title = title;\n        this.author = author;\n        this.pubDate = pubDate;\n    }\n\n    print() {\n        console.log(`\n            Title: ${ this.title }\n            By: ${ this.author }\n            ${ this.pubDate }\n        `);\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This ", "type": "text"}, {"text": "Publication", "type": "text", "marks": [{"type": "code"}]}, {"text": " class defines a set of common behavior that any publication might need.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now let's consider more specific types of publication, like ", "type": "text"}, {"text": "Book", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "BlogPost", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "class Book extends Publication {\n    constructor(bookDetails) {\n        super(\n            bookDetails.title,\n            bookDetails.author,\n            bookDetails.publishedOn\n        );\n        this.publisher = bookDetails.publisher;\n        this.ISBN = bookDetails.ISBN;\n    }\n\n    print() {\n        super.print();\n        console.log(`\n            Publisher: ${ this.publisher }\n            ISBN: ${ this.ISBN }\n        `);\n    }\n}\n\nclass BlogPost extends Publication {\n    constructor(title,author,pubDate,URL) {\n        super(title,author,pubDate);\n        this.URL = URL;\n    }\n\n    print() {\n        super.print();\n        console.log(this.URL);\n    }\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Both ", "type": "text"}, {"text": "Book", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "BlogPost", "type": "text", "marks": [{"type": "code"}]}, {"text": " use the ", "type": "text"}, {"text": "extends", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause to ", "type": "text"}, {"text": "extend", "type": "text", "marks": [{"type": "italic"}]}, {"text": " the general definition of ", "type": "text"}, {"text": "Publication", "type": "text", "marks": [{"type": "code"}]}, {"text": " to include additional behavior. The ", "type": "text"}, {"text": "super(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " call in each constructor delegates to the parent ", "type": "text"}, {"text": "Publication", "type": "text", "marks": [{"type": "code"}]}, {"text": " class's constructor for its initialization work, and then they do more specific things according to their respective publication type (aka, \"sub-class\" or \"child class\").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now consider using these child classes:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var YDKJS = new Book({\n    title: \"You Don't Know JS\",\n    author: \"Kyle Simpson\",\n    publishedOn: \"June 2014\",\n    publisher: \"O'Reilly\",\n    ISBN: \"123456-789\"\n});\n\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\n\nvar forAgainstLet = new BlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice that both child class instances have a ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method, which was an override of the ", "type": "text"}, {"text": "inherited", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method from the parent ", "type": "text"}, {"text": "Publication", "type": "text", "marks": [{"type": "code"}]}, {"text": " class. Each of those overridden child class ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": " methods call ", "type": "text"}, {"text": "super.print()", "type": "text", "marks": [{"type": "code"}]}, {"text": " to invoke the inherited version of the ", "type": "text"}, {"text": "print()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The fact that both the inherited and overridden methods can have the same name and co-exist is called ", "type": "text"}, {"text": "polymorphism", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Inheritance is a powerful tool for organizing data/behavior in separate logical units (classes), but allowing the child class to cooperate with the parent by accessing/using its behavior and data.", "type": "text"}]}]}, "article_text": "Class Inheritance\n\nAnother aspect inherent to traditional \"class-oriented\" design, though a bit less commonly used in JS, is \"inheritance\" (and \"polymorphism\"). Consider:\n\nclass Publication {\n    constructor(title,author,pubDate) {\n        this.title = title;\n        this.author = author;\n        this.pubDate = pubDate;\n    }\n\n    print() {\n        console.log(`\n            Title: ${ this.title }\n            By: ${ this.author }\n            ${ this.pubDate }\n        `);\n    }\n}\n\nThis Publication class defines a set of common behavior that any publication might need.\n\nNow let's consider more specific types of publication, like Book and BlogPost:\n\nclass Book extends Publication {\n    constructor(bookDetails) {\n        super(\n            bookDetails.title,\n            bookDetails.author,\n            bookDetails.publishedOn\n        );\n        this.publisher = bookDetails.publisher;\n        this.ISBN = bookDetails.ISBN;\n    }\n\n    print() {\n        super.print();\n        console.log(`\n            Publisher: ${ this.publisher }\n            ISBN: ${ this.ISBN }\n        `);\n    }\n}\n\nclass BlogPost extends Publication {\n    constructor(title,author,pubDate,URL) {\n        super(title,author,pubDate);\n        this.URL = URL;\n    }\n\n    print() {\n        super.print();\n        console.log(this.URL);\n    }\n}\n\nBoth Book and BlogPost use the extends clause to extend the general definition of Publication to include additional behavior. The super(..) call in each constructor delegates to the parent Publication class's constructor for its initialization work, and then they do more specific things according to their respective publication type (aka, \"sub-class\" or \"child class\").\n\nNow consider using these child classes:\n\nvar YDKJS = new Book({\n    title: \"You Don't Know JS\",\n    author: \"Kyle Simpson\",\n    publishedOn: \"June 2014\",\n    publisher: \"O'Reilly\",\n    ISBN: \"123456-789\"\n});\n\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\n\nvar forAgainstLet = new BlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let\n\nNotice that both child class instances have a print() method, which was an override of the inherited print() method from the parent Publication class. Each of those overridden child class print() methods call super.print() to invoke the inherited version of the print() method.\n\nThe fact that both the inherited and overridden methods can have the same name and co-exist is called polymorphism.\n\nInheritance is a powerful tool for organizing data/behavior in separate logical units (classes), but allowing the child class to cooperate with the parent by accessing/using its behavior and data."}, "id": 129}]}, {"data": {"uuid": "1cd23d4e-5900-4ed5-87f0-eb12a9888a4b", "user": 1, "title": "Modules", "author": "Kyle Simpson", "created_on": "2023-06-07 18:56:15.104634+00:00", "updated_on": "2023-06-07 18:56:34.767149+00:00", "article_html": "<h3>Modules</h3><p>The module pattern has essentially the same goal as the class pattern, which is to group data and behavior together into logical units. Also like classes, modules can \"include\" or \"access\" the data and behaviors of other modules, for cooperation's sake.</p><p>But modules have some important differences from classes. Most notably, the syntax is entirely different.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Modules", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The module pattern has essentially the same goal as the class pattern, which is to group data and behavior together into logical units. Also like classes, modules can \"include\" or \"access\" the data and behaviors of other modules, for cooperation's sake.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But modules have some important differences from classes. Most notably, the syntax is entirely different.", "type": "text"}]}]}, "article_text": "Modules\n\nThe module pattern has essentially the same goal as the class pattern, which is to group data and behavior together into logical units. Also like classes, modules can \"include\" or \"access\" the data and behaviors of other modules, for cooperation's sake.\n\nBut modules have some important differences from classes. Most notably, the syntax is entirely different."}, "id": 130, "children": [{"data": {"uuid": "0b235603-8ae9-427f-a2ca-fb8b7124113e", "user": 1, "title": "Classic Modules", "author": "Kyle Simpson", "created_on": "2023-06-07 18:56:53.607493+00:00", "updated_on": "2023-06-07 18:57:19.970249+00:00", "article_html": "<h4>Classic Modules</h4><p>ES6 added a module syntax form to native JS syntax, which we'll look at in a moment. But from the early days of JS, modules was an important and common pattern that was leveraged in countless JS programs, even without a dedicated syntax.</p><p>The key hallmarks of a <em>classic module</em> are an outer function (that runs at least once), which returns an \"instance\" of the module with one or more functions exposed that can operate on the module instance's internal (hidden) data.</p><p>Because a module of this form is <em>just a function</em>, and calling it produces an \"instance\" of the module, another description for these functions is \"module factories\".</p><p>Consider the classic module form of the earlier <code>Publication</code>, <code>Book</code>, and <code>BlogPost</code> classes:</p><pre><code>function Publication(title,author,pubDate) {\n    var publicAPI = {\n        print() {\n            console.log(`\n                Title: ${ title }\n                By: ${ author }\n                ${ pubDate }\n            `);\n        }\n    };\n\n    return publicAPI;\n}\n\nfunction Book(bookDetails) {\n    var pub = Publication(\n        bookDetails.title,\n        bookDetails.author,\n        bookDetails.publishedOn\n    );\n\n    var publicAPI = {\n        print() {\n            pub.print();\n            console.log(`\n                Publisher: ${ bookDetails.publisher }\n                ISBN: ${ bookDetails.ISBN }\n            `);\n        }\n    };\n\n    return publicAPI;\n}\n\nfunction BlogPost(title,author,pubDate,URL) {\n    var pub = Publication(title,author,pubDate);\n\n    var publicAPI = {\n        print() {\n            pub.print();\n            console.log(URL);\n        }\n    };\n\n    return publicAPI;\n}</code></pre><p>Comparing these forms to the <code>class</code> forms, there are more similarities than differences.</p><p>The <code>class</code> form stores methods and data on an object instance, which must be accessed with the <code>this.</code> prefix. With modules, the methods and data are accessed as identifier variables in scope, without any <code>this.</code> prefix.</p><p>With <code>class</code>, the \"API\" of an instance is implicit in the class definition\u2014also, all data and methods are public. With the module factory function, you explicitly create and return an object with any publicly exposed methods, and any data or other unreferenced methods remain private inside the factory function.</p><p>There are other variations to this factory function form that are quite common across JS, even in 2020; you may run across these forms in different JS programs: AMD (Asynchronous Module Definition), UMD (Universal Module Definition), and CommonJS (classic Node.js-style modules). The variations are minor (not quite compatible). However, all of these forms rely on the same basic principles.</p><p>Consider also the usage (aka, \"instantiation\") of these module factory functions:</p><pre><code>var YDKJS = Book({\n    title: \"You Don't Know JS\",\n    author: \"Kyle Simpson\",\n    publishedOn: \"June 2014\",\n    publisher: \"O'Reilly\",\n    ISBN: \"123456-789\"\n});\n\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\n\nvar forAgainstLet = BlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let</code></pre><p>The only observable difference here is the lack of using <code>new</code>, calling the module factories as normal functions.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 4}, "content": [{"text": "Classic Modules", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES6 added a module syntax form to native JS syntax, which we'll look at in a moment. But from the early days of JS, modules was an important and common pattern that was leveraged in countless JS programs, even without a dedicated syntax.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The key hallmarks of a ", "type": "text"}, {"text": "classic module", "type": "text", "marks": [{"type": "italic"}]}, {"text": " are an outer function (that runs at least once), which returns an \"instance\" of the module with one or more functions exposed that can operate on the module instance's internal (hidden) data.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Because a module of this form is ", "type": "text"}, {"text": "just a function", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and calling it produces an \"instance\" of the module, another description for these functions is \"module factories\".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider the classic module form of the earlier ", "type": "text"}, {"text": "Publication", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "Book", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "BlogPost", "type": "text", "marks": [{"type": "code"}]}, {"text": " classes:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function Publication(title,author,pubDate) {\n    var publicAPI = {\n        print() {\n            console.log(`\n                Title: ${ title }\n                By: ${ author }\n                ${ pubDate }\n            `);\n        }\n    };\n\n    return publicAPI;\n}\n\nfunction Book(bookDetails) {\n    var pub = Publication(\n        bookDetails.title,\n        bookDetails.author,\n        bookDetails.publishedOn\n    );\n\n    var publicAPI = {\n        print() {\n            pub.print();\n            console.log(`\n                Publisher: ${ bookDetails.publisher }\n                ISBN: ${ bookDetails.ISBN }\n            `);\n        }\n    };\n\n    return publicAPI;\n}\n\nfunction BlogPost(title,author,pubDate,URL) {\n    var pub = Publication(title,author,pubDate);\n\n    var publicAPI = {\n        print() {\n            pub.print();\n            console.log(URL);\n        }\n    };\n\n    return publicAPI;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Comparing these forms to the ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " forms, there are more similarities than differences.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " form stores methods and data on an object instance, which must be accessed with the ", "type": "text"}, {"text": "this.", "type": "text", "marks": [{"type": "code"}]}, {"text": " prefix. With modules, the methods and data are accessed as identifier variables in scope, without any ", "type": "text"}, {"text": "this.", "type": "text", "marks": [{"type": "code"}]}, {"text": " prefix.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": ", the \"API\" of an instance is implicit in the class definition\u2014also, all data and methods are public. With the module factory function, you explicitly create and return an object with any publicly exposed methods, and any data or other unreferenced methods remain private inside the factory function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are other variations to this factory function form that are quite common across JS, even in 2020; you may run across these forms in different JS programs: AMD (Asynchronous Module Definition), UMD (Universal Module Definition), and CommonJS (classic Node.js-style modules). The variations are minor (not quite compatible). However, all of these forms rely on the same basic principles.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider also the usage (aka, \"instantiation\") of these module factory functions:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var YDKJS = Book({\n    title: \"You Don't Know JS\",\n    author: \"Kyle Simpson\",\n    publishedOn: \"June 2014\",\n    publisher: \"O'Reilly\",\n    ISBN: \"123456-789\"\n});\n\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\n\nvar forAgainstLet = BlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The only observable difference here is the lack of using ", "type": "text"}, {"text": "new", "type": "text", "marks": [{"type": "code"}]}, {"text": ", calling the module factories as normal functions.", "type": "text"}]}]}, "article_text": "Classic Modules\n\nES6 added a module syntax form to native JS syntax, which we'll look at in a moment. But from the early days of JS, modules was an important and common pattern that was leveraged in countless JS programs, even without a dedicated syntax.\n\nThe key hallmarks of a classic module are an outer function (that runs at least once), which returns an \"instance\" of the module with one or more functions exposed that can operate on the module instance's internal (hidden) data.\n\nBecause a module of this form is just a function, and calling it produces an \"instance\" of the module, another description for these functions is \"module factories\".\n\nConsider the classic module form of the earlier Publication, Book, and BlogPost classes:\n\nfunction Publication(title,author,pubDate) {\n    var publicAPI = {\n        print() {\n            console.log(`\n                Title: ${ title }\n                By: ${ author }\n                ${ pubDate }\n            `);\n        }\n    };\n\n    return publicAPI;\n}\n\nfunction Book(bookDetails) {\n    var pub = Publication(\n        bookDetails.title,\n        bookDetails.author,\n        bookDetails.publishedOn\n    );\n\n    var publicAPI = {\n        print() {\n            pub.print();\n            console.log(`\n                Publisher: ${ bookDetails.publisher }\n                ISBN: ${ bookDetails.ISBN }\n            `);\n        }\n    };\n\n    return publicAPI;\n}\n\nfunction BlogPost(title,author,pubDate,URL) {\n    var pub = Publication(title,author,pubDate);\n\n    var publicAPI = {\n        print() {\n            pub.print();\n            console.log(URL);\n        }\n    };\n\n    return publicAPI;\n}\n\nComparing these forms to the class forms, there are more similarities than differences.\n\nThe class form stores methods and data on an object instance, which must be accessed with the this. prefix. With modules, the methods and data are accessed as identifier variables in scope, without any this. prefix.\n\nWith class, the \"API\" of an instance is implicit in the class definition\u2014also, all data and methods are public. With the module factory function, you explicitly create and return an object with any publicly exposed methods, and any data or other unreferenced methods remain private inside the factory function.\n\nThere are other variations to this factory function form that are quite common across JS, even in 2020; you may run across these forms in different JS programs: AMD (Asynchronous Module Definition), UMD (Universal Module Definition), and CommonJS (classic Node.js-style modules). The variations are minor (not quite compatible). However, all of these forms rely on the same basic principles.\n\nConsider also the usage (aka, \"instantiation\") of these module factory functions:\n\nvar YDKJS = Book({\n    title: \"You Don't Know JS\",\n    author: \"Kyle Simpson\",\n    publishedOn: \"June 2014\",\n    publisher: \"O'Reilly\",\n    ISBN: \"123456-789\"\n});\n\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\n\nvar forAgainstLet = BlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let\n\nThe only observable difference here is the lack of using new, calling the module factories as normal functions."}, "id": 131}, {"data": {"uuid": "81889543-0cb3-4b27-bb15-c964591a0952", "user": 1, "title": "ES Modules", "author": "Kyle Simpson", "created_on": "2023-06-07 18:57:43.714573+00:00", "updated_on": "2023-06-07 18:58:41.178572+00:00", "article_html": "<h4>ES Modules</h4><p>ES modules (ESM), introduced to the JS language in ES6, are meant to serve much the same spirit and purpose as the existing <em>classic modules</em> just described, especially taking into account important variations and use cases from AMD, UMD, and CommonJS.</p><p>The implementation approach does, however, differ significantly.</p><p>First, there's no wrapping function to <em>define</em> a module. The wrapping context is a file. ESMs are always file-based; one file, one module.</p><p>Second, you don't interact with a module's \"API\" explicitly, but rather use the <code>export</code> keyword to add a variable or method to its public API definition. If something is defined in a module but not <code>export</code>ed, then it stays hidden (just as with <em>classic modules</em>).</p><p>Third, and maybe most noticeably different from previously discussed patterns, you don't \"instantiate\" an ES module, you just <code>import</code> it to use its single instance. ESMs are, in effect, \"singletons,\" in that there's only one instance ever created, at first <code>import</code> in your program, and all other <code>import</code>s just receive a reference to that same single instance. If your module needs to support multiple instantiations, you have to provide a <em>classic module-style</em> factory function on your ESM definition for that purpose.</p><p>In our running example, we do assume multiple-instantiation, so these following snippets will mix both ESM and <em>classic modules</em>.</p><p>Consider the file <code>publication.js</code>:</p><pre><code>function printDetails(title,author,pubDate) {\n    console.log(`\n        Title: ${ title }\n        By: ${ author }\n        ${ pubDate }\n    `);\n}\n\nexport function create(title,author,pubDate) {\n    var publicAPI = {\n        print() {\n            printDetails(title,author,pubDate);\n        }\n    };\n\n    return publicAPI;\n}</code></pre><p>To import and use this module, from another ES module like <code>blogpost.js</code>:</p><pre><code>import { create as createPub } from \"publication.js\";\n\nfunction printDetails(pub,URL) {\n    pub.print();\n    console.log(URL);\n}\n\nexport function create(title,author,pubDate,URL) {\n    var pub = createPub(title,author,pubDate);\n\n    var publicAPI = {\n        print() {\n            printDetails(pub,URL);\n        }\n    };\n\n    return publicAPI;\n}</code></pre><p>And finally, to use this module, we import into another ES module like <code>main.js</code>:</p><pre><code>import { create as newBlogPost } from \"blogpost.js\";\n\nvar forAgainstLet = newBlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>The <code>as newBlogPost</code> clause in the <code>import</code> statement is optional; if omitted, a top-level function just named <code>create(..)</code> would be imported. In this case, I'm renaming it for readability's sake; its more generic factory name of <code>create(..)</code> becomes more semantically descriptive of its purpose as <code>newBlogPost(..)</code>.</p></td></tr></tbody></table><p>As shown, ES modules can use <em>classic modules</em> internally if they need to support multiple-instantiation. Alternatively, we could have exposed a <code>class</code> from our module instead of a <code>create(..)</code> factory function, with generally the same outcome. However, since you're already using ESM at that point, I'd recommend sticking with <em>classic modules</em> instead of <code>class</code>.</p><p>If your module only needs a single instance, you can skip the extra layers of complexity: <code>export</code> its public methods directly.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 4}, "content": [{"text": "ES Modules", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES modules (ESM), introduced to the JS language in ES6, are meant to serve much the same spirit and purpose as the existing ", "type": "text"}, {"text": "classic modules", "type": "text", "marks": [{"type": "italic"}]}, {"text": " just described, especially taking into account important variations and use cases from AMD, UMD, and CommonJS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The implementation approach does, however, differ significantly.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First, there's no wrapping function to ", "type": "text"}, {"text": "define", "type": "text", "marks": [{"type": "italic"}]}, {"text": " a module. The wrapping context is a file. ESMs are always file-based; one file, one module.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Second, you don't interact with a module's \"API\" explicitly, but rather use the ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword to add a variable or method to its public API definition. If something is defined in a module but not ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": "ed, then it stays hidden (just as with ", "type": "text"}, {"text": "classic modules", "type": "text", "marks": [{"type": "italic"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Third, and maybe most noticeably different from previously discussed patterns, you don't \"instantiate\" an ES module, you just ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " it to use its single instance. ESMs are, in effect, \"singletons,\" in that there's only one instance ever created, at first ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " in your program, and all other ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": "s just receive a reference to that same single instance. If your module needs to support multiple instantiations, you have to provide a ", "type": "text"}, {"text": "classic module-style", "type": "text", "marks": [{"type": "italic"}]}, {"text": " factory function on your ESM definition for that purpose.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In our running example, we do assume multiple-instantiation, so these following snippets will mix both ESM and ", "type": "text"}, {"text": "classic modules", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider the file ", "type": "text"}, {"text": "publication.js", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function printDetails(title,author,pubDate) {\n    console.log(`\n        Title: ${ title }\n        By: ${ author }\n        ${ pubDate }\n    `);\n}\n\nexport function create(title,author,pubDate) {\n    var publicAPI = {\n        print() {\n            printDetails(title,author,pubDate);\n        }\n    };\n\n    return publicAPI;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To import and use this module, from another ES module like ", "type": "text"}, {"text": "blogpost.js", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import { create as createPub } from \"publication.js\";\n\nfunction printDetails(pub,URL) {\n    pub.print();\n    console.log(URL);\n}\n\nexport function create(title,author,pubDate,URL) {\n    var pub = createPub(title,author,pubDate);\n\n    var publicAPI = {\n        print() {\n            printDetails(pub,URL);\n        }\n    };\n\n    return publicAPI;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And finally, to use this module, we import into another ES module like ", "type": "text"}, {"text": "main.js", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "import { create as newBlogPost } from \"blogpost.js\";\n\nvar forAgainstLet = newBlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "as newBlogPost", "type": "text", "marks": [{"type": "code"}]}, {"text": " clause in the ", "type": "text"}, {"text": "import", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement is optional; if omitted, a top-level function just named ", "type": "text"}, {"text": "create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " would be imported. In this case, I'm renaming it for readability's sake; its more generic factory name of ", "type": "text"}, {"text": "create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " becomes more semantically descriptive of its purpose as ", "type": "text"}, {"text": "newBlogPost(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "As shown, ES modules can use ", "type": "text"}, {"text": "classic modules", "type": "text", "marks": [{"type": "italic"}]}, {"text": " internally if they need to support multiple-instantiation. Alternatively, we could have exposed a ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " from our module instead of a ", "type": "text"}, {"text": "create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " factory function, with generally the same outcome. However, since you're already using ESM at that point, I'd recommend sticking with ", "type": "text"}, {"text": "classic modules", "type": "text", "marks": [{"type": "italic"}]}, {"text": " instead of ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If your module only needs a single instance, you can skip the extra layers of complexity: ", "type": "text"}, {"text": "export", "type": "text", "marks": [{"type": "code"}]}, {"text": " its public methods directly.", "type": "text"}]}]}, "article_text": "ES Modules\n\nES modules (ESM), introduced to the JS language in ES6, are meant to serve much the same spirit and purpose as the existing classic modules just described, especially taking into account important variations and use cases from AMD, UMD, and CommonJS.\n\nThe implementation approach does, however, differ significantly.\n\nFirst, there's no wrapping function to define a module. The wrapping context is a file. ESMs are always file-based; one file, one module.\n\nSecond, you don't interact with a module's \"API\" explicitly, but rather use the export keyword to add a variable or method to its public API definition. If something is defined in a module but not exported, then it stays hidden (just as with classic modules).\n\nThird, and maybe most noticeably different from previously discussed patterns, you don't \"instantiate\" an ES module, you just import it to use its single instance. ESMs are, in effect, \"singletons,\" in that there's only one instance ever created, at first import in your program, and all other imports just receive a reference to that same single instance. If your module needs to support multiple instantiations, you have to provide a classic module-style factory function on your ESM definition for that purpose.\n\nIn our running example, we do assume multiple-instantiation, so these following snippets will mix both ESM and classic modules.\n\nConsider the file publication.js:\n\nfunction printDetails(title,author,pubDate) {\n    console.log(`\n        Title: ${ title }\n        By: ${ author }\n        ${ pubDate }\n    `);\n}\n\nexport function create(title,author,pubDate) {\n    var publicAPI = {\n        print() {\n            printDetails(title,author,pubDate);\n        }\n    };\n\n    return publicAPI;\n}\n\nTo import and use this module, from another ES module like blogpost.js:\n\nimport { create as createPub } from \"publication.js\";\n\nfunction printDetails(pub,URL) {\n    pub.print();\n    console.log(URL);\n}\n\nexport function create(title,author,pubDate,URL) {\n    var pub = createPub(title,author,pubDate);\n\n    var publicAPI = {\n        print() {\n            printDetails(pub,URL);\n        }\n    };\n\n    return publicAPI;\n}\n\nAnd finally, to use this module, we import into another ES module like main.js:\n\nimport { create as newBlogPost } from \"blogpost.js\";\n\nvar forAgainstLet = newBlogPost(\n    \"For and against let\",\n    \"Kyle Simpson\",\n    \"October 27, 2014\",\n    \"https://davidwalsh.name/for-and-against-let\"\n);\n\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let\n\nNOTE:\n\nThe as newBlogPost clause in the import statement is optional; if omitted, a top-level function just named create(..) would be imported. In this case, I'm renaming it for readability's sake; its more generic factory name of create(..) becomes more semantically descriptive of its purpose as newBlogPost(..).\n\nAs shown, ES modules can use classic modules internally if they need to support multiple-instantiation. Alternatively, we could have exposed a class from our module instead of a create(..) factory function, with generally the same outcome. However, since you're already using ESM at that point, I'd recommend sticking with classic modules instead of class.\n\nIf your module only needs a single instance, you can skip the extra layers of complexity: export its public methods directly."}, "id": 132}]}]}, {"data": {"uuid": "d186592f-29da-498e-9bf7-4405b33cfdd2", "user": 1, "title": "The Rabbit Hole Deepens", "author": "Kyle Simpson", "created_on": "2023-06-07 18:59:13.216960+00:00", "updated_on": "2023-06-07 18:59:29.886980+00:00", "article_html": "<h2>The Rabbit Hole Deepens</h2><p>As promised at the top of this chapter, we just glanced over a wide surface area of the main parts of the JS language. Your head may still be spinning, but that's entirely natural after such a firehose of information!</p><p>Even with just this \"brief\" survey of JS, we covered or hinted at a ton of details you should carefully consider and ensure you are comfortable with. I'm serious when I suggest: re-read this chapter, maybe several times.</p><p>In the next chapter, we're going to dig much deeper into some important aspects of how JS works at its core. But before you follow that rabbit hole deeper, make sure you've taken adequate time to fully digest what we've just covered here.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "The Rabbit Hole Deepens", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As promised at the top of this chapter, we just glanced over a wide surface area of the main parts of the JS language. Your head may still be spinning, but that's entirely natural after such a firehose of information!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even with just this \"brief\" survey of JS, we covered or hinted at a ton of details you should carefully consider and ensure you are comfortable with. I'm serious when I suggest: re-read this chapter, maybe several times.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the next chapter, we're going to dig much deeper into some important aspects of how JS works at its core. But before you follow that rabbit hole deeper, make sure you've taken adequate time to fully digest what we've just covered here.", "type": "text"}]}]}, "article_text": "The Rabbit Hole Deepens\n\nAs promised at the top of this chapter, we just glanced over a wide surface area of the main parts of the JS language. Your head may still be spinning, but that's entirely natural after such a firehose of information!\n\nEven with just this \"brief\" survey of JS, we covered or hinted at a ton of details you should carefully consider and ensure you are comfortable with. I'm serious when I suggest: re-read this chapter, maybe several times.\n\nIn the next chapter, we're going to dig much deeper into some important aspects of how JS works at its core. But before you follow that rabbit hole deeper, make sure you've taken adequate time to fully digest what we've just covered here."}, "id": 133}]}, {"data": {"uuid": "b4a0112f-b2b7-4b95-a382-f30f29984124", "user": 1, "title": "Chapter 3: Digging to the Roots of JS", "author": "Kyle Simpson", "created_on": "2023-06-07 20:26:11.308720+00:00", "updated_on": "2023-06-07 20:26:30.602813+00:00", "article_html": "<h1>Chapter 3: Digging to the Roots of JS</h1><p>If you've read Chapters 1 and 2, and taken the time to digest and percolate, you're hopefully starting to <em>get</em> JS a little more. If you skipped/skimmed them (especially Chapter 2), I recommend going back to spend some more time with that material.</p><p>In Chapter 2, we surveyed syntax, patterns, and behaviors at a high level. In this chapter, our attention shifts to some of the lower-level root characteristics of JS that underpin virtually every line of code we write.</p><p>Be aware: this chapter digs much deeper than you're likely used to thinking about a programming language. My goal is to help you appreciate the core of how JS works, what makes it tick. This chapter should begin to answer some of the \"Why?\" questions that may be cropping up as you explore JS. However, this material is still not an exhaustive exposition of the language; that's what the rest of the book series is for! Our goal here is still just to <em>get started</em>, and become more comfortable with, the <em>feel</em> of JS, how it ebbs and flows.</p><p>Don't run so quickly through this material that you get lost in the weeds. As I've said a dozen times already, <strong>take your time</strong>. Even still, you'll probably finish this chapter with remaining questions. That's OK, because there's a whole book series ahead of you to keep exploring!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 3: Digging to the Roots of JS", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you've read Chapters 1 and 2, and taken the time to digest and percolate, you're hopefully starting to ", "type": "text"}, {"text": "get", "type": "text", "marks": [{"type": "italic"}]}, {"text": " JS a little more. If you skipped/skimmed them (especially Chapter 2), I recommend going back to spend some more time with that material.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Chapter 2, we surveyed syntax, patterns, and behaviors at a high level. In this chapter, our attention shifts to some of the lower-level root characteristics of JS that underpin virtually every line of code we write.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Be aware: this chapter digs much deeper than you're likely used to thinking about a programming language. My goal is to help you appreciate the core of how JS works, what makes it tick. This chapter should begin to answer some of the \"Why?\" questions that may be cropping up as you explore JS. However, this material is still not an exhaustive exposition of the language; that's what the rest of the book series is for! Our goal here is still just to ", "type": "text"}, {"text": "get started", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and become more comfortable with, the ", "type": "text"}, {"text": "feel", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of JS, how it ebbs and flows.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Don't run so quickly through this material that you get lost in the weeds. As I've said a dozen times already, ", "type": "text"}, {"text": "take your time", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". Even still, you'll probably finish this chapter with remaining questions. That's OK, because there's a whole book series ahead of you to keep exploring!", "type": "text"}]}]}, "article_text": "Chapter 3: Digging to the Roots of JS\n\nIf you've read Chapters 1 and 2, and taken the time to digest and percolate, you're hopefully starting to get JS a little more. If you skipped/skimmed them (especially Chapter 2), I recommend going back to spend some more time with that material.\n\nIn Chapter 2, we surveyed syntax, patterns, and behaviors at a high level. In this chapter, our attention shifts to some of the lower-level root characteristics of JS that underpin virtually every line of code we write.\n\nBe aware: this chapter digs much deeper than you're likely used to thinking about a programming language. My goal is to help you appreciate the core of how JS works, what makes it tick. This chapter should begin to answer some of the \"Why?\" questions that may be cropping up as you explore JS. However, this material is still not an exhaustive exposition of the language; that's what the rest of the book series is for! Our goal here is still just to get started, and become more comfortable with, the feel of JS, how it ebbs and flows.\n\nDon't run so quickly through this material that you get lost in the weeds. As I've said a dozen times already, take your time. Even still, you'll probably finish this chapter with remaining questions. That's OK, because there's a whole book series ahead of you to keep exploring!"}, "id": 134, "children": [{"data": {"uuid": "e4675b3d-c3c6-429b-afd4-064b4aa400e8", "user": 1, "title": "Iteration", "author": "Kyle Simpson", "created_on": "2023-06-07 20:26:56.974387+00:00", "updated_on": "2023-06-07 20:27:20.143075+00:00", "article_html": "<h2>Iteration</h2><p>Since programs are essentially built to process data (and make decisions on that data), the patterns used to step through the data have a big impact on the program's readability.</p><p>The iterator pattern has been around for decades, and suggests a \"standardized\" approach to consuming data from a source one <em>chunk</em> at a time. The idea is that it's more common and helpful to iterate the data source\u2014to progressively handle the collection of data by processing the first part, then the next, and so on, rather than handling the entire set all at once.</p><p>Imagine a data structure that represents a relational database <code>SELECT</code> query, which typically organizes the results as rows. If this query had only one or a couple of rows, you could handle the entire result set at once, and assign each row to a local variable, and perform whatever operations on that data that were appropriate.</p><p>But if the query has 100 or 1,000 (or more!) rows, you'll need iterative processing to deal with this data (typically, a loop).</p><p>The iterator pattern defines a data structure called an \"iterator\" that has a reference to an underlying data source (like the query result rows), which exposes a method like <code>next()</code>. Calling <code>next()</code> returns the next piece of data (i.e., a \"record\" or \"row\" from a database query).</p><p>You don't always know how many pieces of data that you will need to iterate through, so the pattern typically indicates completion by some special value or exception once you iterate through the entire set and <em>go past the end</em>.</p><p>The importance of the iterator pattern is in adhering to a <em>standard</em> way of processing data iteratively, which creates cleaner and easier to understand code, as opposed to having every data structure/source define its own custom way of handling its data.</p><p>After many years of various JS community efforts around mutually agreed-upon iteration techniques, ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a <code>next()</code> method whose return is an object called an <em>iterator result</em>; the object has <code>value</code> and <code>done</code> properties, where <code>done</code> is a boolean that is <code>false</code> until the iteration over the underlying data source is complete.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Iteration", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since programs are essentially built to process data (and make decisions on that data), the patterns used to step through the data have a big impact on the program's readability.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The iterator pattern has been around for decades, and suggests a \"standardized\" approach to consuming data from a source one ", "type": "text"}, {"text": "chunk", "type": "text", "marks": [{"type": "italic"}]}, {"text": " at a time. The idea is that it's more common and helpful to iterate the data source\u2014to progressively handle the collection of data by processing the first part, then the next, and so on, rather than handling the entire set all at once.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Imagine a data structure that represents a relational database ", "type": "text"}, {"text": "SELECT", "type": "text", "marks": [{"type": "code"}]}, {"text": " query, which typically organizes the results as rows. If this query had only one or a couple of rows, you could handle the entire result set at once, and assign each row to a local variable, and perform whatever operations on that data that were appropriate.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But if the query has 100 or 1,000 (or more!) rows, you'll need iterative processing to deal with this data (typically, a loop).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The iterator pattern defines a data structure called an \"iterator\" that has a reference to an underlying data source (like the query result rows), which exposes a method like ", "type": "text"}, {"text": "next()", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Calling ", "type": "text"}, {"text": "next()", "type": "text", "marks": [{"type": "code"}]}, {"text": " returns the next piece of data (i.e., a \"record\" or \"row\" from a database query).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You don't always know how many pieces of data that you will need to iterate through, so the pattern typically indicates completion by some special value or exception once you iterate through the entire set and ", "type": "text"}, {"text": "go past the end", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The importance of the iterator pattern is in adhering to a ", "type": "text"}, {"text": "standard", "type": "text", "marks": [{"type": "italic"}]}, {"text": " way of processing data iteratively, which creates cleaner and easier to understand code, as opposed to having every data structure/source define its own custom way of handling its data.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "After many years of various JS community efforts around mutually agreed-upon iteration techniques, ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a ", "type": "text"}, {"text": "next()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method whose return is an object called an ", "type": "text"}, {"text": "iterator result", "type": "text", "marks": [{"type": "italic"}]}, {"text": "; the object has ", "type": "text"}, {"text": "value", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "done", "type": "text", "marks": [{"type": "code"}]}, {"text": " properties, where ", "type": "text"}, {"text": "done", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a boolean that is ", "type": "text"}, {"text": "false", "type": "text", "marks": [{"type": "code"}]}, {"text": " until the iteration over the underlying data source is complete.", "type": "text"}]}]}, "article_text": "Iteration\n\nSince programs are essentially built to process data (and make decisions on that data), the patterns used to step through the data have a big impact on the program's readability.\n\nThe iterator pattern has been around for decades, and suggests a \"standardized\" approach to consuming data from a source one chunk at a time. The idea is that it's more common and helpful to iterate the data source\u2014to progressively handle the collection of data by processing the first part, then the next, and so on, rather than handling the entire set all at once.\n\nImagine a data structure that represents a relational database SELECT query, which typically organizes the results as rows. If this query had only one or a couple of rows, you could handle the entire result set at once, and assign each row to a local variable, and perform whatever operations on that data that were appropriate.\n\nBut if the query has 100 or 1,000 (or more!) rows, you'll need iterative processing to deal with this data (typically, a loop).\n\nThe iterator pattern defines a data structure called an \"iterator\" that has a reference to an underlying data source (like the query result rows), which exposes a method like next(). Calling next() returns the next piece of data (i.e., a \"record\" or \"row\" from a database query).\n\nYou don't always know how many pieces of data that you will need to iterate through, so the pattern typically indicates completion by some special value or exception once you iterate through the entire set and go past the end.\n\nThe importance of the iterator pattern is in adhering to a standard way of processing data iteratively, which creates cleaner and easier to understand code, as opposed to having every data structure/source define its own custom way of handling its data.\n\nAfter many years of various JS community efforts around mutually agreed-upon iteration techniques, ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a next() method whose return is an object called an iterator result; the object has value and done properties, where done is a boolean that is false until the iteration over the underlying data source is complete."}, "id": 135, "children": [{"data": {"uuid": "efb07b3d-babe-4c3e-8056-9f00112a872f", "user": 1, "title": "Consuming Iterators", "author": "Kyle Simpson", "created_on": "2023-06-07 20:27:35.658366+00:00", "updated_on": "2023-06-07 20:28:17.694268+00:00", "article_html": "<h3>Consuming Iterators</h3><p>With the ES6 iteration protocol in place, it's workable to consume a data source one value at a time, checking after each <code>next()</code> call for <code>done</code> to be <code>true</code> to stop the iteration. But this approach is rather manual, so ES6 also included several mechanisms (syntax and APIs) for standardized consumption of these iterators.</p><p>One such mechanism is the <code>for..of</code> loop:</p><pre><code>// given an iterator of some data source:\nvar it = /* .. */;\n\n// loop over its results one at a time\nfor (let val of it) {\n    console.log(`Iterator value: ${ val }`);\n}\n// Iterator value: ..\n// Iterator value: ..\n// ..</code></pre><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>We'll omit the manual loop equivalent here, but it's definitely less readable than the <code>for..of</code> loop!</p></td></tr></tbody></table><p>Another mechanism that's often used for consuming iterators is the <code>...</code> operator. This operator actually has two symmetrical forms: <em>spread</em> and <em>rest</em> (or <em>gather</em>, as I prefer). The <em>spread</em> form is an iterator-consumer.</p><p>To <em>spread</em> an iterator, you have to have <em>something</em> to spread it into. There are two possibilities in JS: an array or an argument list for a function call.</p><p>An array spread:</p><pre><code>// spread an iterator into an array,\n// with each iterated value occupying\n// an array element position.\nvar vals = [ ...it ];</code></pre><p>A function call spread:</p><pre><code>// spread an iterator into a function,\n// call with each iterated value\n// occupying an argument position.\ndoSomethingUseful( ...it );</code></pre><p>In both cases, the iterator-spread form of <code>...</code> follows the iterator-consumption protocol (the same as the <code>for..of</code> loop) to retrieve all available values from an iterator and place (aka, spread) them into the receiving context (array, argument list).</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Consuming Iterators", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "With the ES6 iteration protocol in place, it's workable to consume a data source one value at a time, checking after each ", "type": "text"}, {"text": "next()", "type": "text", "marks": [{"type": "code"}]}, {"text": " call for ", "type": "text"}, {"text": "done", "type": "text", "marks": [{"type": "code"}]}, {"text": " to be ", "type": "text"}, {"text": "true", "type": "text", "marks": [{"type": "code"}]}, {"text": " to stop the iteration. But this approach is rather manual, so ES6 also included several mechanisms (syntax and APIs) for standardized consumption of these iterators.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One such mechanism is the ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// given an iterator of some data source:\nvar it = /* .. */;\n\n// loop over its results one at a time\nfor (let val of it) {\n    console.log(`Iterator value: ${ val }`);\n}\n// Iterator value: ..\n// Iterator value: ..\n// ..", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "We'll omit the manual loop equivalent here, but it's definitely less readable than the ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Another mechanism that's often used for consuming iterators is the ", "type": "text"}, {"text": "...", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator. This operator actually has two symmetrical forms: ", "type": "text"}, {"text": "spread", "type": "text", "marks": [{"type": "italic"}]}, {"text": " and ", "type": "text"}, {"text": "rest", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (or ", "type": "text"}, {"text": "gather", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", as I prefer). The ", "type": "text"}, {"text": "spread", "type": "text", "marks": [{"type": "italic"}]}, {"text": " form is an iterator-consumer.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To ", "type": "text"}, {"text": "spread", "type": "text", "marks": [{"type": "italic"}]}, {"text": " an iterator, you have to have ", "type": "text"}, {"text": "something", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to spread it into. There are two possibilities in JS: an array or an argument list for a function call.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "An array spread:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// spread an iterator into an array,\n// with each iterated value occupying\n// an array element position.\nvar vals = [ ...it ];", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A function call spread:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// spread an iterator into a function,\n// call with each iterated value\n// occupying an argument position.\ndoSomethingUseful( ...it );", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In both cases, the iterator-spread form of ", "type": "text"}, {"text": "...", "type": "text", "marks": [{"type": "code"}]}, {"text": " follows the iterator-consumption protocol (the same as the ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop) to retrieve all available values from an iterator and place (aka, spread) them into the receiving context (array, argument list).", "type": "text"}]}]}, "article_text": "Consuming Iterators\n\nWith the ES6 iteration protocol in place, it's workable to consume a data source one value at a time, checking after each next() call for done to be true to stop the iteration. But this approach is rather manual, so ES6 also included several mechanisms (syntax and APIs) for standardized consumption of these iterators.\n\nOne such mechanism is the for..of loop:\n\n// given an iterator of some data source:\nvar it = /* .. */;\n\n// loop over its results one at a time\nfor (let val of it) {\n    console.log(`Iterator value: ${ val }`);\n}\n// Iterator value: ..\n// Iterator value: ..\n// ..\n\nNOTE:\n\nWe'll omit the manual loop equivalent here, but it's definitely less readable than the for..of loop!\n\nAnother mechanism that's often used for consuming iterators is the ... operator. This operator actually has two symmetrical forms: spread and rest (or gather, as I prefer). The spread form is an iterator-consumer.\n\nTo spread an iterator, you have to have something to spread it into. There are two possibilities in JS: an array or an argument list for a function call.\n\nAn array spread:\n\n// spread an iterator into an array,\n// with each iterated value occupying\n// an array element position.\nvar vals = [ ...it ];\n\nA function call spread:\n\n// spread an iterator into a function,\n// call with each iterated value\n// occupying an argument position.\ndoSomethingUseful( ...it );\n\nIn both cases, the iterator-spread form of ... follows the iterator-consumption protocol (the same as the for..of loop) to retrieve all available values from an iterator and place (aka, spread) them into the receiving context (array, argument list)."}, "id": 136}, {"data": {"uuid": "053673cf-9122-4921-9c4f-c2a0e37e09d5", "user": 1, "title": "Iterables", "author": "Kyle Simpson", "created_on": "2023-06-07 20:28:41.839902+00:00", "updated_on": "2023-06-07 20:29:10.793481+00:00", "article_html": "<h3>Iterables</h3><p>The iterator-consumption protocol is technically defined for consuming <em>iterables</em>; an iterable is a value that can be iterated over.</p><p>The protocol automatically creates an iterator instance from an iterable, and consumes <em>just that iterator instance</em> to its completion. This means a single iterable could be consumed more than once; each time, a new iterator instance would be created and used.</p><p>So where do we find iterables?</p><p>ES6 defined the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.</p><p>Consider:</p><pre><code>// an array is an iterable\nvar arr = [ 10, 20, 30 ];\n\nfor (let val of arr) {\n    console.log(`Array value: ${ val }`);\n}\n// Array value: 10\n// Array value: 20\n// Array value: 30</code></pre><p>Since arrays are iterables, we can shallow-copy an array using iterator consumption via the <code>...</code> spread operator:</p><pre><code>var arrCopy = [ ...arr ];</code></pre><p>We can also iterate the characters in a string one at a time:</p><pre><code>var greeting = \"Hello world!\";\nvar chars = [ ...greeting ];\n\nchars;\n// [ \"H\", \"e\", \"l\", \"l\", \"o\", \" \",\n//   \"w\", \"o\", \"r\", \"l\", \"d\", \"!\" ]</code></pre><p>A <code>Map</code> data structure uses objects as keys, associating a value (of any type) with that object. Maps have a different default iteration than seen here, in that the iteration is not just over the map's values but instead its <em>entries</em>. An <em>entry</em> is a tuple (2-element array) including both a key and a value.</p><p>Consider:</p><pre><code>// given two DOM elements, `btn1` and `btn2`\n\nvar buttonNames = new Map();\nbuttonNames.set(btn1,\"Button 1\");\nbuttonNames.set(btn2,\"Button 2\");\n\nfor (let [btn,btnName] of buttonNames) {\n    btn.addEventListener(\"click\",function onClick(){\n        console.log(`Clicked ${ btnName }`);\n    });\n}</code></pre><p>In the <code>for..of</code> loop over the default map iteration, we use the <code>[btn,btnName]</code> syntax (called \"array destructuring\") to break down each consumed tuple into the respective key/value pairs (<code>btn1</code> / <code>\"Button 1\"</code> and <code>btn2</code> / <code>\"Button 2\"</code>).</p><p>Each of the built-in iterables in JS expose a default iteration, one which likely matches your intuition. But you can also choose a more specific iteration if necessary. For example, if we want to consume only the values of the above <code>buttonNames</code> map, we can call <code>values()</code> to get a values-only iterator:</p><pre><code>for (let btnName of buttonNames.values()) {\n    console.log(btnName);\n}\n// Button 1\n// Button 2</code></pre><p>Or if we want the index <em>and</em> value in an array iteration, we can make an entries iterator with the <code>entries()</code> method:</p><pre><code>var arr = [ 10, 20, 30 ];\n\nfor (let [idx,val] of arr.entries()) {\n    console.log(`[${ idx }]: ${ val }`);\n}\n// [0]: 10\n// [1]: 20\n// [2]: 30</code></pre><p>For the most part, all built-in iterables in JS have three iterator forms available: keys-only (<code>keys()</code>), values-only (<code>values()</code>), and entries (<code>entries()</code>).</p><p>Beyond just using built-in iterables, you can also ensure your own data structures adhere to the iteration protocol; doing so means you opt into the ability to consume your data with <code>for..of</code> loops and the <code>...</code> operator. \"Standardizing\" on this protocol means code that is overall more readily recognizable and readable.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>You may have noticed a nuanced shift that occurred in this discussion. We started by talking about consuming <strong>iterators</strong>, but then switched to talking about iterating over <strong>iterables</strong>. The iteration-consumption protocol expects an <em>iterable</em>, but the reason we can provide a direct <em>iterator</em> is that an iterator is just an iterable of itself! When creating an iterator instance from an existing iterator, the iterator itself is returned.</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Iterables", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The iterator-consumption protocol is technically defined for consuming ", "type": "text"}, {"text": "iterables", "type": "text", "marks": [{"type": "italic"}]}, {"text": "; an iterable is a value that can be iterated over.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The protocol automatically creates an iterator instance from an iterable, and consumes ", "type": "text"}, {"text": "just that iterator instance", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to its completion. This means a single iterable could be consumed more than once; each time, a new iterator instance would be created and used.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So where do we find iterables?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "ES6 defined the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// an array is an iterable\nvar arr = [ 10, 20, 30 ];\n\nfor (let val of arr) {\n    console.log(`Array value: ${ val }`);\n}\n// Array value: 10\n// Array value: 20\n// Array value: 30", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since arrays are iterables, we can shallow-copy an array using iterator consumption via the ", "type": "text"}, {"text": "...", "type": "text", "marks": [{"type": "code"}]}, {"text": " spread operator:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var arrCopy = [ ...arr ];", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We can also iterate the characters in a string one at a time:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var greeting = \"Hello world!\";\nvar chars = [ ...greeting ];\n\nchars;\n// [ \"H\", \"e\", \"l\", \"l\", \"o\", \" \",\n//   \"w\", \"o\", \"r\", \"l\", \"d\", \"!\" ]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A ", "type": "text"}, {"text": "Map", "type": "text", "marks": [{"type": "code"}]}, {"text": " data structure uses objects as keys, associating a value (of any type) with that object. Maps have a different default iteration than seen here, in that the iteration is not just over the map's values but instead its ", "type": "text"}, {"text": "entries", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". An ", "type": "text"}, {"text": "entry", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is a tuple (2-element array) including both a key and a value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// given two DOM elements, `btn1` and `btn2`\n\nvar buttonNames = new Map();\nbuttonNames.set(btn1,\"Button 1\");\nbuttonNames.set(btn2,\"Button 2\");\n\nfor (let [btn,btnName] of buttonNames) {\n    btn.addEventListener(\"click\",function onClick(){\n        console.log(`Clicked ${ btnName }`);\n    });\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " loop over the default map iteration, we use the ", "type": "text"}, {"text": "[btn,btnName]", "type": "text", "marks": [{"type": "code"}]}, {"text": " syntax (called \"array destructuring\") to break down each consumed tuple into the respective key/value pairs (", "type": "text"}, {"text": "btn1", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "\"Button 1\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "btn2", "type": "text", "marks": [{"type": "code"}]}, {"text": " / ", "type": "text"}, {"text": "\"Button 2\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each of the built-in iterables in JS expose a default iteration, one which likely matches your intuition. But you can also choose a more specific iteration if necessary. For example, if we want to consume only the values of the above ", "type": "text"}, {"text": "buttonNames", "type": "text", "marks": [{"type": "code"}]}, {"text": " map, we can call ", "type": "text"}, {"text": "values()", "type": "text", "marks": [{"type": "code"}]}, {"text": " to get a values-only iterator:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (let btnName of buttonNames.values()) {\n    console.log(btnName);\n}\n// Button 1\n// Button 2", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Or if we want the index ", "type": "text"}, {"text": "and", "type": "text", "marks": [{"type": "italic"}]}, {"text": " value in an array iteration, we can make an entries iterator with the ", "type": "text"}, {"text": "entries()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var arr = [ 10, 20, 30 ];\n\nfor (let [idx,val] of arr.entries()) {\n    console.log(`[${ idx }]: ${ val }`);\n}\n// [0]: 10\n// [1]: 20\n// [2]: 30", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For the most part, all built-in iterables in JS have three iterator forms available: keys-only (", "type": "text"}, {"text": "keys()", "type": "text", "marks": [{"type": "code"}]}, {"text": "), values-only (", "type": "text"}, {"text": "values()", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and entries (", "type": "text"}, {"text": "entries()", "type": "text", "marks": [{"type": "code"}]}, {"text": ").", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Beyond just using built-in iterables, you can also ensure your own data structures adhere to the iteration protocol; doing so means you opt into the ability to consume your data with ", "type": "text"}, {"text": "for..of", "type": "text", "marks": [{"type": "code"}]}, {"text": " loops and the ", "type": "text"}, {"text": "...", "type": "text", "marks": [{"type": "code"}]}, {"text": " operator. \"Standardizing\" on this protocol means code that is overall more readily recognizable and readable.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "You may have noticed a nuanced shift that occurred in this discussion. We started by talking about consuming ", "type": "text"}, {"text": "iterators", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", but then switched to talking about iterating over ", "type": "text"}, {"text": "iterables", "type": "text", "marks": [{"type": "bold"}]}, {"text": ". The iteration-consumption protocol expects an ", "type": "text"}, {"text": "iterable", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", but the reason we can provide a direct ", "type": "text"}, {"text": "iterator", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is that an iterator is just an iterable of itself! When creating an iterator instance from an existing iterator, the iterator itself is returned.", "type": "text"}]}]}]}]}]}, "article_text": "Iterables\n\nThe iterator-consumption protocol is technically defined for consuming iterables; an iterable is a value that can be iterated over.\n\nThe protocol automatically creates an iterator instance from an iterable, and consumes just that iterator instance to its completion. This means a single iterable could be consumed more than once; each time, a new iterator instance would be created and used.\n\nSo where do we find iterables?\n\nES6 defined the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.\n\nConsider:\n\n// an array is an iterable\nvar arr = [ 10, 20, 30 ];\n\nfor (let val of arr) {\n    console.log(`Array value: ${ val }`);\n}\n// Array value: 10\n// Array value: 20\n// Array value: 30\n\nSince arrays are iterables, we can shallow-copy an array using iterator consumption via the ... spread operator:\n\nvar arrCopy = [ ...arr ];\n\nWe can also iterate the characters in a string one at a time:\n\nvar greeting = \"Hello world!\";\nvar chars = [ ...greeting ];\n\nchars;\n// [ \"H\", \"e\", \"l\", \"l\", \"o\", \" \",\n//   \"w\", \"o\", \"r\", \"l\", \"d\", \"!\" ]\n\nA Map data structure uses objects as keys, associating a value (of any type) with that object. Maps have a different default iteration than seen here, in that the iteration is not just over the map's values but instead its entries. An entry is a tuple (2-element array) including both a key and a value.\n\nConsider:\n\n// given two DOM elements, `btn1` and `btn2`\n\nvar buttonNames = new Map();\nbuttonNames.set(btn1,\"Button 1\");\nbuttonNames.set(btn2,\"Button 2\");\n\nfor (let [btn,btnName] of buttonNames) {\n    btn.addEventListener(\"click\",function onClick(){\n        console.log(`Clicked ${ btnName }`);\n    });\n}\n\nIn the for..of loop over the default map iteration, we use the [btn,btnName] syntax (called \"array destructuring\") to break down each consumed tuple into the respective key/value pairs (btn1 / \"Button 1\" and btn2 / \"Button 2\").\n\nEach of the built-in iterables in JS expose a default iteration, one which likely matches your intuition. But you can also choose a more specific iteration if necessary. For example, if we want to consume only the values of the above buttonNames map, we can call values() to get a values-only iterator:\n\nfor (let btnName of buttonNames.values()) {\n    console.log(btnName);\n}\n// Button 1\n// Button 2\n\nOr if we want the index and value in an array iteration, we can make an entries iterator with the entries() method:\n\nvar arr = [ 10, 20, 30 ];\n\nfor (let [idx,val] of arr.entries()) {\n    console.log(`[${ idx }]: ${ val }`);\n}\n// [0]: 10\n// [1]: 20\n// [2]: 30\n\nFor the most part, all built-in iterables in JS have three iterator forms available: keys-only (keys()), values-only (values()), and entries (entries()).\n\nBeyond just using built-in iterables, you can also ensure your own data structures adhere to the iteration protocol; doing so means you opt into the ability to consume your data with for..of loops and the ... operator. \"Standardizing\" on this protocol means code that is overall more readily recognizable and readable.\n\nNOTE:\n\nYou may have noticed a nuanced shift that occurred in this discussion. We started by talking about consuming iterators, but then switched to talking about iterating over iterables. The iteration-consumption protocol expects an iterable, but the reason we can provide a direct iterator is that an iterator is just an iterable of itself! When creating an iterator instance from an existing iterator, the iterator itself is returned."}, "id": 137}]}, {"data": {"uuid": "90d750f0-e500-4261-8b76-0cb766ed8d3e", "user": 1, "title": "Closure", "author": "Kyle Simpson", "created_on": "2023-06-07 20:30:03.160460+00:00", "updated_on": "2023-06-07 20:30:32.601662+00:00", "article_html": "<h2>Closure</h2><p>Perhaps without realizing it, almost every JS developer has made use of closure. In fact, closure is one of the most pervasive programming functionalities across a majority of languages. It might even be as important to understand as variables or loops; that's how fundamental it is.</p><p>Yet it feels kind of hidden, almost magical. And it's often talked about in either very abstract or very informal terms, which does little to help us nail down exactly what it is.</p><p>We need to be able to recognize where closure is used in programs, as the presence or lack of closure is sometimes the cause of bugs (or even the cause of performance issues).</p><p>So let's define closure in a pragmatic and concrete way:</p><blockquote><p>Closure is when a function remembers and continues to access variables from outside its scope, even when the function is executed in a different scope.</p></blockquote><p>We see two definitional characteristics here. First, closure is part of the nature of a function. Objects don't get closures, functions do. Second, to observe a closure, you must execute a function in a different scope than where that function was originally defined.</p><p>Consider:</p><pre><code>function greeting(msg) {\n    return function who(name) {\n        console.log(`${ msg }, ${ name }!`);\n    };\n}\n\nvar hello = greeting(\"Hello\");\nvar howdy = greeting(\"Howdy\");\n\nhello(\"Kyle\");\n// Hello, Kyle!\n\nhello(\"Sarah\");\n// Hello, Sarah!\n\nhowdy(\"Grant\");\n// Howdy, Grant!</code></pre><p>First, the <code>greeting(..)</code> outer function is executed, creating an instance of the inner function <code>who(..)</code>; that function closes over the variable <code>msg</code>, which is the parameter from the outer scope of <code>greeting(..)</code>. When that inner function is returned, its reference is assigned to the <code>hello</code> variable in the outer scope. Then we call <code>greeting(..)</code> a second time, creating a new inner function instance, with a new closure over a new <code>msg</code>, and return that reference to be assigned to <code>howdy</code>.</p><p>When the <code>greeting(..)</code> function finishes running, normally we would expect all of its variables to be garbage collected (removed from memory). We'd expect each <code>msg</code> to go away, but they don't. The reason is closure. Since the inner function instances are still alive (assigned to <code>hello</code> and <code>howdy</code>, respectively), their closures are still preserving the <code>msg</code> variables.</p><p>These closures are not a snapshot of the <code>msg</code> variable's value; they are a direct link and preservation of the variable itself. That means closure can actually observe (or make!) updates to these variables over time.</p><pre><code>function counter(step = 1) {\n    var count = 0;\n    return function increaseCount(){\n        count = count + step;\n        return count;\n    };\n}\n\nvar incBy1 = counter(1);\nvar incBy3 = counter(3);\n\nincBy1();       // 1\nincBy1();       // 2\n\nincBy3();       // 3\nincBy3();       // 6\nincBy3();       // 9</code></pre><p>Each instance of the inner <code>increaseCount()</code> function is closed over both the <code>count</code> and <code>step</code> variables from its outer <code>counter(..)</code> function's scope. <code>step</code> remains the same over time, but <code>count</code> is updated on each invocation of that inner function. Since closure is over the variables and not just snapshots of the values, these updates are preserved.</p><p>Closure is most common when working with asynchronous code, such as with callbacks. Consider:</p><pre><code>function getSomeData(url) {\n    ajax(url,function onResponse(resp){\n        console.log(\n            `Response (from ${ url }): ${ resp }`\n        );\n    });\n}\n\ngetSomeData(\"https://some.url/wherever\");\n// Response (from https://some.url/wherever): ...</code></pre><p>The inner function <code>onResponse(..)</code> is closed over <code>url</code>, and thus preserves and remembers it until the Ajax call returns and executes <code>onResponse(..)</code>. Even though <code>getSomeData(..)</code> finishes right away, the <code>url</code> parameter variable is kept alive in the closure for as long as needed.</p><p>It's not necessary that the outer scope be a function\u2014it usually is, but not always\u2014just that there be at least one variable in an outer scope accessed from an inner function:</p><pre><code>for (let [idx,btn] of buttons.entries()) {\n    btn.addEventListener(\"click\",function onClick(){\n       console.log(`Clicked on button (${ idx })!`);\n    });\n}</code></pre><p>Because this loop is using <code>let</code> declarations, each iteration gets new block-scoped (aka, local) <code>idx</code> and <code>btn</code> variables; the loop also creates a new inner <code>onClick(..)</code> function each time. That inner function closes over <code>idx</code>, preserving it for as long as the click handler is set on the <code>btn</code>. So when each button is clicked, its handler can print its associated index value, because the handler remembers its respective <code>idx</code> variable.</p><p>Remember: this closure is not over the value (like <code>1</code> or <code>3</code>), but over the variable <code>idx</code> itself.</p><p>Closure is one of the most prevalent and important programming patterns in any language. But that's especially true of JS; it's hard to imagine doing anything useful without leveraging closure in one way or another.</p><p>If you're still feeling unclear or shaky about closure, the majority of Book 2, <em>Scope &amp; Closures</em> is focused on the topic.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Perhaps without realizing it, almost every JS developer has made use of closure. In fact, closure is one of the most pervasive programming functionalities across a majority of languages. It might even be as important to understand as variables or loops; that's how fundamental it is.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Yet it feels kind of hidden, almost magical. And it's often talked about in either very abstract or very informal terms, which does little to help us nail down exactly what it is.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We need to be able to recognize where closure is used in programs, as the presence or lack of closure is sometimes the cause of bugs (or even the cause of performance issues).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So let's define closure in a pragmatic and concrete way:", "type": "text"}]}, {"type": "blockquote", "content": [{"type": "paragraph", "content": [{"text": "Closure is when a function remembers and continues to access variables from outside its scope, even when the function is executed in a different scope.", "type": "text"}]}]}, {"type": "paragraph", "content": [{"text": "We see two definitional characteristics here. First, closure is part of the nature of a function. Objects don't get closures, functions do. Second, to observe a closure, you must execute a function in a different scope than where that function was originally defined.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function greeting(msg) {\n    return function who(name) {\n        console.log(`${ msg }, ${ name }!`);\n    };\n}\n\nvar hello = greeting(\"Hello\");\nvar howdy = greeting(\"Howdy\");\n\nhello(\"Kyle\");\n// Hello, Kyle!\n\nhello(\"Sarah\");\n// Hello, Sarah!\n\nhowdy(\"Grant\");\n// Howdy, Grant!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First, the ", "type": "text"}, {"text": "greeting(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " outer function is executed, creating an instance of the inner function ", "type": "text"}, {"text": "who(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": "; that function closes over the variable ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which is the parameter from the outer scope of ", "type": "text"}, {"text": "greeting(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". When that inner function is returned, its reference is assigned to the ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable in the outer scope. Then we call ", "type": "text"}, {"text": "greeting(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " a second time, creating a new inner function instance, with a new closure over a new ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and return that reference to be assigned to ", "type": "text"}, {"text": "howdy", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When the ", "type": "text"}, {"text": "greeting(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function finishes running, normally we would expect all of its variables to be garbage collected (removed from memory). We'd expect each ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": " to go away, but they don't. The reason is closure. Since the inner function instances are still alive (assigned to ", "type": "text"}, {"text": "hello", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "howdy", "type": "text", "marks": [{"type": "code"}]}, {"text": ", respectively), their closures are still preserving the ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "These closures are not a snapshot of the ", "type": "text"}, {"text": "msg", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable's value; they are a direct link and preservation of the variable itself. That means closure can actually observe (or make!) updates to these variables over time.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function counter(step = 1) {\n    var count = 0;\n    return function increaseCount(){\n        count = count + step;\n        return count;\n    };\n}\n\nvar incBy1 = counter(1);\nvar incBy3 = counter(3);\n\nincBy1();       // 1\nincBy1();       // 2\n\nincBy3();       // 3\nincBy3();       // 6\nincBy3();       // 9", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Each instance of the inner ", "type": "text"}, {"text": "increaseCount()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function is closed over both the ", "type": "text"}, {"text": "count", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "step", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables from its outer ", "type": "text"}, {"text": "counter(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function's scope. ", "type": "text"}, {"text": "step", "type": "text", "marks": [{"type": "code"}]}, {"text": " remains the same over time, but ", "type": "text"}, {"text": "count", "type": "text", "marks": [{"type": "code"}]}, {"text": " is updated on each invocation of that inner function. Since closure is over the variables and not just snapshots of the values, these updates are preserved.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is most common when working with asynchronous code, such as with callbacks. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function getSomeData(url) {\n    ajax(url,function onResponse(resp){\n        console.log(\n            `Response (from ${ url }): ${ resp }`\n        );\n    });\n}\n\ngetSomeData(\"https://some.url/wherever\");\n// Response (from https://some.url/wherever): ...", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The inner function ", "type": "text"}, {"text": "onResponse(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " is closed over ", "type": "text"}, {"text": "url", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and thus preserves and remembers it until the Ajax call returns and executes ", "type": "text"}, {"text": "onResponse(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Even though ", "type": "text"}, {"text": "getSomeData(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " finishes right away, the ", "type": "text"}, {"text": "url", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter variable is kept alive in the closure for as long as needed.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "It's not necessary that the outer scope be a function\u2014it usually is, but not always\u2014just that there be at least one variable in an outer scope accessed from an inner function:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "for (let [idx,btn] of buttons.entries()) {\n    btn.addEventListener(\"click\",function onClick(){\n       console.log(`Clicked on button (${ idx })!`);\n    });\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Because this loop is using ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations, each iteration gets new block-scoped (aka, local) ", "type": "text"}, {"text": "idx", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "btn", "type": "text", "marks": [{"type": "code"}]}, {"text": " variables; the loop also creates a new inner ", "type": "text"}, {"text": "onClick(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function each time. That inner function closes over ", "type": "text"}, {"text": "idx", "type": "text", "marks": [{"type": "code"}]}, {"text": ", preserving it for as long as the click handler is set on the ", "type": "text"}, {"text": "btn", "type": "text", "marks": [{"type": "code"}]}, {"text": ". So when each button is clicked, its handler can print its associated index value, because the handler remembers its respective ", "type": "text"}, {"text": "idx", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember: this closure is not over the value (like ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": " or ", "type": "text"}, {"text": "3", "type": "text", "marks": [{"type": "code"}]}, {"text": "), but over the variable ", "type": "text"}, {"text": "idx", "type": "text", "marks": [{"type": "code"}]}, {"text": " itself.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is one of the most prevalent and important programming patterns in any language. But that's especially true of JS; it's hard to imagine doing anything useful without leveraging closure in one way or another.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you're still feeling unclear or shaky about closure, the majority of Book 2, ", "type": "text"}, {"text": "Scope & Closures", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is focused on the topic.", "type": "text"}]}]}, "article_text": "Closure\n\nPerhaps without realizing it, almost every JS developer has made use of closure. In fact, closure is one of the most pervasive programming functionalities across a majority of languages. It might even be as important to understand as variables or loops; that's how fundamental it is.\n\nYet it feels kind of hidden, almost magical. And it's often talked about in either very abstract or very informal terms, which does little to help us nail down exactly what it is.\n\nWe need to be able to recognize where closure is used in programs, as the presence or lack of closure is sometimes the cause of bugs (or even the cause of performance issues).\n\nSo let's define closure in a pragmatic and concrete way:\n\nClosure is when a function remembers and continues to access variables from outside its scope, even when the function is executed in a different scope.\n\nWe see two definitional characteristics here. First, closure is part of the nature of a function. Objects don't get closures, functions do. Second, to observe a closure, you must execute a function in a different scope than where that function was originally defined.\n\nConsider:\n\nfunction greeting(msg) {\n    return function who(name) {\n        console.log(`${ msg }, ${ name }!`);\n    };\n}\n\nvar hello = greeting(\"Hello\");\nvar howdy = greeting(\"Howdy\");\n\nhello(\"Kyle\");\n// Hello, Kyle!\n\nhello(\"Sarah\");\n// Hello, Sarah!\n\nhowdy(\"Grant\");\n// Howdy, Grant!\n\nFirst, the greeting(..) outer function is executed, creating an instance of the inner function who(..); that function closes over the variable msg, which is the parameter from the outer scope of greeting(..). When that inner function is returned, its reference is assigned to the hello variable in the outer scope. Then we call greeting(..) a second time, creating a new inner function instance, with a new closure over a new msg, and return that reference to be assigned to howdy.\n\nWhen the greeting(..) function finishes running, normally we would expect all of its variables to be garbage collected (removed from memory). We'd expect each msg to go away, but they don't. The reason is closure. Since the inner function instances are still alive (assigned to hello and howdy, respectively), their closures are still preserving the msg variables.\n\nThese closures are not a snapshot of the msg variable's value; they are a direct link and preservation of the variable itself. That means closure can actually observe (or make!) updates to these variables over time.\n\nfunction counter(step = 1) {\n    var count = 0;\n    return function increaseCount(){\n        count = count + step;\n        return count;\n    };\n}\n\nvar incBy1 = counter(1);\nvar incBy3 = counter(3);\n\nincBy1();       // 1\nincBy1();       // 2\n\nincBy3();       // 3\nincBy3();       // 6\nincBy3();       // 9\n\nEach instance of the inner increaseCount() function is closed over both the count and step variables from its outer counter(..) function's scope. step remains the same over time, but count is updated on each invocation of that inner function. Since closure is over the variables and not just snapshots of the values, these updates are preserved.\n\nClosure is most common when working with asynchronous code, such as with callbacks. Consider:\n\nfunction getSomeData(url) {\n    ajax(url,function onResponse(resp){\n        console.log(\n            `Response (from ${ url }): ${ resp }`\n        );\n    });\n}\n\ngetSomeData(\"https://some.url/wherever\");\n// Response (from https://some.url/wherever): ...\n\nThe inner function onResponse(..) is closed over url, and thus preserves and remembers it until the Ajax call returns and executes onResponse(..). Even though getSomeData(..) finishes right away, the url parameter variable is kept alive in the closure for as long as needed.\n\nIt's not necessary that the outer scope be a function\u2014it usually is, but not always\u2014just that there be at least one variable in an outer scope accessed from an inner function:\n\nfor (let [idx,btn] of buttons.entries()) {\n    btn.addEventListener(\"click\",function onClick(){\n       console.log(`Clicked on button (${ idx })!`);\n    });\n}\n\nBecause this loop is using let declarations, each iteration gets new block-scoped (aka, local) idx and btn variables; the loop also creates a new inner onClick(..) function each time. That inner function closes over idx, preserving it for as long as the click handler is set on the btn. So when each button is clicked, its handler can print its associated index value, because the handler remembers its respective idx variable.\n\nRemember: this closure is not over the value (like 1 or 3), but over the variable idx itself.\n\nClosure is one of the most prevalent and important programming patterns in any language. But that's especially true of JS; it's hard to imagine doing anything useful without leveraging closure in one way or another.\n\nIf you're still feeling unclear or shaky about closure, the majority of Book 2, Scope & Closures is focused on the topic."}, "id": 138}, {"data": {"uuid": "83ff8259-331d-4388-9eb2-10d01be5d938", "user": 1, "title": "this Keyword", "author": "", "created_on": "2023-06-07 20:30:55.963192+00:00", "updated_on": "2023-06-07 20:31:29.064680+00:00", "article_html": "<h2><code>this</code> Keyword</h2><p>One of JS's most powerful mechanisms is also one of its most misunderstood: the <code>this</code> keyword. One common misconception is that a function's <code>this</code> refers to the function itself. Because of how <code>this</code> works in other languages, another misconception is that <code>this</code> points the instance that a method belongs to. Both are incorrect.</p><p>As discussed previously, when a function is defined, it is <em>attached</em> to its enclosing scope via closure. Scope is the set of rules that controls how references to variables are resolved.</p><p>But functions also have another characteristic besides their scope that influences what they can access. This characteristic is best described as an <em>execution context</em>, and it's exposed to the function via its <code>this</code> keyword.</p><p>Scope is static and contains a fixed set of variables available at the moment and location you define a function, but a function's execution <em>context</em> is dynamic, entirely dependent on <strong>how it is called</strong> (regardless of where it is defined or even called from).</p><p><code>this</code> is not a fixed characteristic of a function based on the function's definition, but rather a dynamic characteristic that's determined each time the function is called.</p><p>One way to think about the <em>execution context</em> is that it's a tangible object whose properties are made available to a function while it executes. Compare that to scope, which can also be thought of as an <em>object</em>; except, the <em>scope object</em> is hidden inside the JS engine, it's always the same for that function, and its <em>properties</em> take the form of identifier variables available inside the function.</p><pre><code>function classroom(teacher) {\n    return function study() {\n        console.log(\n            `${ teacher } says to study ${ this.topic }`\n        );\n    };\n}\nvar assignment = classroom(\"Kyle\");</code></pre><p>The outer <code>classroom(..)</code> function makes no reference to a <code>this</code> keyword, so it's just like any other function we've seen so far. But the inner <code>study()</code> function does reference <code>this</code>, which makes it a <code>this</code>-aware function. In other words, it's a function that is dependent on its <em>execution context</em>.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p><code>study()</code> is also closed over the <code>teacher</code> variable from its outer scope.</p></td></tr></tbody></table><p>The inner <code>study()</code> function returned by <code>classroom(\"Kyle\")</code> is assigned to a variable called <code>assignment</code>. So how can <code>assignment()</code> (aka <code>study()</code>) be called?</p><pre><code>assignment();\n// Kyle says to study undefined  -- Oops :(</code></pre><p>In this snippet, we call <code>assignment()</code> as a plain, normal function, without providing it any <em>execution context</em>.</p><p>Since this program is not in strict mode (see Chapter 1, \"Strictly Speaking\"), context-aware functions that are called <strong>without any context specified</strong> default the context to the global object (<code>window</code> in the browser). As there is no global variable named <code>topic</code> (and thus no such property on the global object), <code>this.topic</code> resolves to <code>undefined</code>.</p><p>Now consider:</p><pre><code>var homework = {\n    topic: \"JS\",\n    assignment: assignment\n};\n\nhomework.assignment();\n// Kyle says to study JS</code></pre><p>A copy of the <code>assignment</code> function reference is set as a property on the <code>homework</code> object, and then it's called as <code>homework.assignment()</code>. That means the <code>this</code> for that function call will be the <code>homework</code> object. Hence, <code>this.topic</code> resolves to <code>\"JS\"</code>.</p><p>Lastly:</p><pre><code>var otherHomework = {\n    topic: \"Math\"\n};\n\nassignment.call(otherHomework);\n// Kyle says to study Math</code></pre><p>A third way to invoke a function is with the <code>call(..)</code> method, which takes an object (<code>otherHomework</code> here) to use for setting the <code>this</code> reference for the function call. The property reference <code>this.topic</code> resolves to <code>\"Math\"</code>.</p><p>The same context-aware function invoked three different ways, gives different answers each time for what object <code>this</code> will reference.</p><p>The benefit of <code>this</code>-aware functions\u2014and their dynamic context\u2014is the ability to more flexibly re-use a single function with data from different objects. A function that closes over a scope can never reference a different scope or set of variables. But a function that has dynamic <code>this</code> context awareness can be quite helpful for certain tasks.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " Keyword", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One of JS's most powerful mechanisms is also one of its most misunderstood: the ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword. One common misconception is that a function's ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " refers to the function itself. Because of how ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " works in other languages, another misconception is that ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " points the instance that a method belongs to. Both are incorrect.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As discussed previously, when a function is defined, it is ", "type": "text"}, {"text": "attached", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to its enclosing scope via closure. Scope is the set of rules that controls how references to variables are resolved.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But functions also have another characteristic besides their scope that influences what they can access. This characteristic is best described as an ", "type": "text"}, {"text": "execution context", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", and it's exposed to the function via its ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Scope is static and contains a fixed set of variables available at the moment and location you define a function, but a function's execution ", "type": "text"}, {"text": "context", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is dynamic, entirely dependent on ", "type": "text"}, {"text": "how it is called", "type": "text", "marks": [{"type": "bold"}]}, {"text": " (regardless of where it is defined or even called from).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " is not a fixed characteristic of a function based on the function's definition, but rather a dynamic characteristic that's determined each time the function is called.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "One way to think about the ", "type": "text"}, {"text": "execution context", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is that it's a tangible object whose properties are made available to a function while it executes. Compare that to scope, which can also be thought of as an ", "type": "text"}, {"text": "object", "type": "text", "marks": [{"type": "italic"}]}, {"text": "; except, the ", "type": "text"}, {"text": "scope object", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is hidden inside the JS engine, it's always the same for that function, and its ", "type": "text"}, {"text": "properties", "type": "text", "marks": [{"type": "italic"}]}, {"text": " take the form of identifier variables available inside the function.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function classroom(teacher) {\n    return function study() {\n        console.log(\n            `${ teacher } says to study ${ this.topic }`\n        );\n    };\n}\nvar assignment = classroom(\"Kyle\");", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The outer ", "type": "text"}, {"text": "classroom(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function makes no reference to a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword, so it's just like any other function we've seen so far. But the inner ", "type": "text"}, {"text": "study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function does reference ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": ", which makes it a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": "-aware function. In other words, it's a function that is dependent on its ", "type": "text"}, {"text": "execution context", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " is also closed over the ", "type": "text"}, {"text": "teacher", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable from its outer scope.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "The inner ", "type": "text"}, {"text": "study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function returned by ", "type": "text"}, {"text": "classroom(\"Kyle\")", "type": "text", "marks": [{"type": "code"}]}, {"text": " is assigned to a variable called ", "type": "text"}, {"text": "assignment", "type": "text", "marks": [{"type": "code"}]}, {"text": ". So how can ", "type": "text"}, {"text": "assignment()", "type": "text", "marks": [{"type": "code"}]}, {"text": " (aka ", "type": "text"}, {"text": "study()", "type": "text", "marks": [{"type": "code"}]}, {"text": ") be called?", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "assignment();\n// Kyle says to study undefined  -- Oops :(", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this snippet, we call ", "type": "text"}, {"text": "assignment()", "type": "text", "marks": [{"type": "code"}]}, {"text": " as a plain, normal function, without providing it any ", "type": "text"}, {"text": "execution context", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since this program is not in strict mode (see Chapter 1, \"Strictly Speaking\"), context-aware functions that are called ", "type": "text"}, {"text": "without any context specified", "type": "text", "marks": [{"type": "bold"}]}, {"text": " default the context to the global object (", "type": "text"}, {"text": "window", "type": "text", "marks": [{"type": "code"}]}, {"text": " in the browser). As there is no global variable named ", "type": "text"}, {"text": "topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " (and thus no such property on the global object), ", "type": "text"}, {"text": "this.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " resolves to ", "type": "text"}, {"text": "undefined", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var homework = {\n    topic: \"JS\",\n    assignment: assignment\n};\n\nhomework.assignment();\n// Kyle says to study JS", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A copy of the ", "type": "text"}, {"text": "assignment", "type": "text", "marks": [{"type": "code"}]}, {"text": " function reference is set as a property on the ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " object, and then it's called as ", "type": "text"}, {"text": "homework.assignment()", "type": "text", "marks": [{"type": "code"}]}, {"text": ". That means the ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " for that function call will be the ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " object. Hence, ", "type": "text"}, {"text": "this.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " resolves to ", "type": "text"}, {"text": "\"JS\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Lastly:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var otherHomework = {\n    topic: \"Math\"\n};\n\nassignment.call(otherHomework);\n// Kyle says to study Math", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A third way to invoke a function is with the ", "type": "text"}, {"text": "call(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " method, which takes an object (", "type": "text"}, {"text": "otherHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " here) to use for setting the ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " reference for the function call. The property reference ", "type": "text"}, {"text": "this.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " resolves to ", "type": "text"}, {"text": "\"Math\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The same context-aware function invoked three different ways, gives different answers each time for what object ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " will reference.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The benefit of ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": "-aware functions\u2014and their dynamic context\u2014is the ability to more flexibly re-use a single function with data from different objects. A function that closes over a scope can never reference a different scope or set of variables. But a function that has dynamic ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " context awareness can be quite helpful for certain tasks.", "type": "text"}]}]}, "article_text": "this Keyword\n\nOne of JS's most powerful mechanisms is also one of its most misunderstood: the this keyword. One common misconception is that a function's this refers to the function itself. Because of how this works in other languages, another misconception is that this points the instance that a method belongs to. Both are incorrect.\n\nAs discussed previously, when a function is defined, it is attached to its enclosing scope via closure. Scope is the set of rules that controls how references to variables are resolved.\n\nBut functions also have another characteristic besides their scope that influences what they can access. This characteristic is best described as an execution context, and it's exposed to the function via its this keyword.\n\nScope is static and contains a fixed set of variables available at the moment and location you define a function, but a function's execution context is dynamic, entirely dependent on how it is called (regardless of where it is defined or even called from).\n\nthis is not a fixed characteristic of a function based on the function's definition, but rather a dynamic characteristic that's determined each time the function is called.\n\nOne way to think about the execution context is that it's a tangible object whose properties are made available to a function while it executes. Compare that to scope, which can also be thought of as an object; except, the scope object is hidden inside the JS engine, it's always the same for that function, and its properties take the form of identifier variables available inside the function.\n\nfunction classroom(teacher) {\n    return function study() {\n        console.log(\n            `${ teacher } says to study ${ this.topic }`\n        );\n    };\n}\nvar assignment = classroom(\"Kyle\");\n\nThe outer classroom(..) function makes no reference to a this keyword, so it's just like any other function we've seen so far. But the inner study() function does reference this, which makes it a this-aware function. In other words, it's a function that is dependent on its execution context.\n\nNOTE:\n\nstudy() is also closed over the teacher variable from its outer scope.\n\nThe inner study() function returned by classroom(\"Kyle\") is assigned to a variable called assignment. So how can assignment() (aka study()) be called?\n\nassignment();\n// Kyle says to study undefined  -- Oops :(\n\nIn this snippet, we call assignment() as a plain, normal function, without providing it any execution context.\n\nSince this program is not in strict mode (see Chapter 1, \"Strictly Speaking\"), context-aware functions that are called without any context specified default the context to the global object (window in the browser). As there is no global variable named topic (and thus no such property on the global object), this.topic resolves to undefined.\n\nNow consider:\n\nvar homework = {\n    topic: \"JS\",\n    assignment: assignment\n};\n\nhomework.assignment();\n// Kyle says to study JS\n\nA copy of the assignment function reference is set as a property on the homework object, and then it's called as homework.assignment(). That means the this for that function call will be the homework object. Hence, this.topic resolves to \"JS\".\n\nLastly:\n\nvar otherHomework = {\n    topic: \"Math\"\n};\n\nassignment.call(otherHomework);\n// Kyle says to study Math\n\nA third way to invoke a function is with the call(..) method, which takes an object (otherHomework here) to use for setting the this reference for the function call. The property reference this.topic resolves to \"Math\".\n\nThe same context-aware function invoked three different ways, gives different answers each time for what object this will reference.\n\nThe benefit of this-aware functions\u2014and their dynamic context\u2014is the ability to more flexibly re-use a single function with data from different objects. A function that closes over a scope can never reference a different scope or set of variables. But a function that has dynamic this context awareness can be quite helpful for certain tasks."}, "id": 139}, {"data": {"uuid": "996aa24d-e03f-4f49-ae9d-9d2df507d00a", "user": 1, "title": "Prototypes", "author": "Kyle Simpson", "created_on": "2023-06-07 20:32:01.811349+00:00", "updated_on": "2023-06-07 20:32:27.035340+00:00", "article_html": "<h2>Prototypes</h2><p>Where <code>this</code> is a characteristic of function execution, a prototype is a characteristic of an object, and specifically resolution of a property access.</p><p>Think about a prototype as a linkage between two objects; the linkage is hidden behind the scenes, though there are ways to expose and observe it. This prototype linkage occurs when an object is created; it's linked to another object that already exists.</p><p>A series of objects linked together via prototypes is called the \"prototype chain.\"</p><p>The purpose of this prototype linkage (i.e., from an object B to another object A) is so that accesses against B for properties/methods that B does not have, are <em>delegated</em> to A to handle. Delegation of property/method access allows two (or more!) objects to cooperate with each other to perform a task.</p><p>Consider defining an object as a normal literal:</p><pre><code>var homework = {\n    topic: \"JS\"\n};</code></pre><p>The <code>homework</code> object only has a single property on it: <code>topic</code>. However, its default prototype linkage connects to the <code>Object.prototype</code> object, which has common built-in methods on it like <code>toString()</code> and <code>valueOf()</code>, among others.</p><p>We can observe this prototype linkage <em>delegation</em> from <code>homework</code> to <code>Object.prototype</code>:</p><pre><code>homework.toString();    // [object Object]</code></pre><p><code>homework.toString()</code> works even though <code>homework</code> doesn't have a <code>toString()</code> method defined; the delegation invokes <code>Object.prototype.toString()</code> instead.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Prototypes", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Where ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " is a characteristic of function execution, a prototype is a characteristic of an object, and specifically resolution of a property access.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Think about a prototype as a linkage between two objects; the linkage is hidden behind the scenes, though there are ways to expose and observe it. This prototype linkage occurs when an object is created; it's linked to another object that already exists.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A series of objects linked together via prototypes is called the \"prototype chain.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The purpose of this prototype linkage (i.e., from an object B to another object A) is so that accesses against B for properties/methods that B does not have, are ", "type": "text"}, {"text": "delegated", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to A to handle. Delegation of property/method access allows two (or more!) objects to cooperate with each other to perform a task.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider defining an object as a normal literal:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var homework = {\n    topic: \"JS\"\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " object only has a single property on it: ", "type": "text"}, {"text": "topic", "type": "text", "marks": [{"type": "code"}]}, {"text": ". However, its default prototype linkage connects to the ", "type": "text"}, {"text": "Object.prototype", "type": "text", "marks": [{"type": "code"}]}, {"text": " object, which has common built-in methods on it like ", "type": "text"}, {"text": "toString()", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "valueOf()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", among others.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We can observe this prototype linkage ", "type": "text"}, {"text": "delegation", "type": "text", "marks": [{"type": "italic"}]}, {"text": " from ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "Object.prototype", "type": "text", "marks": [{"type": "code"}]}, {"text": ":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "homework.toString();    // [object Object]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "homework.toString()", "type": "text", "marks": [{"type": "code"}]}, {"text": " works even though ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " doesn't have a ", "type": "text"}, {"text": "toString()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method defined; the delegation invokes ", "type": "text"}, {"text": "Object.prototype.toString()", "type": "text", "marks": [{"type": "code"}]}, {"text": " instead.", "type": "text"}]}]}, "article_text": "Prototypes\n\nWhere this is a characteristic of function execution, a prototype is a characteristic of an object, and specifically resolution of a property access.\n\nThink about a prototype as a linkage between two objects; the linkage is hidden behind the scenes, though there are ways to expose and observe it. This prototype linkage occurs when an object is created; it's linked to another object that already exists.\n\nA series of objects linked together via prototypes is called the \"prototype chain.\"\n\nThe purpose of this prototype linkage (i.e., from an object B to another object A) is so that accesses against B for properties/methods that B does not have, are delegated to A to handle. Delegation of property/method access allows two (or more!) objects to cooperate with each other to perform a task.\n\nConsider defining an object as a normal literal:\n\nvar homework = {\n    topic: \"JS\"\n};\n\nThe homework object only has a single property on it: topic. However, its default prototype linkage connects to the Object.prototype object, which has common built-in methods on it like toString() and valueOf(), among others.\n\nWe can observe this prototype linkage delegation from homework to Object.prototype:\n\nhomework.toString();    // [object Object]\n\nhomework.toString() works even though homework doesn't have a toString() method defined; the delegation invokes Object.prototype.toString() instead."}, "id": 140, "children": [{"data": {"uuid": "b823273a-53b2-4fe7-b5ec-97dbdc562d86", "user": 1, "title": "Object Linkage", "author": "Kyle Simpson", "created_on": "2023-06-07 20:33:39.650319+00:00", "updated_on": "2023-06-07 20:36:20.495654+00:00", "article_html": "<h3>Object Linkage</h3><p>To define an object prototype linkage, you can create the object using the <code>Object.create(..)</code> utility:</p><pre><code>var homework = {\n    topic: \"JS\"\n};\n\nvar otherHomework = Object.create(homework);\n\notherHomework.topic;   // \"JS\"</code></pre><p>The first argument to <code>Object.create(..)</code> specifies an object to link the newly created object to, and then returns the newly created (and linked!) object.</p><p>Figure 4 shows how the three objects (<code>otherHomework</code>, <code>homework</code>, and <code>Object.prototype</code>) are linked in a prototype chain:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig4.png\"><p><em>Fig. 4: Objects in a prototype chain</em> </p><p>Delegation through the prototype chain only applies for accesses to lookup the value in a property. If you assign to a property of an object, that will apply directly to the object regardless of where that object is prototype linked to. </p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p><code>Object.create(null)</code> creates an object that is not prototype linked anywhere, so it's purely just a standalone object; in some circumstances, that may be preferable.</p></td></tr></tbody></table><p>Consider: </p><pre><code>homework.topic;\n// \"JS\"\n\notherHomework.topic;\n// \"JS\"\n\notherHomework.topic = \"Math\";\notherHomework.topic;\n// \"Math\"\n\nhomework.topic;\n// \"JS\" -- not \"Math\"</code></pre><p>The assignment to <code>topic</code> creates a property of that name directly on <code>otherHomework</code>; there's no effect on the <code>topic</code> property on <code>homework</code>. The next statement then accesses <code>otherHomework.topic</code>, and we see the non-delegated answer from that new property: <code>\"Math\"</code>.</p><p>Figure 5 shows the objects/properties after the assignment that creates the <code>otherHomework.topic</code> property:</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig5.png\"><p><em>Fig. 5: Shadowed property 'topic'</em> </p><p>The <code>topic</code> on <code>otherHomework</code> is \"shadowing\" the property of the same name on the <code>homework</code> object in the chain.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>NOTE:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>Another frankly more convoluted but perhaps still more common way of creating an object with a prototype linkage is using the \"prototypal class\" pattern, from before <code>class</code> (see Chapter 2, \"Classes\") was added in ES6. We'll cover this topic in more detail in Appendix A, \"Prototypal 'Classes'\".</p></td></tr></tbody></table>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "Object Linkage", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To define an object prototype linkage, you can create the object using the ", "type": "text"}, {"text": "Object.create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " utility:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var homework = {\n    topic: \"JS\"\n};\n\nvar otherHomework = Object.create(homework);\n\notherHomework.topic;   // \"JS\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first argument to ", "type": "text"}, {"text": "Object.create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " specifies an object to link the newly created object to, and then returns the newly created (and linked!) object.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Figure 4 shows how the three objects (", "type": "text"}, {"text": "otherHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": ", ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and ", "type": "text"}, {"text": "Object.prototype", "type": "text", "marks": [{"type": "code"}]}, {"text": ") are linked in a prototype chain:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig4.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 4: Objects in a prototype chain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Delegation through the prototype chain only applies for accesses to lookup the value in a property. If you assign to a property of an object, that will apply directly to the object regardless of where that object is prototype linked to. ", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Object.create(null)", "type": "text", "marks": [{"type": "code"}]}, {"text": " creates an object that is not prototype linked anywhere, so it's purely just a standalone object; in some circumstances, that may be preferable.", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Consider: ", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "homework.topic;\n// \"JS\"\n\notherHomework.topic;\n// \"JS\"\n\notherHomework.topic = \"Math\";\notherHomework.topic;\n// \"Math\"\n\nhomework.topic;\n// \"JS\" -- not \"Math\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The assignment to ", "type": "text"}, {"text": "topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " creates a property of that name directly on ", "type": "text"}, {"text": "otherHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": "; there's no effect on the ", "type": "text"}, {"text": "topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " property on ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": ". The next statement then accesses ", "type": "text"}, {"text": "otherHomework.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and we see the non-delegated answer from that new property: ", "type": "text"}, {"text": "\"Math\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Figure 5 shows the objects/properties after the assignment that creates the ", "type": "text"}, {"text": "otherHomework.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " property:", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig5.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 5: Shadowed property 'topic'", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " on ", "type": "text"}, {"text": "otherHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " is \"shadowing\" the property of the same name on the ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " object in the chain.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "NOTE:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "Another frankly more convoluted but perhaps still more common way of creating an object with a prototype linkage is using the \"prototypal class\" pattern, from before ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " (see Chapter 2, \"Classes\") was added in ES6. We'll cover this topic in more detail in Appendix A, \"Prototypal 'Classes'\".", "type": "text"}]}]}]}]}]}, "article_text": "Object Linkage\n\nTo define an object prototype linkage, you can create the object using the Object.create(..) utility:\n\nvar homework = {\n    topic: \"JS\"\n};\n\nvar otherHomework = Object.create(homework);\n\notherHomework.topic;   // \"JS\"\n\nThe first argument to Object.create(..) specifies an object to link the newly created object to, and then returns the newly created (and linked!) object.\n\nFigure 4 shows how the three objects (otherHomework, homework, and Object.prototype) are linked in a prototype chain:\n\nFig. 4: Objects in a prototype chain \n\nDelegation through the prototype chain only applies for accesses to lookup the value in a property. If you assign to a property of an object, that will apply directly to the object regardless of where that object is prototype linked to. \n\nTIP:\n\nObject.create(null) creates an object that is not prototype linked anywhere, so it's purely just a standalone object; in some circumstances, that may be preferable.\n\nConsider: \n\nhomework.topic;\n// \"JS\"\n\notherHomework.topic;\n// \"JS\"\n\notherHomework.topic = \"Math\";\notherHomework.topic;\n// \"Math\"\n\nhomework.topic;\n// \"JS\" -- not \"Math\"\n\nThe assignment to topic creates a property of that name directly on otherHomework; there's no effect on the topic property on homework. The next statement then accesses otherHomework.topic, and we see the non-delegated answer from that new property: \"Math\".\n\nFigure 5 shows the objects/properties after the assignment that creates the otherHomework.topic property:\n\nFig. 5: Shadowed property 'topic' \n\nThe topic on otherHomework is \"shadowing\" the property of the same name on the homework object in the chain.\n\nNOTE:\n\nAnother frankly more convoluted but perhaps still more common way of creating an object with a prototype linkage is using the \"prototypal class\" pattern, from before class (see Chapter 2, \"Classes\") was added in ES6. We'll cover this topic in more detail in Appendix A, \"Prototypal 'Classes'\"."}, "id": 141}, {"data": {"uuid": "c353d531-c669-40b8-bae0-efcbc168e721", "user": 1, "title": "this Revisited", "author": "Kyle Simpson", "created_on": "2023-06-07 20:36:56.685376+00:00", "updated_on": "2023-06-07 20:37:47.253190+00:00", "article_html": "<h3><code>this</code> Revisited</h3><p>We covered the <code>this</code> keyword earlier, but its true importance shines when considering how it powers prototype-delegated function calls. Indeed, one of the main reasons <code>this</code> supports dynamic context based on how the function is called is so that method calls on objects which delegate through the prototype chain still maintain the expected <code>this</code>.</p><p>Consider:</p><pre><code>var homework = {\n    study() {\n        console.log(`Please study ${ this.topic }`);\n    }\n};\n\nvar jsHomework = Object.create(homework);\njsHomework.topic = \"JS\";\njsHomework.study();\n// Please study JS\n\nvar mathHomework = Object.create(homework);\nmathHomework.topic = \"Math\";\nmathHomework.study();\n// Please study Math</code></pre><p>The two objects <code>jsHomework</code> and <code>mathHomework</code> each prototype link to the single <code>homework</code> object, which has the <code>study()</code> function. <code>jsHomework</code> and <code>mathHomework</code> are each given their own <code>topic</code> property (see Figure 6).</p><img src=\"https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig6.png\"><p><em>Fig. 6: Two objects linked to a common parent</em> </p><p><code>jsHomework.study()</code> delegates to <code>homework.study()</code>, but its <code>this</code> (<code>this.topic</code>) for that execution resolves to <code>jsHomework</code> because of how the function is called, so <code>this.topic</code> is <code>\"JS\"</code>. Similarly for <code>mathHomework.study()</code> delegating to <code>homework.study()</code> but still resolving <code>this</code> to <code>mathHomework</code>, and thus <code>this.topic</code> as <code>\"Math\"</code>.</p><p>The preceding code snippet would be far less useful if <code>this</code> was resolved to <code>homework</code>. Yet, in many other languages, it would seem <code>this</code> would be <code>homework</code> because the <code>study()</code> method is indeed defined on <code>homework</code>.</p><p>Unlike many other languages, JS's <code>this</code> being dynamic is a critical component of allowing prototype delegation, and indeed <code>class</code>, to work as expected!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 3}, "content": [{"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " Revisited", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We covered the ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword earlier, but its true importance shines when considering how it powers prototype-delegated function calls. Indeed, one of the main reasons ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " supports dynamic context based on how the function is called is so that method calls on objects which delegate through the prototype chain still maintain the expected ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var homework = {\n    study() {\n        console.log(`Please study ${ this.topic }`);\n    }\n};\n\nvar jsHomework = Object.create(homework);\njsHomework.topic = \"JS\";\njsHomework.study();\n// Please study JS\n\nvar mathHomework = Object.create(homework);\nmathHomework.topic = \"Math\";\nmathHomework.study();\n// Please study Math", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The two objects ", "type": "text"}, {"text": "jsHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "mathHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " each prototype link to the single ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " object, which has the ", "type": "text"}, {"text": "study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function. ", "type": "text"}, {"text": "jsHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "mathHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " are each given their own ", "type": "text"}, {"text": "topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " property (see Figure 6).", "type": "text"}]}, {"type": "image", "attrs": {"alt": null, "src": "https://raw.githubusercontent.com/getify/You-Dont-Know-JS/2nd-ed/get-started/images/fig6.png", "title": null}}, {"type": "paragraph", "content": [{"text": "Fig. 6: Two objects linked to a common parent", "type": "text", "marks": [{"type": "italic"}]}, {"text": " ", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "jsHomework.study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " delegates to ", "type": "text"}, {"text": "homework.study()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", but its ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " (", "type": "text"}, {"text": "this.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": ") for that execution resolves to ", "type": "text"}, {"text": "jsHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": " because of how the function is called, so ", "type": "text"}, {"text": "this.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " is ", "type": "text"}, {"text": "\"JS\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Similarly for ", "type": "text"}, {"text": "mathHomework.study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " delegating to ", "type": "text"}, {"text": "homework.study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " but still resolving ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "mathHomework", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and thus ", "type": "text"}, {"text": "this.topic", "type": "text", "marks": [{"type": "code"}]}, {"text": " as ", "type": "text"}, {"text": "\"Math\"", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The preceding code snippet would be far less useful if ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " was resolved to ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Yet, in many other languages, it would seem ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " would be ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": " because the ", "type": "text"}, {"text": "study()", "type": "text", "marks": [{"type": "code"}]}, {"text": " method is indeed defined on ", "type": "text"}, {"text": "homework", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Unlike many other languages, JS's ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " being dynamic is a critical component of allowing prototype delegation, and indeed ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": ", to work as expected!", "type": "text"}]}]}, "article_text": "this Revisited\n\nWe covered the this keyword earlier, but its true importance shines when considering how it powers prototype-delegated function calls. Indeed, one of the main reasons this supports dynamic context based on how the function is called is so that method calls on objects which delegate through the prototype chain still maintain the expected this.\n\nConsider:\n\nvar homework = {\n    study() {\n        console.log(`Please study ${ this.topic }`);\n    }\n};\n\nvar jsHomework = Object.create(homework);\njsHomework.topic = \"JS\";\njsHomework.study();\n// Please study JS\n\nvar mathHomework = Object.create(homework);\nmathHomework.topic = \"Math\";\nmathHomework.study();\n// Please study Math\n\nThe two objects jsHomework and mathHomework each prototype link to the single homework object, which has the study() function. jsHomework and mathHomework are each given their own topic property (see Figure 6).\n\nFig. 6: Two objects linked to a common parent \n\njsHomework.study() delegates to homework.study(), but its this (this.topic) for that execution resolves to jsHomework because of how the function is called, so this.topic is \"JS\". Similarly for mathHomework.study() delegating to homework.study() but still resolving this to mathHomework, and thus this.topic as \"Math\".\n\nThe preceding code snippet would be far less useful if this was resolved to homework. Yet, in many other languages, it would seem this would be homework because the study() method is indeed defined on homework.\n\nUnlike many other languages, JS's this being dynamic is a critical component of allowing prototype delegation, and indeed class, to work as expected!"}, "id": 142}]}, {"data": {"uuid": "5cdb0535-893e-4412-8db5-87145114cacd", "user": 1, "title": "Asking \"Why?\"", "author": "Kyle Simpson", "created_on": "2023-06-07 20:38:07.509819+00:00", "updated_on": "2023-06-07 20:38:25.133097+00:00", "article_html": "<h2>Asking \"Why?\"</h2><p>The intended take-away from this chapter is that there's a lot more to JS under the hood than is obvious from glancing at the surface.</p><p>As you are <em>getting started</em> learning and knowing JS more closely, one of the most important skills you can practice and bolster is curiosity, and the art of asking \"Why?\" when you encounter something in the language.</p><p>Even though this chapter has gone quite deep on some of the topics, many details have still been entirely skimmed over. There's much more to learn here, and the path to that starts with you asking the <em>right</em> questions of your code. Asking the right questions is a critical skill of becoming a better developer.</p><p>In the final chapter of this book, we're going to briefly look at how JS is divided, as covered across the rest of the <em>You Don't Know JS Yet</em> book series. Also, don't skip Appendix B of this book, which has some practice code to review some of the main topics covered in this book.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Asking \"Why?\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The intended take-away from this chapter is that there's a lot more to JS under the hood than is obvious from glancing at the surface.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As you are ", "type": "text"}, {"text": "getting started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " learning and knowing JS more closely, one of the most important skills you can practice and bolster is curiosity, and the art of asking \"Why?\" when you encounter something in the language.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even though this chapter has gone quite deep on some of the topics, many details have still been entirely skimmed over. There's much more to learn here, and the path to that starts with you asking the ", "type": "text"}, {"text": "right", "type": "text", "marks": [{"type": "italic"}]}, {"text": " questions of your code. Asking the right questions is a critical skill of becoming a better developer.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In the final chapter of this book, we're going to briefly look at how JS is divided, as covered across the rest of the ", "type": "text"}, {"text": "You Don't Know JS Yet", "type": "text", "marks": [{"type": "italic"}]}, {"text": " book series. Also, don't skip Appendix B of this book, which has some practice code to review some of the main topics covered in this book.", "type": "text"}]}]}, "article_text": "Asking \"Why?\"\n\nThe intended take-away from this chapter is that there's a lot more to JS under the hood than is obvious from glancing at the surface.\n\nAs you are getting started learning and knowing JS more closely, one of the most important skills you can practice and bolster is curiosity, and the art of asking \"Why?\" when you encounter something in the language.\n\nEven though this chapter has gone quite deep on some of the topics, many details have still been entirely skimmed over. There's much more to learn here, and the path to that starts with you asking the right questions of your code. Asking the right questions is a critical skill of becoming a better developer.\n\nIn the final chapter of this book, we're going to briefly look at how JS is divided, as covered across the rest of the You Don't Know JS Yet book series. Also, don't skip Appendix B of this book, which has some practice code to review some of the main topics covered in this book."}, "id": 143}]}, {"data": {"uuid": "4bfa2fac-f6f5-42f4-b9b1-7de69111da5e", "user": 1, "title": "Chapter 4: The Bigger Picture", "author": "Kyle Simpson", "created_on": "2023-06-07 20:41:34.996523+00:00", "updated_on": "2023-06-07 20:42:03.675167+00:00", "article_html": "<h1>Chapter 4: The Bigger Picture</h1><p>This book surveys what you need to be aware of as you <em>get started</em> with JS. The goal is to fill in gaps that readers newer to JS might have tripped over in their early encounters with the language. I also hope that we've hinted at enough deeper detail throughout to pique your curiosity to want to dig more into the language.</p><p>The rest of the books in this series are where we will unpack all of the rest of the language, in far greater detail than we could have done in a few brief chapters here.</p><p>Remember to take your time, though. Rather than rushing onto the next book in an attempt to churn through all the books expediently, spend some time going back over the material in this book. Spend some more time looking through code in your current projects, and comparing what you see to what's been discussed so far.</p><p>When you're ready, this final chapter divides the organization of the JS language into three main pillars, then offers a brief roadmap of what to expect from the rest of the book series, and how I suggest you proceed. Also, don't skip the appendices, especially Appendix B, \"Practice, Practice, Practice!\".</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Chapter 4: The Bigger Picture", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This book surveys what you need to be aware of as you ", "type": "text"}, {"text": "get started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with JS. The goal is to fill in gaps that readers newer to JS might have tripped over in their early encounters with the language. I also hope that we've hinted at enough deeper detail throughout to pique your curiosity to want to dig more into the language.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The rest of the books in this series are where we will unpack all of the rest of the language, in far greater detail than we could have done in a few brief chapters here.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Remember to take your time, though. Rather than rushing onto the next book in an attempt to churn through all the books expediently, spend some time going back over the material in this book. Spend some more time looking through code in your current projects, and comparing what you see to what's been discussed so far.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "When you're ready, this final chapter divides the organization of the JS language into three main pillars, then offers a brief roadmap of what to expect from the rest of the book series, and how I suggest you proceed. Also, don't skip the appendices, especially Appendix B, \"Practice, Practice, Practice!\".", "type": "text"}]}]}, "article_text": "Chapter 4: The Bigger Picture\n\nThis book surveys what you need to be aware of as you get started with JS. The goal is to fill in gaps that readers newer to JS might have tripped over in their early encounters with the language. I also hope that we've hinted at enough deeper detail throughout to pique your curiosity to want to dig more into the language.\n\nThe rest of the books in this series are where we will unpack all of the rest of the language, in far greater detail than we could have done in a few brief chapters here.\n\nRemember to take your time, though. Rather than rushing onto the next book in an attempt to churn through all the books expediently, spend some time going back over the material in this book. Spend some more time looking through code in your current projects, and comparing what you see to what's been discussed so far.\n\nWhen you're ready, this final chapter divides the organization of the JS language into three main pillars, then offers a brief roadmap of what to expect from the rest of the book series, and how I suggest you proceed. Also, don't skip the appendices, especially Appendix B, \"Practice, Practice, Practice!\"."}, "id": 144, "children": [{"data": {"uuid": "dabd5c2b-90c6-4bde-a1b7-1f638cd16701", "user": 1, "title": "Pillar 1: Scope and Closure", "author": "Kyle Simpson", "created_on": "2023-06-07 20:42:31.974710+00:00", "updated_on": "2023-06-07 20:42:55.439921+00:00", "article_html": "<h2>Pillar 1: Scope and Closure</h2><p>The organization of variables into units of scope (functions, blocks) is one of the most foundational characteristics of any language; perhaps no other characteristic has a greater impact on how programs behave.</p><p>Scopes are like buckets, and variables are like marbles you put into those buckets. The scope model of a language is like the rules that help you determine which color marbles go in which matching-color buckets.</p><p>Scopes nest inside each other, and for any given expression or statement, only variables at that level of scope nesting, or in higher/outer scopes, are accessible; variables from lower/inner scopes are hidden and inaccessible.</p><p>This is how scopes behave in most languages, which is called lexical scope. The scope unit boundaries, and how variables are organized in them, is determined at the time the program is parsed (compiled). In other words, it's an author-time decision: where you locate a function/scope in the program determines what the scope structure of that part of the program will be.</p><p>JS is lexically scoped, though many claim it isn't, because of two particular characteristics of its model that are not present in other lexically scoped languages.</p><p>The first is commonly called <em>hoisting</em>: when all variables declared anywhere in a scope are treated as if they're declared at the beginning of the scope. The other is that <code>var</code>-declared variables are function scoped, even if they appear inside a block.</p><p>Neither hoisting nor function-scoped <code>var</code> are sufficient to back the claim that JS is not lexically scoped. <code>let</code>/<code>const</code> declarations have a peculiar error behavior called the \"Temporal Dead Zone\" (TDZ) which results in observable but unusable variables. Though TDZ can be strange to encounter, it's <em>also</em> not an invalidation of lexical scoping. All of these are just unique parts of the language that should be learned and understood by all JS developers.</p><p>Closure is a natural result of lexical scope when the language has functions as first-class values, as JS does. When a function makes reference to variables from an outer scope, and that function is passed around as a value and executed in other scopes, it maintains access to its original scope variables; this is closure.</p><p>Across all of programming, but especially in JS, closure drives many of the most important programming patterns, including modules. As I see it, modules are as <em>with the grain</em> as you can get, when it comes to code organization in JS.</p><p>To dig further into scope, closures, and how modules work, read Book 2, <em>Scope &amp; Closures</em>.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Pillar 1: Scope and Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The organization of variables into units of scope (functions, blocks) is one of the most foundational characteristics of any language; perhaps no other characteristic has a greater impact on how programs behave.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Scopes are like buckets, and variables are like marbles you put into those buckets. The scope model of a language is like the rules that help you determine which color marbles go in which matching-color buckets.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Scopes nest inside each other, and for any given expression or statement, only variables at that level of scope nesting, or in higher/outer scopes, are accessible; variables from lower/inner scopes are hidden and inaccessible.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This is how scopes behave in most languages, which is called lexical scope. The scope unit boundaries, and how variables are organized in them, is determined at the time the program is parsed (compiled). In other words, it's an author-time decision: where you locate a function/scope in the program determines what the scope structure of that part of the program will be.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS is lexically scoped, though many claim it isn't, because of two particular characteristics of its model that are not present in other lexically scoped languages.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The first is commonly called ", "type": "text"}, {"text": "hoisting", "type": "text", "marks": [{"type": "italic"}]}, {"text": ": when all variables declared anywhere in a scope are treated as if they're declared at the beginning of the scope. The other is that ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": "-declared variables are function scoped, even if they appear inside a block.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Neither hoisting nor function-scoped ", "type": "text"}, {"text": "var", "type": "text", "marks": [{"type": "code"}]}, {"text": " are sufficient to back the claim that JS is not lexically scoped. ", "type": "text"}, {"text": "let", "type": "text", "marks": [{"type": "code"}]}, {"text": "/", "type": "text"}, {"text": "const", "type": "text", "marks": [{"type": "code"}]}, {"text": " declarations have a peculiar error behavior called the \"Temporal Dead Zone\" (TDZ) which results in observable but unusable variables. Though TDZ can be strange to encounter, it's ", "type": "text"}, {"text": "also", "type": "text", "marks": [{"type": "italic"}]}, {"text": " not an invalidation of lexical scoping. All of these are just unique parts of the language that should be learned and understood by all JS developers.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Closure is a natural result of lexical scope when the language has functions as first-class values, as JS does. When a function makes reference to variables from an outer scope, and that function is passed around as a value and executed in other scopes, it maintains access to its original scope variables; this is closure.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Across all of programming, but especially in JS, closure drives many of the most important programming patterns, including modules. As I see it, modules are as ", "type": "text"}, {"text": "with the grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " as you can get, when it comes to code organization in JS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To dig further into scope, closures, and how modules work, read Book 2, ", "type": "text"}, {"text": "Scope & Closures", "type": "text", "marks": [{"type": "italic"}]}, {"text": ".", "type": "text"}]}]}, "article_text": "Pillar 1: Scope and Closure\n\nThe organization of variables into units of scope (functions, blocks) is one of the most foundational characteristics of any language; perhaps no other characteristic has a greater impact on how programs behave.\n\nScopes are like buckets, and variables are like marbles you put into those buckets. The scope model of a language is like the rules that help you determine which color marbles go in which matching-color buckets.\n\nScopes nest inside each other, and for any given expression or statement, only variables at that level of scope nesting, or in higher/outer scopes, are accessible; variables from lower/inner scopes are hidden and inaccessible.\n\nThis is how scopes behave in most languages, which is called lexical scope. The scope unit boundaries, and how variables are organized in them, is determined at the time the program is parsed (compiled). In other words, it's an author-time decision: where you locate a function/scope in the program determines what the scope structure of that part of the program will be.\n\nJS is lexically scoped, though many claim it isn't, because of two particular characteristics of its model that are not present in other lexically scoped languages.\n\nThe first is commonly called hoisting: when all variables declared anywhere in a scope are treated as if they're declared at the beginning of the scope. The other is that var-declared variables are function scoped, even if they appear inside a block.\n\nNeither hoisting nor function-scoped var are sufficient to back the claim that JS is not lexically scoped. let/const declarations have a peculiar error behavior called the \"Temporal Dead Zone\" (TDZ) which results in observable but unusable variables. Though TDZ can be strange to encounter, it's also not an invalidation of lexical scoping. All of these are just unique parts of the language that should be learned and understood by all JS developers.\n\nClosure is a natural result of lexical scope when the language has functions as first-class values, as JS does. When a function makes reference to variables from an outer scope, and that function is passed around as a value and executed in other scopes, it maintains access to its original scope variables; this is closure.\n\nAcross all of programming, but especially in JS, closure drives many of the most important programming patterns, including modules. As I see it, modules are as with the grain as you can get, when it comes to code organization in JS.\n\nTo dig further into scope, closures, and how modules work, read Book 2, Scope & Closures."}, "id": 145}, {"data": {"uuid": "89552785-5248-42b5-ab41-3c76e20ca924", "user": 1, "title": "Pillar 2: Prototypes", "author": "Kyle Simpson", "created_on": "2023-06-07 20:43:17.732472+00:00", "updated_on": "2023-06-07 20:43:35.866852+00:00", "article_html": "<h2>Pillar 2: Prototypes</h2><p>The second pillar of the language is the prototypes system. We covered this topic in-depth in Chapter 3 (\"Prototypes\"), but I just want to make a few more comments about its importance.</p><p>JS is one of very few languages where you have the option to create objects directly and explicitly, without first defining their structure in a class.</p><p>For many years, people implemented the class design pattern on top of prototypes\u2014so-called \"prototypal inheritance\" (see Appendix A, \"Prototypal 'Classes'\")\u2014and then with the advent of ES6's <code>class</code> keyword, the language doubled-down on its inclination toward OO/class-style programming.</p><p>But I think that focus has obscured the beauty and power of the prototype system: the ability for two objects to simply connect with each other and cooperate dynamically (during function/method execution) through sharing a <code>this</code> context.</p><p>Classes are just one pattern you can build on top of such power. But another approach, in a very different direction, is to simply embrace objects as objects, forget classes altogether, and let objects cooperate through the prototype chain. This is called <em>behavior delegation</em>. I think delegation is more powerful than class inheritance, as a means for organizing behavior and data in our programs.</p><p>But class inheritance gets almost all the attention. And the rest goes to functional programming (FP), as the sort of \"anti-class\" way of designing programs. This saddens me, because it snuffs out any chance for exploration of delegation as a viable alternative.</p><p>I encourage you to spend plenty of time deep in Book 3, <em>Objects &amp; Classes</em>, to see how object delegation holds far more potential than we've perhaps realized. This isn't an anti-<code>class</code> message, but it is intentionally a \"classes aren't the only way to use objects\" message that I want more JS developers to consider.</p><p>Object delegation is, I would argue, far more <em>with the grain</em> of JS, than classes (more on <em>grains</em> in a bit).</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Pillar 2: Prototypes", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The second pillar of the language is the prototypes system. We covered this topic in-depth in Chapter 3 (\"Prototypes\"), but I just want to make a few more comments about its importance.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "JS is one of very few languages where you have the option to create objects directly and explicitly, without first defining their structure in a class.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "For many years, people implemented the class design pattern on top of prototypes\u2014so-called \"prototypal inheritance\" (see Appendix A, \"Prototypal 'Classes'\")\u2014and then with the advent of ES6's ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword, the language doubled-down on its inclination toward OO/class-style programming.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I think that focus has obscured the beauty and power of the prototype system: the ability for two objects to simply connect with each other and cooperate dynamically (during function/method execution) through sharing a ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " context.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Classes are just one pattern you can build on top of such power. But another approach, in a very different direction, is to simply embrace objects as objects, forget classes altogether, and let objects cooperate through the prototype chain. This is called ", "type": "text"}, {"text": "behavior delegation", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". I think delegation is more powerful than class inheritance, as a means for organizing behavior and data in our programs.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But class inheritance gets almost all the attention. And the rest goes to functional programming (FP), as the sort of \"anti-class\" way of designing programs. This saddens me, because it snuffs out any chance for exploration of delegation as a viable alternative.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I encourage you to spend plenty of time deep in Book 3, ", "type": "text"}, {"text": "Objects & Classes", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", to see how object delegation holds far more potential than we've perhaps realized. This isn't an anti-", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " message, but it is intentionally a \"classes aren't the only way to use objects\" message that I want more JS developers to consider.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Object delegation is, I would argue, far more ", "type": "text"}, {"text": "with the grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of JS, than classes (more on ", "type": "text"}, {"text": "grains", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in a bit).", "type": "text"}]}]}, "article_text": "Pillar 2: Prototypes\n\nThe second pillar of the language is the prototypes system. We covered this topic in-depth in Chapter 3 (\"Prototypes\"), but I just want to make a few more comments about its importance.\n\nJS is one of very few languages where you have the option to create objects directly and explicitly, without first defining their structure in a class.\n\nFor many years, people implemented the class design pattern on top of prototypes\u2014so-called \"prototypal inheritance\" (see Appendix A, \"Prototypal 'Classes'\")\u2014and then with the advent of ES6's class keyword, the language doubled-down on its inclination toward OO/class-style programming.\n\nBut I think that focus has obscured the beauty and power of the prototype system: the ability for two objects to simply connect with each other and cooperate dynamically (during function/method execution) through sharing a this context.\n\nClasses are just one pattern you can build on top of such power. But another approach, in a very different direction, is to simply embrace objects as objects, forget classes altogether, and let objects cooperate through the prototype chain. This is called behavior delegation. I think delegation is more powerful than class inheritance, as a means for organizing behavior and data in our programs.\n\nBut class inheritance gets almost all the attention. And the rest goes to functional programming (FP), as the sort of \"anti-class\" way of designing programs. This saddens me, because it snuffs out any chance for exploration of delegation as a viable alternative.\n\nI encourage you to spend plenty of time deep in Book 3, Objects & Classes, to see how object delegation holds far more potential than we've perhaps realized. This isn't an anti-class message, but it is intentionally a \"classes aren't the only way to use objects\" message that I want more JS developers to consider.\n\nObject delegation is, I would argue, far more with the grain of JS, than classes (more on grains in a bit)."}, "id": 146}, {"data": {"uuid": "4553008c-b28b-48d1-883f-d21e63d79584", "user": 1, "title": "Pillar 3: Types and Coercion", "author": "Kyle Simpson", "created_on": "2023-06-07 20:43:54.406728+00:00", "updated_on": "2023-06-07 20:44:14.219772+00:00", "article_html": "<h2>Pillar 3: Types and Coercion</h2><p>The third pillar of JS is by far the most overlooked part of JS's nature.</p><p>The vast majority of developers have strong misconceptions about how <em>types</em> work in programming languages, and especially how they work in JS. A tidal wave of interest in the broader JS community has begun to shift to \"static typing\" approaches, using type-aware tooling like TypeScript or Flow.</p><p>I agree that JS developers should learn more about types, and should learn more about how JS manages type conversions. I also agree that type-aware tooling can help developers, assuming they have gained and used this knowledge in the first place!</p><p>But I don't agree at all that the inevitable conclusion of this is to decide JS's type mechanism is bad and that we need to cover up JS's types with solutions outside the language. We don't have to follow the \"static typing\" way to be smart and solid with types in our programs. There are other options, if you're just willing to go <em>against the grain</em> of the crowd, and <em>with the grain</em> of JS (again, more on that to come).</p><p>Arguably, this pillar is more important than the other two, in the sense that no JS program will do anything useful if it doesn't properly leverage JS's value types, as well as the conversion (coercion) of values between types.</p><p>Even if you love TypeScript/Flow, you are not going to get the most out of those tools or coding approaches if you aren't deeply familiar with how the language itself manages value types.</p><p>To learn more about JS types and coercion, check out Book 4, <em>Types &amp; Grammar</em>. But please don't skip over this topic just because you've always heard that we should use <code>===</code> and forget about the rest.</p><p>Without learning this pillar, your foundation in JS is shaky and incomplete at best.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Pillar 3: Types and Coercion", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The third pillar of JS is by far the most overlooked part of JS's nature.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The vast majority of developers have strong misconceptions about how ", "type": "text"}, {"text": "types", "type": "text", "marks": [{"type": "italic"}]}, {"text": " work in programming languages, and especially how they work in JS. A tidal wave of interest in the broader JS community has begun to shift to \"static typing\" approaches, using type-aware tooling like TypeScript or Flow.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I agree that JS developers should learn more about types, and should learn more about how JS manages type conversions. I also agree that type-aware tooling can help developers, assuming they have gained and used this knowledge in the first place!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I don't agree at all that the inevitable conclusion of this is to decide JS's type mechanism is bad and that we need to cover up JS's types with solutions outside the language. We don't have to follow the \"static typing\" way to be smart and solid with types in our programs. There are other options, if you're just willing to go ", "type": "text"}, {"text": "against the grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of the crowd, and ", "type": "text"}, {"text": "with the grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of JS (again, more on that to come).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Arguably, this pillar is more important than the other two, in the sense that no JS program will do anything useful if it doesn't properly leverage JS's value types, as well as the conversion (coercion) of values between types.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even if you love TypeScript/Flow, you are not going to get the most out of those tools or coding approaches if you aren't deeply familiar with how the language itself manages value types.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "To learn more about JS types and coercion, check out Book 4, ", "type": "text"}, {"text": "Types & Grammar", "type": "text", "marks": [{"type": "italic"}]}, {"text": ". But please don't skip over this topic just because you've always heard that we should use ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " and forget about the rest.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Without learning this pillar, your foundation in JS is shaky and incomplete at best.", "type": "text"}]}]}, "article_text": "Pillar 3: Types and Coercion\n\nThe third pillar of JS is by far the most overlooked part of JS's nature.\n\nThe vast majority of developers have strong misconceptions about how types work in programming languages, and especially how they work in JS. A tidal wave of interest in the broader JS community has begun to shift to \"static typing\" approaches, using type-aware tooling like TypeScript or Flow.\n\nI agree that JS developers should learn more about types, and should learn more about how JS manages type conversions. I also agree that type-aware tooling can help developers, assuming they have gained and used this knowledge in the first place!\n\nBut I don't agree at all that the inevitable conclusion of this is to decide JS's type mechanism is bad and that we need to cover up JS's types with solutions outside the language. We don't have to follow the \"static typing\" way to be smart and solid with types in our programs. There are other options, if you're just willing to go against the grain of the crowd, and with the grain of JS (again, more on that to come).\n\nArguably, this pillar is more important than the other two, in the sense that no JS program will do anything useful if it doesn't properly leverage JS's value types, as well as the conversion (coercion) of values between types.\n\nEven if you love TypeScript/Flow, you are not going to get the most out of those tools or coding approaches if you aren't deeply familiar with how the language itself manages value types.\n\nTo learn more about JS types and coercion, check out Book 4, Types & Grammar. But please don't skip over this topic just because you've always heard that we should use === and forget about the rest.\n\nWithout learning this pillar, your foundation in JS is shaky and incomplete at best."}, "id": 147}, {"data": {"uuid": "e13860c7-6320-46ec-b7e1-4f6b16de8e0b", "user": 1, "title": "With the Grain", "author": "Kyle Simpson", "created_on": "2023-06-07 20:44:34.652873+00:00", "updated_on": "2023-06-07 20:44:53.270034+00:00", "article_html": "<h2>With the Grain</h2><p>I have some advice to share on continuing your learning journey with JS, and your path through the rest of this book series: be aware of the <em>grain</em> (recall various references to <em>grain</em> earlier in this chapter).</p><p>First, consider the <em>grain</em> (as in, wood) of how most people approach and use JS. You've probably already noticed that these books cut against that <em>grain</em> in many respects. In YDKJSY, I respect you the reader enough to explain all the parts of JS, not only some select popular parts. I believe you're both capable and deserving of that knowledge.</p><p>But that is not what you'll find from a lot of other material out there. It also means that the more you follow and adhere to the guidance from these books\u2014that you think carefully and analyze for yourself what's best in your code\u2014the more you will stand out. That can be a good and bad thing. If you ever want to break out from the crowd, you're going to have to break from how the crowd does it!</p><p>But I've also had many people tell me that they quoted some topic/explanation from these books during a job interview, and the interviewer told the candidate they were wrong; indeed, people have reportedly lost out on job offers as a result.</p><p>As much as possible, I endeavor in these books to provide completely accurate information about JS, informed generally from the specification itself. But I also dose out quite a bit of my opinions on how you can interpret and use JS to the best benefit in your programs. I don't present opinion as fact, or vice versa. You'll always know which is which in these books.</p><p>Facts about JS are not really up for debate. Either the specification says something, or it doesn't. If you don't like what the specification says, or my relaying of it, take that up with TC39! If you're in an interview and they claim you're wrong on the facts, ask them right then and there if you can look it up in the specification. If the interviewer won't re-consider, then you shouldn't want to work there anyway.</p><p>But if you choose to align with my opinions, you have to be prepared to back up those choices with <em>why</em> you feel that way. Don't just parrot what I say. Own your opinions. Defend them. And if someone you were hoping to work with disagrees, walk away with your head still held high. It's a big JS, and there's plenty of room for lots of different ways.</p><p>In other words, don't be afraid to go against the <em>grain</em>, as I have done with these books and all my teachings. Nobody can tell you how you will best make use of JS; that's for you to decide. I'm merely trying to empower you in coming to your own conclusions, no matter what they are.</p><p>On the other hand, there's a <em>grain</em> you really should pay attention to and follow: the <em>grain</em> of how JS works, at the language level. There are things that work well and naturally in JS, given the right practice and approach, and there are things you really shouldn't try to do in the language.</p><p>Can you make your JS program look like a Java, C#, or Perl program? What about Python or Ruby, or even PHP? To varying degrees, sure you can. But should you?</p><p>No, I don't think you should. I think you should learn and embrace the JS way, and make your JS programs as JS'y as is practical. Some will think that means sloppy and informal programming, but I don't mean that at all. I just mean that JS has a lot of patterns and idioms that are recognizably \"JS,\" and going with that <em>grain</em> is the general path to the best success.</p><p>Finally, maybe the most important <em>grain</em> to recognize is how the existing program(s) you're working on, and developers you're working with, do stuff. Don't read these books and then try to change <em>all that grain</em> in your existing projects over night. That approach will always fail.</p><p>You'll have to shift these things little by little, over time. Work on building consensus with your fellow developers on why it's important to re-visit and re-consider an approach. But do so with just one small topic at a time, and let before-and-after code comparisons do most of the talking. Bring everyone on the team together to discuss, and push for decisions that are based on analysis and evidence from the code rather than the inertia of \"our senior devs have always done it this way.\"</p><p>That's the most important advice I can impart to help you learn JS. Always keep looking for better ways to use what JS gives us to author more readable code. Everyone who works on your code, including your future self, will thank you!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "With the Grain", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "I have some advice to share on continuing your learning journey with JS, and your path through the rest of this book series: be aware of the ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (recall various references to ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " earlier in this chapter).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "First, consider the ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (as in, wood) of how most people approach and use JS. You've probably already noticed that these books cut against that ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in many respects. In YDKJSY, I respect you the reader enough to explain all the parts of JS, not only some select popular parts. I believe you're both capable and deserving of that knowledge.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But that is not what you'll find from a lot of other material out there. It also means that the more you follow and adhere to the guidance from these books\u2014that you think carefully and analyze for yourself what's best in your code\u2014the more you will stand out. That can be a good and bad thing. If you ever want to break out from the crowd, you're going to have to break from how the crowd does it!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But I've also had many people tell me that they quoted some topic/explanation from these books during a job interview, and the interviewer told the candidate they were wrong; indeed, people have reportedly lost out on job offers as a result.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "As much as possible, I endeavor in these books to provide completely accurate information about JS, informed generally from the specification itself. But I also dose out quite a bit of my opinions on how you can interpret and use JS to the best benefit in your programs. I don't present opinion as fact, or vice versa. You'll always know which is which in these books.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Facts about JS are not really up for debate. Either the specification says something, or it doesn't. If you don't like what the specification says, or my relaying of it, take that up with TC39! If you're in an interview and they claim you're wrong on the facts, ask them right then and there if you can look it up in the specification. If the interviewer won't re-consider, then you shouldn't want to work there anyway.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But if you choose to align with my opinions, you have to be prepared to back up those choices with ", "type": "text"}, {"text": "why", "type": "text", "marks": [{"type": "italic"}]}, {"text": " you feel that way. Don't just parrot what I say. Own your opinions. Defend them. And if someone you were hoping to work with disagrees, walk away with your head still held high. It's a big JS, and there's plenty of room for lots of different ways.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In other words, don't be afraid to go against the ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", as I have done with these books and all my teachings. Nobody can tell you how you will best make use of JS; that's for you to decide. I'm merely trying to empower you in coming to your own conclusions, no matter what they are.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "On the other hand, there's a ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " you really should pay attention to and follow: the ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " of how JS works, at the language level. There are things that work well and naturally in JS, given the right practice and approach, and there are things you really shouldn't try to do in the language.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Can you make your JS program look like a Java, C#, or Perl program? What about Python or Ruby, or even PHP? To varying degrees, sure you can. But should you?", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "No, I don't think you should. I think you should learn and embrace the JS way, and make your JS programs as JS'y as is practical. Some will think that means sloppy and informal programming, but I don't mean that at all. I just mean that JS has a lot of patterns and idioms that are recognizably \"JS,\" and going with that ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " is the general path to the best success.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Finally, maybe the most important ", "type": "text"}, {"text": "grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to recognize is how the existing program(s) you're working on, and developers you're working with, do stuff. Don't read these books and then try to change ", "type": "text"}, {"text": "all that grain", "type": "text", "marks": [{"type": "italic"}]}, {"text": " in your existing projects over night. That approach will always fail.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You'll have to shift these things little by little, over time. Work on building consensus with your fellow developers on why it's important to re-visit and re-consider an approach. But do so with just one small topic at a time, and let before-and-after code comparisons do most of the talking. Bring everyone on the team together to discuss, and push for decisions that are based on analysis and evidence from the code rather than the inertia of \"our senior devs have always done it this way.\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's the most important advice I can impart to help you learn JS. Always keep looking for better ways to use what JS gives us to author more readable code. Everyone who works on your code, including your future self, will thank you!", "type": "text"}]}]}, "article_text": "With the Grain\n\nI have some advice to share on continuing your learning journey with JS, and your path through the rest of this book series: be aware of the grain (recall various references to grain earlier in this chapter).\n\nFirst, consider the grain (as in, wood) of how most people approach and use JS. You've probably already noticed that these books cut against that grain in many respects. In YDKJSY, I respect you the reader enough to explain all the parts of JS, not only some select popular parts. I believe you're both capable and deserving of that knowledge.\n\nBut that is not what you'll find from a lot of other material out there. It also means that the more you follow and adhere to the guidance from these books\u2014that you think carefully and analyze for yourself what's best in your code\u2014the more you will stand out. That can be a good and bad thing. If you ever want to break out from the crowd, you're going to have to break from how the crowd does it!\n\nBut I've also had many people tell me that they quoted some topic/explanation from these books during a job interview, and the interviewer told the candidate they were wrong; indeed, people have reportedly lost out on job offers as a result.\n\nAs much as possible, I endeavor in these books to provide completely accurate information about JS, informed generally from the specification itself. But I also dose out quite a bit of my opinions on how you can interpret and use JS to the best benefit in your programs. I don't present opinion as fact, or vice versa. You'll always know which is which in these books.\n\nFacts about JS are not really up for debate. Either the specification says something, or it doesn't. If you don't like what the specification says, or my relaying of it, take that up with TC39! If you're in an interview and they claim you're wrong on the facts, ask them right then and there if you can look it up in the specification. If the interviewer won't re-consider, then you shouldn't want to work there anyway.\n\nBut if you choose to align with my opinions, you have to be prepared to back up those choices with why you feel that way. Don't just parrot what I say. Own your opinions. Defend them. And if someone you were hoping to work with disagrees, walk away with your head still held high. It's a big JS, and there's plenty of room for lots of different ways.\n\nIn other words, don't be afraid to go against the grain, as I have done with these books and all my teachings. Nobody can tell you how you will best make use of JS; that's for you to decide. I'm merely trying to empower you in coming to your own conclusions, no matter what they are.\n\nOn the other hand, there's a grain you really should pay attention to and follow: the grain of how JS works, at the language level. There are things that work well and naturally in JS, given the right practice and approach, and there are things you really shouldn't try to do in the language.\n\nCan you make your JS program look like a Java, C#, or Perl program? What about Python or Ruby, or even PHP? To varying degrees, sure you can. But should you?\n\nNo, I don't think you should. I think you should learn and embrace the JS way, and make your JS programs as JS'y as is practical. Some will think that means sloppy and informal programming, but I don't mean that at all. I just mean that JS has a lot of patterns and idioms that are recognizably \"JS,\" and going with that grain is the general path to the best success.\n\nFinally, maybe the most important grain to recognize is how the existing program(s) you're working on, and developers you're working with, do stuff. Don't read these books and then try to change all that grain in your existing projects over night. That approach will always fail.\n\nYou'll have to shift these things little by little, over time. Work on building consensus with your fellow developers on why it's important to re-visit and re-consider an approach. But do so with just one small topic at a time, and let before-and-after code comparisons do most of the talking. Bring everyone on the team together to discuss, and push for decisions that are based on analysis and evidence from the code rather than the inertia of \"our senior devs have always done it this way.\"\n\nThat's the most important advice I can impart to help you learn JS. Always keep looking for better ways to use what JS gives us to author more readable code. Everyone who works on your code, including your future self, will thank you!"}, "id": 148}, {"data": {"uuid": "f70e4c46-38cc-4f36-b113-3fca997ab8d0", "user": 1, "title": "In Order", "author": "Kyle Simpson", "created_on": "2023-06-07 20:45:13.787942+00:00", "updated_on": "2023-06-07 20:48:38.133559+00:00", "article_html": "<h2>In Order</h2><p>So now you've got a broader perspective on what's left to explore in JS, and the right attitude to approach the rest of your journey.</p><p>But one of the most common practical questions I get at this point is, \"What order should I read the books?\" There is a straightforward answer... but it also depends.</p><p>My suggestion for most readers is to proceed through this series in this order:</p><ol><li><p>Get started with a solid foundation of JS from <em>Get Started</em> (Book 1) -- good news, you've already almost finished this book!</p></li><li><p>In <em>Scope &amp; Closures</em> (Book 2), dig into the first pillar of JS: lexical scope, how that supports closure, and how the module pattern organizes code.</p></li><li><p>In <em>Objects &amp; Classes</em> (Book 3), focus on the second pillar of JS: how JS's <code>this</code> works, how object prototypes support delegation, and how prototypes enable the <code>class</code> mechanism for OO-style code organization.</p></li><li><p>In <em>Types &amp; Grammar</em> (Book 4), tackle the third and final pillar of JS: types and type coercion, as well as how JS's syntax and grammar define how we write our code.</p></li><li><p>With the <strong>three pillars</strong> solidly in place, <em>Sync &amp; Async</em> (Book 5) then explores how we use flow control to model state change in our programs, both synchronously (right away) and asynchronously (over time).</p></li><li><p>The series concludes with <em>ES.Next &amp; Beyond</em> (Book 6), a forward look at the near- and mid-term future of JS, including a variety of features likely coming to your JS programs before too long.</p></li></ol><p>That's the intended order to read this book series.</p><p>However, Books 2, 3, and 4 can generally be read in any order, depending on which topic you feel most curious about and comfortable exploring first. But I don't recommend you skip any of these three books\u2014not even <em>Types &amp; Grammar</em>, as some of you will be tempted to do!\u2014even if you think you already have that topic down.</p><p>Book 5 (<em>Sync &amp; Async</em>) is crucial for deeply understanding JS, but if you start digging in and find it's too intimidating, this book can be deferred until you're more experienced with the language. The more JS you've written (and struggled with!), the more you'll come to appreciate this book. So don't be afraid to come back to it at a later time.</p><p>The final book in the series, <em>ES.Next &amp; Beyond</em>, in some respects stands alone. It can be read at the end, as I suggest, or right after <em>Getting Started</em> if you're looking for a shortcut to broaden your radar of what JS is all about. This book will also be more likely to receive updates in the future, so you'll probably want to re-visit it occasionally.</p><p>However you choose to proceed with YDKJSY, check out the appendices of this book first, especially practicing the snippets in Appendix B, \"Practice, Practice, Practice!\" Did I mention you should go practice!? There's no better way to learn code than to write it.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "In Order", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So now you've got a broader perspective on what's left to explore in JS, and the right attitude to approach the rest of your journey.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "But one of the most common practical questions I get at this point is, \"What order should I read the books?\" There is a straightforward answer... but it also depends.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "My suggestion for most readers is to proceed through this series in this order:", "type": "text"}]}, {"type": "orderedList", "attrs": {"start": 1}, "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Get started with a solid foundation of JS from ", "type": "text"}, {"text": "Get Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (Book 1) -- good news, you've already almost finished this book!", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "In ", "type": "text"}, {"text": "Scope & Closures", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (Book 2), dig into the first pillar of JS: lexical scope, how that supports closure, and how the module pattern organizes code.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "In ", "type": "text"}, {"text": "Objects & Classes", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (Book 3), focus on the second pillar of JS: how JS's ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " works, how object prototypes support delegation, and how prototypes enable the ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " mechanism for OO-style code organization.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "In ", "type": "text"}, {"text": "Types & Grammar", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (Book 4), tackle the third and final pillar of JS: types and type coercion, as well as how JS's syntax and grammar define how we write our code.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "With the ", "type": "text"}, {"text": "three pillars", "type": "text", "marks": [{"type": "bold"}]}, {"text": " solidly in place, ", "type": "text"}, {"text": "Sync & Async", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (Book 5) then explores how we use flow control to model state change in our programs, both synchronously (right away) and asynchronously (over time).", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "The series concludes with ", "type": "text"}, {"text": "ES.Next & Beyond", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (Book 6), a forward look at the near- and mid-term future of JS, including a variety of features likely coming to your JS programs before too long.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "That's the intended order to read this book series.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However, Books 2, 3, and 4 can generally be read in any order, depending on which topic you feel most curious about and comfortable exploring first. But I don't recommend you skip any of these three books\u2014not even ", "type": "text"}, {"text": "Types & Grammar", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", as some of you will be tempted to do!\u2014even if you think you already have that topic down.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Book 5 (", "type": "text"}, {"text": "Sync & Async", "type": "text", "marks": [{"type": "italic"}]}, {"text": ") is crucial for deeply understanding JS, but if you start digging in and find it's too intimidating, this book can be deferred until you're more experienced with the language. The more JS you've written (and struggled with!), the more you'll come to appreciate this book. So don't be afraid to come back to it at a later time.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The final book in the series, ", "type": "text"}, {"text": "ES.Next & Beyond", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", in some respects stands alone. It can be read at the end, as I suggest, or right after ", "type": "text"}, {"text": "Getting Started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " if you're looking for a shortcut to broaden your radar of what JS is all about. This book will also be more likely to receive updates in the future, so you'll probably want to re-visit it occasionally.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "However you choose to proceed with YDKJSY, check out the appendices of this book first, especially practicing the snippets in Appendix B, \"Practice, Practice, Practice!\" Did I mention you should go practice!? There's no better way to learn code than to write it.", "type": "text"}]}]}, "article_text": "In Order\n\nSo now you've got a broader perspective on what's left to explore in JS, and the right attitude to approach the rest of your journey.\n\nBut one of the most common practical questions I get at this point is, \"What order should I read the books?\" There is a straightforward answer... but it also depends.\n\nMy suggestion for most readers is to proceed through this series in this order:\n\nGet started with a solid foundation of JS from Get Started (Book 1) -- good news, you've already almost finished this book!\n\nIn Scope & Closures (Book 2), dig into the first pillar of JS: lexical scope, how that supports closure, and how the module pattern organizes code.\n\nIn Objects & Classes (Book 3), focus on the second pillar of JS: how JS's this works, how object prototypes support delegation, and how prototypes enable the class mechanism for OO-style code organization.\n\nIn Types & Grammar (Book 4), tackle the third and final pillar of JS: types and type coercion, as well as how JS's syntax and grammar define how we write our code.\n\nWith the three pillars solidly in place, Sync & Async (Book 5) then explores how we use flow control to model state change in our programs, both synchronously (right away) and asynchronously (over time).\n\nThe series concludes with ES.Next & Beyond (Book 6), a forward look at the near- and mid-term future of JS, including a variety of features likely coming to your JS programs before too long.\n\nThat's the intended order to read this book series.\n\nHowever, Books 2, 3, and 4 can generally be read in any order, depending on which topic you feel most curious about and comfortable exploring first. But I don't recommend you skip any of these three books\u2014not even Types & Grammar, as some of you will be tempted to do!\u2014even if you think you already have that topic down.\n\nBook 5 (Sync & Async) is crucial for deeply understanding JS, but if you start digging in and find it's too intimidating, this book can be deferred until you're more experienced with the language. The more JS you've written (and struggled with!), the more you'll come to appreciate this book. So don't be afraid to come back to it at a later time.\n\nThe final book in the series, ES.Next & Beyond, in some respects stands alone. It can be read at the end, as I suggest, or right after Getting Started if you're looking for a shortcut to broaden your radar of what JS is all about. This book will also be more likely to receive updates in the future, so you'll probably want to re-visit it occasionally.\n\nHowever you choose to proceed with YDKJSY, check out the appendices of this book first, especially practicing the snippets in Appendix B, \"Practice, Practice, Practice!\" Did I mention you should go practice!? There's no better way to learn code than to write it."}, "id": 149}]}, {"data": {"uuid": "21f3532f-c9e0-4866-b5d7-13c2b9455c7f", "user": 1, "title": "Appendix A: Exploring Further", "author": "Kyle Simpson", "created_on": "2023-06-07 20:50:12.748724+00:00", "updated_on": "2023-06-07 20:50:30.290648+00:00", "article_html": "<h1>Appendix A: Exploring Further</h1><p>In this appendix, we're going to explore some topics from the main chapter text in a bit more detail. Think of this content as an optional preview of some of the more nuanced details covered throughout the rest of the book series.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Appendix A: Exploring Further", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this appendix, we're going to explore some topics from the main chapter text in a bit more detail. Think of this content as an optional preview of some of the more nuanced details covered throughout the rest of the book series.", "type": "text"}]}]}, "article_text": "Appendix A: Exploring Further\n\nIn this appendix, we're going to explore some topics from the main chapter text in a bit more detail. Think of this content as an optional preview of some of the more nuanced details covered throughout the rest of the book series."}, "id": 150, "children": [{"data": {"uuid": "a37ec14d-46be-4c63-8433-7e16a8e3ca0b", "user": 1, "title": "Values vs. References", "author": "Kyle Simpson", "created_on": "2023-06-07 20:50:47.045563+00:00", "updated_on": "2023-06-07 20:51:09.779020+00:00", "article_html": "<h2>Values vs. References</h2><p>In Chapter 2, we introduced the two main types of values: primitives and objects. But we didn't discuss yet one key difference between the two: how these values are assigned and passed around.</p><p>In many languages, the developer can choose between assigning/passing a value as the value itself, or as a reference to the value. In JS, however, this decision is entirely determined by the kind of value. That surprises a lot of developers from other languages when they start using JS.</p><p>If you assign/pass a value itself, the value is copied. For example:</p><pre><code>var myName = \"Kyle\";\n\nvar yourName = myName;</code></pre><p>Here, the <code>yourName</code> variable has a separate copy of the <code>\"Kyle\"</code> string from the value that's stored in <code>myName</code>. That's because the value is a primitive, and primitive values are always assigned/passed as <strong>value copies</strong>.</p><p>Here's how you can prove there's two separate values involved:</p><pre><code>var myName = \"Kyle\";\n\nvar yourName = myName;\n\nmyName = \"Frank\";\n\nconsole.log(myName);\n// Frank\n\nconsole.log(yourName);\n// Kyle</code></pre><p>See how <code>yourName</code> wasn't affected by the re-assignment of <code>myName</code> to <code>\"Frank\"</code>? That's because each variable holds its own copy of the value.</p><p>By contrast, references are the idea that two or more variables are pointing at the same value, such that modifying this shared value would be reflected by access via any of those references. In JS, only object values (arrays, objects, functions, etc.) are treated as references.</p><p>Consider:</p><pre><code>var myAddress = {\n    street: \"123 JS Blvd\",\n    city: \"Austin\",\n    state: \"TX\"\n};\n\nvar yourAddress = myAddress;\n\n// I've got to move to a new house!\nmyAddress.street = \"456 TS Ave\";\n\nconsole.log(yourAddress.street);\n// 456 TS Ave</code></pre><p>Because the value assigned to <code>myAddress</code> is an object, it's held/assigned by reference, and thus the assignment to the <code>yourAddress</code> variable is a copy of the reference, not the object value itself. That's why the updated value assigned to the <code>myAddress.street</code> is reflected when we access <code>yourAddress.street</code>. <code>myAddress</code> and <code>yourAddress</code> have copies of the reference to the single shared object, so an update to one is an update to both.</p><p>Again, JS chooses the value-copy vs. reference-copy behavior based on the value type. Primitives are held by value, objects are held by reference. There's no way to override this in JS, in either direction.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Values vs. References", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Chapter 2, we introduced the two main types of values: primitives and objects. But we didn't discuss yet one key difference between the two: how these values are assigned and passed around.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In many languages, the developer can choose between assigning/passing a value as the value itself, or as a reference to the value. In JS, however, this decision is entirely determined by the kind of value. That surprises a lot of developers from other languages when they start using JS.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If you assign/pass a value itself, the value is copied. For example:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var myName = \"Kyle\";\n\nvar yourName = myName;", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, the ", "type": "text"}, {"text": "yourName", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable has a separate copy of the ", "type": "text"}, {"text": "\"Kyle\"", "type": "text", "marks": [{"type": "code"}]}, {"text": " string from the value that's stored in ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": ". That's because the value is a primitive, and primitive values are always assigned/passed as ", "type": "text"}, {"text": "value copies", "type": "text", "marks": [{"type": "bold"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here's how you can prove there's two separate values involved:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var myName = \"Kyle\";\n\nvar yourName = myName;\n\nmyName = \"Frank\";\n\nconsole.log(myName);\n// Frank\n\nconsole.log(yourName);\n// Kyle", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "See how ", "type": "text"}, {"text": "yourName", "type": "text", "marks": [{"type": "code"}]}, {"text": " wasn't affected by the re-assignment of ", "type": "text"}, {"text": "myName", "type": "text", "marks": [{"type": "code"}]}, {"text": " to ", "type": "text"}, {"text": "\"Frank\"", "type": "text", "marks": [{"type": "code"}]}, {"text": "? That's because each variable holds its own copy of the value.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "By contrast, references are the idea that two or more variables are pointing at the same value, such that modifying this shared value would be reflected by access via any of those references. In JS, only object values (arrays, objects, functions, etc.) are treated as references.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var myAddress = {\n    street: \"123 JS Blvd\",\n    city: \"Austin\",\n    state: \"TX\"\n};\n\nvar yourAddress = myAddress;\n\n// I've got to move to a new house!\nmyAddress.street = \"456 TS Ave\";\n\nconsole.log(yourAddress.street);\n// 456 TS Ave", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Because the value assigned to ", "type": "text"}, {"text": "myAddress", "type": "text", "marks": [{"type": "code"}]}, {"text": " is an object, it's held/assigned by reference, and thus the assignment to the ", "type": "text"}, {"text": "yourAddress", "type": "text", "marks": [{"type": "code"}]}, {"text": " variable is a copy of the reference, not the object value itself. That's why the updated value assigned to the ", "type": "text"}, {"text": "myAddress.street", "type": "text", "marks": [{"type": "code"}]}, {"text": " is reflected when we access ", "type": "text"}, {"text": "yourAddress.street", "type": "text", "marks": [{"type": "code"}]}, {"text": ". ", "type": "text"}, {"text": "myAddress", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "yourAddress", "type": "text", "marks": [{"type": "code"}]}, {"text": " have copies of the reference to the single shared object, so an update to one is an update to both.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Again, JS chooses the value-copy vs. reference-copy behavior based on the value type. Primitives are held by value, objects are held by reference. There's no way to override this in JS, in either direction.", "type": "text"}]}]}, "article_text": "Values vs. References\n\nIn Chapter 2, we introduced the two main types of values: primitives and objects. But we didn't discuss yet one key difference between the two: how these values are assigned and passed around.\n\nIn many languages, the developer can choose between assigning/passing a value as the value itself, or as a reference to the value. In JS, however, this decision is entirely determined by the kind of value. That surprises a lot of developers from other languages when they start using JS.\n\nIf you assign/pass a value itself, the value is copied. For example:\n\nvar myName = \"Kyle\";\n\nvar yourName = myName;\n\nHere, the yourName variable has a separate copy of the \"Kyle\" string from the value that's stored in myName. That's because the value is a primitive, and primitive values are always assigned/passed as value copies.\n\nHere's how you can prove there's two separate values involved:\n\nvar myName = \"Kyle\";\n\nvar yourName = myName;\n\nmyName = \"Frank\";\n\nconsole.log(myName);\n// Frank\n\nconsole.log(yourName);\n// Kyle\n\nSee how yourName wasn't affected by the re-assignment of myName to \"Frank\"? That's because each variable holds its own copy of the value.\n\nBy contrast, references are the idea that two or more variables are pointing at the same value, such that modifying this shared value would be reflected by access via any of those references. In JS, only object values (arrays, objects, functions, etc.) are treated as references.\n\nConsider:\n\nvar myAddress = {\n    street: \"123 JS Blvd\",\n    city: \"Austin\",\n    state: \"TX\"\n};\n\nvar yourAddress = myAddress;\n\n// I've got to move to a new house!\nmyAddress.street = \"456 TS Ave\";\n\nconsole.log(yourAddress.street);\n// 456 TS Ave\n\nBecause the value assigned to myAddress is an object, it's held/assigned by reference, and thus the assignment to the yourAddress variable is a copy of the reference, not the object value itself. That's why the updated value assigned to the myAddress.street is reflected when we access yourAddress.street. myAddress and yourAddress have copies of the reference to the single shared object, so an update to one is an update to both.\n\nAgain, JS chooses the value-copy vs. reference-copy behavior based on the value type. Primitives are held by value, objects are held by reference. There's no way to override this in JS, in either direction."}, "id": 151}, {"data": {"uuid": "d33bbb55-d830-4691-a64f-46a3281df13f", "user": 1, "title": "So Many Function Forms", "author": "Kyle Simpson", "created_on": "2023-06-07 20:51:34.086908+00:00", "updated_on": "2023-06-07 20:52:07.866139+00:00", "article_html": "<h2>So Many Function Forms</h2><p>Recall this snippet from the \"Functions\" section in Chapter 2:</p><pre><code>var awesomeFunction = function(coolThings) {\n    // ..\n    return amazingStuff;\n};</code></pre><p>The function expression here is referred to as an <em>anonymous function expression</em>, since it has no name identifier between the <code>function</code> keyword and the <code>(..)</code> parameter list. This point confuses many JS developers because as of ES6, JS performs a \"name inference\" on an anonymous function:</p><pre><code>awesomeFunction.name;\n// \"awesomeFunction\"</code></pre><p>The <code>name</code> property of a function will reveal either its directly given name (in the case of a declaration) or its inferred name in the case of an anonymous function expression. That value is generally used by developer tools when inspecting a function value or when reporting an error stack trace.</p><p>So even an anonymous function expression <em>might</em> get a name. However, name inference only happens in limited cases such as when the function expression is assigned (with <code>=</code>). If you pass a function expression as an argument to a function call, for example, no name inference occurs; the <code>name</code> property will be an empty string, and the developer console will usually report \"(anonymous function)\".</p><p>Even if a name is inferred, <strong>it's still an anonymous function.</strong> Why? Because the inferred name is a metadata string value, not an available identifier to refer to the function. An anonymous function doesn't have an identifier to use to refer to itself from inside itself\u2014for recursion, event unbinding, etc.</p><p>Compare the anonymous function expression form to:</p><pre><code>// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function someName(coolThings) {\n    // ..\n    return amazingStuff;\n};\n\nawesomeFunction.name;\n// \"someName\"</code></pre><p>This function expression is a <em>named function expression</em>, since the identifier <code>someName</code> is directly associated with the function expression at compile time; the association with the identifier <code>awesomeFunction</code> still doesn't happen until runtime at the time of that statement. Those two identifiers don't have to match; sometimes it makes sense to have them be different, other times it's better to have them be the same.</p><p>Notice also that the explicit function name, the identifier <code>someName</code>, takes precedence when assigning a <em>name</em> for the <code>name</code> property.</p><p>Should function expressions be named or anonymous? Opinions vary widely on this. Most developers tend to be unconcerned with using anonymous functions. They're shorter, and unquestionably more common in the broad sphere of JS code out there.</p><p>In my opinion, if a function exists in your program, it has a purpose; otherwise, take it out! And if it has a purpose, it has a natural name that describes that purpose.</p><p>If a function has a name, you the code author should include that name in the code, so that the reader does not have to infer that name from reading and mentally executing that function's source code. Even a trivial function body like <code>x * 2</code> has to be read to infer a name like \"double\" or \"multBy2\"; that brief extra mental work is unnecessary when you could just take a second to name the function \"double\" or \"multBy2\" <em>once</em>, saving the reader that repeated mental work every time it's read in the future.</p><p>There are, regrettably in some respects, many other function definition forms in JS as of early 2020 (maybe more in the future!).</p><p>Here are some more declaration forms:</p><pre><code>// generator function declaration\nfunction *two() { .. }\n\n// async function declaration\nasync function three() { .. }\n\n// async generator function declaration\nasync function *four() { .. }\n\n// named function export declaration (ES6 modules)\nexport function five() { .. }</code></pre><p>And here are some more of the (many!) function expression forms:</p><pre><code>// IIFE\n(function(){ .. })();\n(function namedIIFE(){ .. })();\n\n// asynchronous IIFE\n(async function(){ .. })();\n(async function namedAIIFE(){ .. })();\n\n// arrow function expressions\nvar f;\nf = () =&gt; 42;\nf = x =&gt; x * 2;\nf = (x) =&gt; x * 2;\nf = (x,y) =&gt; x * y;\nf = x =&gt; ({ x: x * 2 });\nf = x =&gt; { return x * 2; };\nf = async x =&gt; {\n    var y = await doSomethingAsync(x);\n    return y * 2;\n};\nsomeOperation( x =&gt; x * 2 );\n// ..</code></pre><p>Keep in mind that arrow function expressions are <strong>syntactically anonymous</strong>, meaning the syntax doesn't provide a way to provide a direct name identifier for the function. The function expression may get an inferred name, but only if it's one of the assignment forms, not in the (more common!) form of being passed as a function call argument (as in the last line of the snippet).</p><p>Since I don't think anonymous functions are a good idea to use frequently in your programs, I'm not a fan of using the <code>=&gt;</code> arrow function form. This kind of function actually has a specific purpose (i.e., handling the <code>this</code> keyword lexically), but that doesn't mean we should use it for every function we write. Use the most appropriate tool for each job.</p><p>Functions can also be specified in class definitions and object literal definitions. They're typically referred to as \"methods\" when in these forms, though in JS this term doesn't have much observable difference over \"function\":</p><pre><code>class SomethingKindaGreat {\n    // class methods\n    coolMethod() { .. }   // no commas!\n    boringMethod() { .. }\n}\n\nvar EntirelyDifferent = {\n    // object methods\n    coolMethod() { .. },   // commas!\n    boringMethod() { .. },\n\n    // (anonymous) function expression property\n    oldSchool: function() { .. }\n};</code></pre><p>Phew! That's a lot of different ways to define functions.</p><p>There's no simple shortcut path here; you just have to build familiarity with all the function forms so you can recognize them in existing code and use them appropriately in the code you write. Study them closely and practice!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "So Many Function Forms", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Recall this snippet from the \"Functions\" section in Chapter 2:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var awesomeFunction = function(coolThings) {\n    // ..\n    return amazingStuff;\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The function expression here is referred to as an ", "type": "text"}, {"text": "anonymous function expression", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", since it has no name identifier between the ", "type": "text"}, {"text": "function", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword and the ", "type": "text"}, {"text": "(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " parameter list. This point confuses many JS developers because as of ES6, JS performs a \"name inference\" on an anonymous function:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "awesomeFunction.name;\n// \"awesomeFunction\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " property of a function will reveal either its directly given name (in the case of a declaration) or its inferred name in the case of an anonymous function expression. That value is generally used by developer tools when inspecting a function value or when reporting an error stack trace.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "So even an anonymous function expression ", "type": "text"}, {"text": "might", "type": "text", "marks": [{"type": "italic"}]}, {"text": " get a name. However, name inference only happens in limited cases such as when the function expression is assigned (with ", "type": "text"}, {"text": "=", "type": "text", "marks": [{"type": "code"}]}, {"text": "). If you pass a function expression as an argument to a function call, for example, no name inference occurs; the ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " property will be an empty string, and the developer console will usually report \"(anonymous function)\".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Even if a name is inferred, ", "type": "text"}, {"text": "it's still an anonymous function.", "type": "text", "marks": [{"type": "bold"}]}, {"text": " Why? Because the inferred name is a metadata string value, not an available identifier to refer to the function. An anonymous function doesn't have an identifier to use to refer to itself from inside itself\u2014for recursion, event unbinding, etc.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Compare the anonymous function expression form to:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function someName(coolThings) {\n    // ..\n    return amazingStuff;\n};\n\nawesomeFunction.name;\n// \"someName\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This function expression is a ", "type": "text"}, {"text": "named function expression", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", since the identifier ", "type": "text"}, {"text": "someName", "type": "text", "marks": [{"type": "code"}]}, {"text": " is directly associated with the function expression at compile time; the association with the identifier ", "type": "text"}, {"text": "awesomeFunction", "type": "text", "marks": [{"type": "code"}]}, {"text": " still doesn't happen until runtime at the time of that statement. Those two identifiers don't have to match; sometimes it makes sense to have them be different, other times it's better to have them be the same.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Notice also that the explicit function name, the identifier ", "type": "text"}, {"text": "someName", "type": "text", "marks": [{"type": "code"}]}, {"text": ", takes precedence when assigning a ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "italic"}]}, {"text": " for the ", "type": "text"}, {"text": "name", "type": "text", "marks": [{"type": "code"}]}, {"text": " property.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Should function expressions be named or anonymous? Opinions vary widely on this. Most developers tend to be unconcerned with using anonymous functions. They're shorter, and unquestionably more common in the broad sphere of JS code out there.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In my opinion, if a function exists in your program, it has a purpose; otherwise, take it out! And if it has a purpose, it has a natural name that describes that purpose.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "If a function has a name, you the code author should include that name in the code, so that the reader does not have to infer that name from reading and mentally executing that function's source code. Even a trivial function body like ", "type": "text"}, {"text": "x * 2", "type": "text", "marks": [{"type": "code"}]}, {"text": " has to be read to infer a name like \"double\" or \"multBy2\"; that brief extra mental work is unnecessary when you could just take a second to name the function \"double\" or \"multBy2\" ", "type": "text"}, {"text": "once", "type": "text", "marks": [{"type": "italic"}]}, {"text": ", saving the reader that repeated mental work every time it's read in the future.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There are, regrettably in some respects, many other function definition forms in JS as of early 2020 (maybe more in the future!).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here are some more declaration forms:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// generator function declaration\nfunction *two() { .. }\n\n// async function declaration\nasync function three() { .. }\n\n// async generator function declaration\nasync function *four() { .. }\n\n// named function export declaration (ES6 modules)\nexport function five() { .. }", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "And here are some more of the (many!) function expression forms:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "// IIFE\n(function(){ .. })();\n(function namedIIFE(){ .. })();\n\n// asynchronous IIFE\n(async function(){ .. })();\n(async function namedAIIFE(){ .. })();\n\n// arrow function expressions\nvar f;\nf = () => 42;\nf = x => x * 2;\nf = (x) => x * 2;\nf = (x,y) => x * y;\nf = x => ({ x: x * 2 });\nf = x => { return x * 2; };\nf = async x => {\n    var y = await doSomethingAsync(x);\n    return y * 2;\n};\nsomeOperation( x => x * 2 );\n// ..", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Keep in mind that arrow function expressions are ", "type": "text"}, {"text": "syntactically anonymous", "type": "text", "marks": [{"type": "bold"}]}, {"text": ", meaning the syntax doesn't provide a way to provide a direct name identifier for the function. The function expression may get an inferred name, but only if it's one of the assignment forms, not in the (more common!) form of being passed as a function call argument (as in the last line of the snippet).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since I don't think anonymous functions are a good idea to use frequently in your programs, I'm not a fan of using the ", "type": "text"}, {"text": "=>", "type": "text", "marks": [{"type": "code"}]}, {"text": " arrow function form. This kind of function actually has a specific purpose (i.e., handling the ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " keyword lexically), but that doesn't mean we should use it for every function we write. Use the most appropriate tool for each job.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Functions can also be specified in class definitions and object literal definitions. They're typically referred to as \"methods\" when in these forms, though in JS this term doesn't have much observable difference over \"function\":", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "class SomethingKindaGreat {\n    // class methods\n    coolMethod() { .. }   // no commas!\n    boringMethod() { .. }\n}\n\nvar EntirelyDifferent = {\n    // object methods\n    coolMethod() { .. },   // commas!\n    boringMethod() { .. },\n\n    // (anonymous) function expression property\n    oldSchool: function() { .. }\n};", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Phew! That's a lot of different ways to define functions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "There's no simple shortcut path here; you just have to build familiarity with all the function forms so you can recognize them in existing code and use them appropriately in the code you write. Study them closely and practice!", "type": "text"}]}]}, "article_text": "So Many Function Forms\n\nRecall this snippet from the \"Functions\" section in Chapter 2:\n\nvar awesomeFunction = function(coolThings) {\n    // ..\n    return amazingStuff;\n};\n\nThe function expression here is referred to as an anonymous function expression, since it has no name identifier between the function keyword and the (..) parameter list. This point confuses many JS developers because as of ES6, JS performs a \"name inference\" on an anonymous function:\n\nawesomeFunction.name;\n// \"awesomeFunction\"\n\nThe name property of a function will reveal either its directly given name (in the case of a declaration) or its inferred name in the case of an anonymous function expression. That value is generally used by developer tools when inspecting a function value or when reporting an error stack trace.\n\nSo even an anonymous function expression might get a name. However, name inference only happens in limited cases such as when the function expression is assigned (with =). If you pass a function expression as an argument to a function call, for example, no name inference occurs; the name property will be an empty string, and the developer console will usually report \"(anonymous function)\".\n\nEven if a name is inferred, it's still an anonymous function. Why? Because the inferred name is a metadata string value, not an available identifier to refer to the function. An anonymous function doesn't have an identifier to use to refer to itself from inside itself\u2014for recursion, event unbinding, etc.\n\nCompare the anonymous function expression form to:\n\n// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function someName(coolThings) {\n    // ..\n    return amazingStuff;\n};\n\nawesomeFunction.name;\n// \"someName\"\n\nThis function expression is a named function expression, since the identifier someName is directly associated with the function expression at compile time; the association with the identifier awesomeFunction still doesn't happen until runtime at the time of that statement. Those two identifiers don't have to match; sometimes it makes sense to have them be different, other times it's better to have them be the same.\n\nNotice also that the explicit function name, the identifier someName, takes precedence when assigning a name for the name property.\n\nShould function expressions be named or anonymous? Opinions vary widely on this. Most developers tend to be unconcerned with using anonymous functions. They're shorter, and unquestionably more common in the broad sphere of JS code out there.\n\nIn my opinion, if a function exists in your program, it has a purpose; otherwise, take it out! And if it has a purpose, it has a natural name that describes that purpose.\n\nIf a function has a name, you the code author should include that name in the code, so that the reader does not have to infer that name from reading and mentally executing that function's source code. Even a trivial function body like x * 2 has to be read to infer a name like \"double\" or \"multBy2\"; that brief extra mental work is unnecessary when you could just take a second to name the function \"double\" or \"multBy2\" once, saving the reader that repeated mental work every time it's read in the future.\n\nThere are, regrettably in some respects, many other function definition forms in JS as of early 2020 (maybe more in the future!).\n\nHere are some more declaration forms:\n\n// generator function declaration\nfunction *two() { .. }\n\n// async function declaration\nasync function three() { .. }\n\n// async generator function declaration\nasync function *four() { .. }\n\n// named function export declaration (ES6 modules)\nexport function five() { .. }\n\nAnd here are some more of the (many!) function expression forms:\n\n// IIFE\n(function(){ .. })();\n(function namedIIFE(){ .. })();\n\n// asynchronous IIFE\n(async function(){ .. })();\n(async function namedAIIFE(){ .. })();\n\n// arrow function expressions\nvar f;\nf = () => 42;\nf = x => x * 2;\nf = (x) => x * 2;\nf = (x,y) => x * y;\nf = x => ({ x: x * 2 });\nf = x => { return x * 2; };\nf = async x => {\n    var y = await doSomethingAsync(x);\n    return y * 2;\n};\nsomeOperation( x => x * 2 );\n// ..\n\nKeep in mind that arrow function expressions are syntactically anonymous, meaning the syntax doesn't provide a way to provide a direct name identifier for the function. The function expression may get an inferred name, but only if it's one of the assignment forms, not in the (more common!) form of being passed as a function call argument (as in the last line of the snippet).\n\nSince I don't think anonymous functions are a good idea to use frequently in your programs, I'm not a fan of using the => arrow function form. This kind of function actually has a specific purpose (i.e., handling the this keyword lexically), but that doesn't mean we should use it for every function we write. Use the most appropriate tool for each job.\n\nFunctions can also be specified in class definitions and object literal definitions. They're typically referred to as \"methods\" when in these forms, though in JS this term doesn't have much observable difference over \"function\":\n\nclass SomethingKindaGreat {\n    // class methods\n    coolMethod() { .. }   // no commas!\n    boringMethod() { .. }\n}\n\nvar EntirelyDifferent = {\n    // object methods\n    coolMethod() { .. },   // commas!\n    boringMethod() { .. },\n\n    // (anonymous) function expression property\n    oldSchool: function() { .. }\n};\n\nPhew! That's a lot of different ways to define functions.\n\nThere's no simple shortcut path here; you just have to build familiarity with all the function forms so you can recognize them in existing code and use them appropriately in the code you write. Study them closely and practice!"}, "id": 152}, {"data": {"uuid": "8b01ede6-d598-4a85-9142-9235989d8156", "user": 1, "title": "Coercive Conditional Comparison", "author": "Kyle Simpson", "created_on": "2023-06-07 20:52:25.889545+00:00", "updated_on": "2023-06-07 20:52:52.096210+00:00", "article_html": "<h2>Coercive Conditional Comparison</h2><p>Yes, that section name is quite a mouthful. But what are we talking about? We're talking about conditional expressions needing to perform coercion-oriented comparisons to make their decisions.</p><p><code>if</code> and <code>? :</code>-ternary statements, as well as the test clauses in <code>while</code> and <code>for</code> loops, all perform an implicit value comparison. But what sort? Is it \"strict\" or \"coercive\"? Both, actually.</p><p>Consider:</p><pre><code>var x = 1;\n\nif (x) {\n    // will run!\n}\n\nwhile (x) {\n    // will run, once!\n    x = false;\n}</code></pre><p>You might think of these <code>(x)</code> conditional expressions like this:</p><pre><code>var x = 1;\n\nif (x == true) {\n    // will run!\n}\n\nwhile (x == true) {\n    // will run, once!\n    x = false;\n}</code></pre><p>In this specific case -- the value of <code>x</code> being <code>1</code> -- that mental model works, but it's not accurate more broadly. Consider:</p><pre><code>var x = \"hello\";\n\nif (x) {\n    // will run!\n}\n\nif (x == true) {\n    // won't run :(\n}</code></pre><p>Oops. So what is the <code>if</code> statement actually doing? This is the more accurate mental model:</p><pre><code>var x = \"hello\";\n\nif (Boolean(x) == true) {\n    // will run\n}\n\n// which is the same as:\n\nif (Boolean(x) === true) {\n    // will run\n}</code></pre><p>Since the <code>Boolean(..)</code> function always returns a value of type boolean, the <code>==</code> vs <code>===</code> in this snippet is irrelevant; they'll both do the same thing. But the important part is to see that before the comparison, a coercion occurs, from whatever type <code>x</code> currently is, to boolean.</p><p>You just can't get away from coercions in JS comparisons. Buckle down and learn them.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Coercive Conditional Comparison", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Yes, that section name is quite a mouthful. But what are we talking about? We're talking about conditional expressions needing to perform coercion-oriented comparisons to make their decisions.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "? :", "type": "text", "marks": [{"type": "code"}]}, {"text": "-ternary statements, as well as the test clauses in ", "type": "text"}, {"text": "while", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "for", "type": "text", "marks": [{"type": "code"}]}, {"text": " loops, all perform an implicit value comparison. But what sort? Is it \"strict\" or \"coercive\"? Both, actually.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var x = 1;\n\nif (x) {\n    // will run!\n}\n\nwhile (x) {\n    // will run, once!\n    x = false;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You might think of these ", "type": "text"}, {"text": "(x)", "type": "text", "marks": [{"type": "code"}]}, {"text": " conditional expressions like this:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var x = 1;\n\nif (x == true) {\n    // will run!\n}\n\nwhile (x == true) {\n    // will run, once!\n    x = false;\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this specific case -- the value of ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": " being ", "type": "text"}, {"text": "1", "type": "text", "marks": [{"type": "code"}]}, {"text": " -- that mental model works, but it's not accurate more broadly. Consider:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var x = \"hello\";\n\nif (x) {\n    // will run!\n}\n\nif (x == true) {\n    // won't run :(\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Oops. So what is the ", "type": "text"}, {"text": "if", "type": "text", "marks": [{"type": "code"}]}, {"text": " statement actually doing? This is the more accurate mental model:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var x = \"hello\";\n\nif (Boolean(x) == true) {\n    // will run\n}\n\n// which is the same as:\n\nif (Boolean(x) === true) {\n    // will run\n}", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Since the ", "type": "text"}, {"text": "Boolean(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function always returns a value of type boolean, the ", "type": "text"}, {"text": "==", "type": "text", "marks": [{"type": "code"}]}, {"text": " vs ", "type": "text"}, {"text": "===", "type": "text", "marks": [{"type": "code"}]}, {"text": " in this snippet is irrelevant; they'll both do the same thing. But the important part is to see that before the comparison, a coercion occurs, from whatever type ", "type": "text"}, {"text": "x", "type": "text", "marks": [{"type": "code"}]}, {"text": " currently is, to boolean.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "You just can't get away from coercions in JS comparisons. Buckle down and learn them.", "type": "text"}]}]}, "article_text": "Coercive Conditional Comparison\n\nYes, that section name is quite a mouthful. But what are we talking about? We're talking about conditional expressions needing to perform coercion-oriented comparisons to make their decisions.\n\nif and ? :-ternary statements, as well as the test clauses in while and for loops, all perform an implicit value comparison. But what sort? Is it \"strict\" or \"coercive\"? Both, actually.\n\nConsider:\n\nvar x = 1;\n\nif (x) {\n    // will run!\n}\n\nwhile (x) {\n    // will run, once!\n    x = false;\n}\n\nYou might think of these (x) conditional expressions like this:\n\nvar x = 1;\n\nif (x == true) {\n    // will run!\n}\n\nwhile (x == true) {\n    // will run, once!\n    x = false;\n}\n\nIn this specific case -- the value of x being 1 -- that mental model works, but it's not accurate more broadly. Consider:\n\nvar x = \"hello\";\n\nif (x) {\n    // will run!\n}\n\nif (x == true) {\n    // won't run :(\n}\n\nOops. So what is the if statement actually doing? This is the more accurate mental model:\n\nvar x = \"hello\";\n\nif (Boolean(x) == true) {\n    // will run\n}\n\n// which is the same as:\n\nif (Boolean(x) === true) {\n    // will run\n}\n\nSince the Boolean(..) function always returns a value of type boolean, the == vs === in this snippet is irrelevant; they'll both do the same thing. But the important part is to see that before the comparison, a coercion occurs, from whatever type x currently is, to boolean.\n\nYou just can't get away from coercions in JS comparisons. Buckle down and learn them."}, "id": 153}, {"data": {"uuid": "b37a230a-fc36-4bc1-b00e-be0571b6d0de", "user": 1, "title": "Prototypal \"Classes\"", "author": "Kyle Simpson", "created_on": "2023-06-07 20:53:16.318511+00:00", "updated_on": "2023-06-07 20:53:38.149351+00:00", "article_html": "<h2>Prototypal \"Classes\"</h2><p>In Chapter 3, we introduced prototypes and showed how we can link objects through a prototype chain.</p><p>Another way of wiring up such prototype linkages served as the (honestly, ugly) predecessor to the elegance of the ES6 <code>class</code> system (see Chapter 2, \"Classes\"), and is referred to as prototypal classes.</p><table class=\"gray-table\"><tbody><tr><th colspan=\"1\" rowspan=\"1\"><p>TIP:</p></th></tr><tr><td colspan=\"1\" rowspan=\"1\"><p>While this style of code is quite uncommon in JS these days, it's still perplexingly rather common to be asked about it in job interviews!</p></td></tr></tbody></table><p>Let's first recall the <code>Object.create(..)</code> style of coding:</p><pre><code>var Classroom = {\n    welcome() {\n        console.log(\"Welcome, students!\");\n    }\n};\n\nvar mathClass = Object.create(Classroom);\n\nmathClass.welcome();\n// Welcome, students!</code></pre><p>Here, a <code>mathClass</code> object is linked via its prototype to a <code>Classroom</code> object. Through this linkage, the function call <code>mathClass.welcome()</code> is delegated to the method defined on <code>Classroom</code>.</p><p>The prototypal class pattern would have labeled this delegation behavior \"inheritance,\" and alternatively have defined it (with the same behavior) as:</p><pre><code>function Classroom() {\n    // ..\n}\n\nClassroom.prototype.welcome = function hello() {\n    console.log(\"Welcome, students!\");\n};\n\nvar mathClass = new Classroom();\n\nmathClass.welcome();\n// Welcome, students!</code></pre><p>All functions by default reference an empty object at a property named <code>prototype</code>. Despite the confusing naming, this is <strong>not</strong> the function's <em>prototype</em> (where the function is prototype linked to), but rather the prototype object to <em>link to</em> when other objects are created by calling the function with <code>new</code>.</p><p>We add a <code>welcome</code> property on that empty object (called <code>Classroom.prototype</code>), pointing at the <code>hello()</code> function.</p><p>Then <code>new Classroom()</code> creates a new object (assigned to <code>mathClass</code>), and prototype links it to the existing <code>Classroom.prototype</code> object.</p><p>Though <code>mathClass</code> does not have a <code>welcome()</code> property/function, it successfully delegates to the function <code>Classroom.prototype.welcome()</code>.</p><p>This \"prototypal class\" pattern is now strongly discouraged, in favor of using ES6's <code>class</code> mechanism:</p><pre><code>class Classroom {\n    constructor() {\n        // ..\n    }\n\n    welcome() {\n        console.log(\"Welcome, students!\");\n    }\n}\n\nvar mathClass = new Classroom();\n\nmathClass.welcome();\n// Welcome, students!</code></pre><p>Under the covers, the same prototype linkage is wired up, but this <code>class</code> syntax fits the class-oriented design pattern much more cleanly than \"prototypal classes\".</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Prototypal \"Classes\"", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In Chapter 3, we introduced prototypes and showed how we can link objects through a prototype chain.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Another way of wiring up such prototype linkages served as the (honestly, ugly) predecessor to the elegance of the ES6 ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " system (see Chapter 2, \"Classes\"), and is referred to as prototypal classes.", "type": "text"}]}, {"type": "table", "content": [{"type": "tableRow", "content": [{"type": "tableHeader", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "TIP:", "type": "text"}]}]}]}, {"type": "tableRow", "content": [{"type": "tableCell", "attrs": {"colspan": 1, "rowspan": 1, "colwidth": null}, "content": [{"type": "paragraph", "content": [{"text": "While this style of code is quite uncommon in JS these days, it's still perplexingly rather common to be asked about it in job interviews!", "type": "text"}]}]}]}]}, {"type": "paragraph", "content": [{"text": "Let's first recall the ", "type": "text"}, {"text": "Object.create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " style of coding:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "var Classroom = {\n    welcome() {\n        console.log(\"Welcome, students!\");\n    }\n};\n\nvar mathClass = Object.create(Classroom);\n\nmathClass.welcome();\n// Welcome, students!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Here, a ", "type": "text"}, {"text": "mathClass", "type": "text", "marks": [{"type": "code"}]}, {"text": " object is linked via its prototype to a ", "type": "text"}, {"text": "Classroom", "type": "text", "marks": [{"type": "code"}]}, {"text": " object. Through this linkage, the function call ", "type": "text"}, {"text": "mathClass.welcome()", "type": "text", "marks": [{"type": "code"}]}, {"text": " is delegated to the method defined on ", "type": "text"}, {"text": "Classroom", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The prototypal class pattern would have labeled this delegation behavior \"inheritance,\" and alternatively have defined it (with the same behavior) as:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function Classroom() {\n    // ..\n}\n\nClassroom.prototype.welcome = function hello() {\n    console.log(\"Welcome, students!\");\n};\n\nvar mathClass = new Classroom();\n\nmathClass.welcome();\n// Welcome, students!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "All functions by default reference an empty object at a property named ", "type": "text"}, {"text": "prototype", "type": "text", "marks": [{"type": "code"}]}, {"text": ". Despite the confusing naming, this is ", "type": "text"}, {"text": "not", "type": "text", "marks": [{"type": "bold"}]}, {"text": " the function's ", "type": "text"}, {"text": "prototype", "type": "text", "marks": [{"type": "italic"}]}, {"text": " (where the function is prototype linked to), but rather the prototype object to ", "type": "text"}, {"text": "link to", "type": "text", "marks": [{"type": "italic"}]}, {"text": " when other objects are created by calling the function with ", "type": "text"}, {"text": "new", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "We add a ", "type": "text"}, {"text": "welcome", "type": "text", "marks": [{"type": "code"}]}, {"text": " property on that empty object (called ", "type": "text"}, {"text": "Classroom.prototype", "type": "text", "marks": [{"type": "code"}]}, {"text": "), pointing at the ", "type": "text"}, {"text": "hello()", "type": "text", "marks": [{"type": "code"}]}, {"text": " function.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Then ", "type": "text"}, {"text": "new Classroom()", "type": "text", "marks": [{"type": "code"}]}, {"text": " creates a new object (assigned to ", "type": "text"}, {"text": "mathClass", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and prototype links it to the existing ", "type": "text"}, {"text": "Classroom.prototype", "type": "text", "marks": [{"type": "code"}]}, {"text": " object.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Though ", "type": "text"}, {"text": "mathClass", "type": "text", "marks": [{"type": "code"}]}, {"text": " does not have a ", "type": "text"}, {"text": "welcome()", "type": "text", "marks": [{"type": "code"}]}, {"text": " property/function, it successfully delegates to the function ", "type": "text"}, {"text": "Classroom.prototype.welcome()", "type": "text", "marks": [{"type": "code"}]}, {"text": ".", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "This \"prototypal class\" pattern is now strongly discouraged, in favor of using ES6's ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " mechanism:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "class Classroom {\n    constructor() {\n        // ..\n    }\n\n    welcome() {\n        console.log(\"Welcome, students!\");\n    }\n}\n\nvar mathClass = new Classroom();\n\nmathClass.welcome();\n// Welcome, students!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Under the covers, the same prototype linkage is wired up, but this ", "type": "text"}, {"text": "class", "type": "text", "marks": [{"type": "code"}]}, {"text": " syntax fits the class-oriented design pattern much more cleanly than \"prototypal classes\".", "type": "text"}]}]}, "article_text": "Prototypal \"Classes\"\n\nIn Chapter 3, we introduced prototypes and showed how we can link objects through a prototype chain.\n\nAnother way of wiring up such prototype linkages served as the (honestly, ugly) predecessor to the elegance of the ES6 class system (see Chapter 2, \"Classes\"), and is referred to as prototypal classes.\n\nTIP:\n\nWhile this style of code is quite uncommon in JS these days, it's still perplexingly rather common to be asked about it in job interviews!\n\nLet's first recall the Object.create(..) style of coding:\n\nvar Classroom = {\n    welcome() {\n        console.log(\"Welcome, students!\");\n    }\n};\n\nvar mathClass = Object.create(Classroom);\n\nmathClass.welcome();\n// Welcome, students!\n\nHere, a mathClass object is linked via its prototype to a Classroom object. Through this linkage, the function call mathClass.welcome() is delegated to the method defined on Classroom.\n\nThe prototypal class pattern would have labeled this delegation behavior \"inheritance,\" and alternatively have defined it (with the same behavior) as:\n\nfunction Classroom() {\n    // ..\n}\n\nClassroom.prototype.welcome = function hello() {\n    console.log(\"Welcome, students!\");\n};\n\nvar mathClass = new Classroom();\n\nmathClass.welcome();\n// Welcome, students!\n\nAll functions by default reference an empty object at a property named prototype. Despite the confusing naming, this is not the function's prototype (where the function is prototype linked to), but rather the prototype object to link to when other objects are created by calling the function with new.\n\nWe add a welcome property on that empty object (called Classroom.prototype), pointing at the hello() function.\n\nThen new Classroom() creates a new object (assigned to mathClass), and prototype links it to the existing Classroom.prototype object.\n\nThough mathClass does not have a welcome() property/function, it successfully delegates to the function Classroom.prototype.welcome().\n\nThis \"prototypal class\" pattern is now strongly discouraged, in favor of using ES6's class mechanism:\n\nclass Classroom {\n    constructor() {\n        // ..\n    }\n\n    welcome() {\n        console.log(\"Welcome, students!\");\n    }\n}\n\nvar mathClass = new Classroom();\n\nmathClass.welcome();\n// Welcome, students!\n\nUnder the covers, the same prototype linkage is wired up, but this class syntax fits the class-oriented design pattern much more cleanly than \"prototypal classes\"."}, "id": 154}]}, {"data": {"uuid": "7c34529d-0471-463b-a6d1-146ce4c8409f", "user": 1, "title": "Appendix B: Practice, Practice, Practice!", "author": "Kyle Simpson", "created_on": "2023-06-07 20:54:48.416848+00:00", "updated_on": "2023-06-07 20:55:10.171309+00:00", "article_html": "<h1>Appendix B: Practice, Practice, Practice!</h1><p>In this appendix, we'll explore some exercises and their suggested solutions. These are just to <em>get you started</em> with practice over the concepts from the book.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 1}, "content": [{"text": "Appendix B: Practice, Practice, Practice!", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "In this appendix, we'll explore some exercises and their suggested solutions. These are just to ", "type": "text"}, {"text": "get you started", "type": "text", "marks": [{"type": "italic"}]}, {"text": " with practice over the concepts from the book.", "type": "text"}]}]}, "article_text": "Appendix B: Practice, Practice, Practice!\n\nIn this appendix, we'll explore some exercises and their suggested solutions. These are just to get you started with practice over the concepts from the book."}, "id": 155, "children": [{"data": {"uuid": "828cf692-849d-4593-b1c9-75df255ca68f", "user": 1, "title": "Practicing Comparisons", "author": "Kyle Simpson", "created_on": "2023-06-07 20:55:34.397173+00:00", "updated_on": "2023-06-07 20:56:07.628446+00:00", "article_html": "<h2>Practicing Comparisons</h2><p>Let's practice working with value types and comparisons (Chapter 4, Pillar 3) where coercion will need to be involved.</p><p><code>scheduleMeeting(..)</code> should take a start time (in 24-hour format as a string \"hh:mm\") and a meeting duration (number of minutes). It should return <code>true</code> if the meeting falls entirely within the work day (according to the times specified in <code>dayStart</code> and <code>dayEnd</code>); return <code>false</code> if the meeting violates the work day bounds.</p><pre><code>const dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\n\nfunction scheduleMeeting(startTime,durationMinutes) {\n    // ..TODO..\n}\n\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false</code></pre><p>Try to solve this yourself first. Consider the usage of equality and relational comparison operators, and how coercion impacts this code. Once you have code that works, <em>compare</em> your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Practicing Comparisons", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Let's practice working with value types and comparisons (Chapter 4, Pillar 3) where coercion will need to be involved.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "scheduleMeeting(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " should take a start time (in 24-hour format as a string \"hh:mm\") and a meeting duration (number of minutes). It should return ", "type": "text"}, {"text": "true", "type": "text", "marks": [{"type": "code"}]}, {"text": " if the meeting falls entirely within the work day (according to the times specified in ", "type": "text"}, {"text": "dayStart", "type": "text", "marks": [{"type": "code"}]}, {"text": " and ", "type": "text"}, {"text": "dayEnd", "type": "text", "marks": [{"type": "code"}]}, {"text": "); return ", "type": "text"}, {"text": "false", "type": "text", "marks": [{"type": "code"}]}, {"text": " if the meeting violates the work day bounds.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\n\nfunction scheduleMeeting(startTime,durationMinutes) {\n    // ..TODO..\n}\n\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try to solve this yourself first. Consider the usage of equality and relational comparison operators, and how coercion impacts this code. Once you have code that works, ", "type": "text"}, {"text": "compare", "type": "text", "marks": [{"type": "italic"}]}, {"text": " your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.", "type": "text"}]}]}, "article_text": "Practicing Comparisons\n\nLet's practice working with value types and comparisons (Chapter 4, Pillar 3) where coercion will need to be involved.\n\nscheduleMeeting(..) should take a start time (in 24-hour format as a string \"hh:mm\") and a meeting duration (number of minutes). It should return true if the meeting falls entirely within the work day (according to the times specified in dayStart and dayEnd); return false if the meeting violates the work day bounds.\n\nconst dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\n\nfunction scheduleMeeting(startTime,durationMinutes) {\n    // ..TODO..\n}\n\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false\n\nTry to solve this yourself first. Consider the usage of equality and relational comparison operators, and how coercion impacts this code. Once you have code that works, compare your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix."}, "id": 156}, {"data": {"uuid": "8fd83284-bd2d-4de6-bbb2-ba7429054387", "user": 1, "title": "Practicing Closure", "author": "Kyle Simpson", "created_on": "2023-06-07 20:56:27.189919+00:00", "updated_on": "2023-06-07 20:56:49.741293+00:00", "article_html": "<h2>Practicing Closure</h2><p>Now let's practice with closure (Chapter 4, Pillar 1).</p><p>The <code>range(..)</code> function takes a number as its first argument, representing the first number in a desired range of numbers. The second argument is also a number representing the end of the desired range (inclusive). If the second argument is omitted, then another function should be returned that expects that argument.</p><pre><code>function range(start,end) {\n    // ..TODO..\n}\n\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\n\nvar start3 = range(3);\nvar start4 = range(4);\n\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\n\nstart4(6);     // [4,5,6]</code></pre><p>Try to solve this yourself first.</p><p>Once you have code that works, <em>compare</em> your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Practicing Closure", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Now let's practice with closure (Chapter 4, Pillar 1).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The ", "type": "text"}, {"text": "range(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " function takes a number as its first argument, representing the first number in a desired range of numbers. The second argument is also a number representing the end of the desired range (inclusive). If the second argument is omitted, then another function should be returned that expects that argument.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function range(start,end) {\n    // ..TODO..\n}\n\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\n\nvar start3 = range(3);\nvar start4 = range(4);\n\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\n\nstart4(6);     // [4,5,6]", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try to solve this yourself first.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Once you have code that works, ", "type": "text"}, {"text": "compare", "type": "text", "marks": [{"type": "italic"}]}, {"text": " your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.", "type": "text"}]}]}, "article_text": "Practicing Closure\n\nNow let's practice with closure (Chapter 4, Pillar 1).\n\nThe range(..) function takes a number as its first argument, representing the first number in a desired range of numbers. The second argument is also a number representing the end of the desired range (inclusive). If the second argument is omitted, then another function should be returned that expects that argument.\n\nfunction range(start,end) {\n    // ..TODO..\n}\n\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\n\nvar start3 = range(3);\nvar start4 = range(4);\n\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\n\nstart4(6);     // [4,5,6]\n\nTry to solve this yourself first.\n\nOnce you have code that works, compare your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix."}, "id": 157}, {"data": {"uuid": "2da4d80e-dcc8-4c97-8166-de509029cdec", "user": 1, "title": "Practicing Prototypes", "author": "Kyle Simpson", "created_on": "2023-06-07 20:56:58.450849+00:00", "updated_on": "2023-06-07 20:57:48.979808+00:00", "article_html": "<h2>Practicing Prototypes</h2><p>Finally, let's work on <code>this</code> and objects linked via prototype (Chapter 4, Pillar 2).</p><p>Define a slot machine with three reels that can individually <code>spin()</code>, and then <code>display()</code> the current contents of all the reels.</p><p>The basic behavior of a single reel is defined in the <code>reel</code> object below. But the slot machine needs individual reels\u2014objects that delegate to <code>reel</code>, and which each have a <code>position</code> property.</p><p>A reel only <em>knows how</em> to <code>display()</code> its current slot symbol, but a slot machine typically shows three symbols per reel: the current slot (<code>position</code>), one slot above (<code>position - 1</code>), and one slot below (<code>position + 1</code>). So displaying the slot machine should end up displaying a 3 x 3 grid of slot symbols.</p><pre><code>function randMax(max) {\n    return Math.trunc(1E9 * Math.random()) % max;\n}\n\nvar reel = {\n    symbols: [\n        \"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n    ],\n    spin() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        this.position = (\n            this.position + 100 + randMax(100)\n        ) % this.symbols.length;\n    },\n    display() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        return this.symbols[this.position];\n    }\n};\n\nvar slotMachine = {\n    reels: [\n        // this slot machine needs 3 separate reels\n        // hint: Object.create(..)\n    ],\n    spin() {\n        this.reels.forEach(function spinReel(reel){\n            reel.spin();\n        });\n    },\n    display() {\n        // TODO\n    }\n};\n\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\n\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605</code></pre><p>Try to solve this yourself first.</p><p>Hints:</p><ul><li><p>Use the <code>%</code> modulo operator for wrapping <code>position</code> as you access symbols circularly around a reel.</p></li><li><p>Use <code>Object.create(..)</code> to create an object and prototype-link it to another object. Once linked, delegation allows the objects to share <code>this</code> context during method invocation.</p></li><li><p>Instead of modifying the reel object directly to show each of the three positions, you can use another temporary object (<code>Object.create(..)</code> again) with its own <code>position</code>, to delegate from.</p></li></ul><p>Once you have code that works, <em>compare</em> your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Practicing Prototypes", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Finally, let's work on ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " and objects linked via prototype (Chapter 4, Pillar 2).", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Define a slot machine with three reels that can individually ", "type": "text"}, {"text": "spin()", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and then ", "type": "text"}, {"text": "display()", "type": "text", "marks": [{"type": "code"}]}, {"text": " the current contents of all the reels.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "The basic behavior of a single reel is defined in the ", "type": "text"}, {"text": "reel", "type": "text", "marks": [{"type": "code"}]}, {"text": " object below. But the slot machine needs individual reels\u2014objects that delegate to ", "type": "text"}, {"text": "reel", "type": "text", "marks": [{"type": "code"}]}, {"text": ", and which each have a ", "type": "text"}, {"text": "position", "type": "text", "marks": [{"type": "code"}]}, {"text": " property.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "A reel only ", "type": "text"}, {"text": "knows how", "type": "text", "marks": [{"type": "italic"}]}, {"text": " to ", "type": "text"}, {"text": "display()", "type": "text", "marks": [{"type": "code"}]}, {"text": " its current slot symbol, but a slot machine typically shows three symbols per reel: the current slot (", "type": "text"}, {"text": "position", "type": "text", "marks": [{"type": "code"}]}, {"text": "), one slot above (", "type": "text"}, {"text": "position - 1", "type": "text", "marks": [{"type": "code"}]}, {"text": "), and one slot below (", "type": "text"}, {"text": "position + 1", "type": "text", "marks": [{"type": "code"}]}, {"text": "). So displaying the slot machine should end up displaying a 3 x 3 grid of slot symbols.", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function randMax(max) {\n    return Math.trunc(1E9 * Math.random()) % max;\n}\n\nvar reel = {\n    symbols: [\n        \"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n    ],\n    spin() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        this.position = (\n            this.position + 100 + randMax(100)\n        ) % this.symbols.length;\n    },\n    display() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        return this.symbols[this.position];\n    }\n};\n\nvar slotMachine = {\n    reels: [\n        // this slot machine needs 3 separate reels\n        // hint: Object.create(..)\n    ],\n    spin() {\n        this.reels.forEach(function spinReel(reel){\n            reel.spin();\n        });\n    },\n    display() {\n        // TODO\n    }\n};\n\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\n\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Try to solve this yourself first.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Hints:", "type": "text"}]}, {"type": "bulletList", "content": [{"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Use the ", "type": "text"}, {"text": "%", "type": "text", "marks": [{"type": "code"}]}, {"text": " modulo operator for wrapping ", "type": "text"}, {"text": "position", "type": "text", "marks": [{"type": "code"}]}, {"text": " as you access symbols circularly around a reel.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Use ", "type": "text"}, {"text": "Object.create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " to create an object and prototype-link it to another object. Once linked, delegation allows the objects to share ", "type": "text"}, {"text": "this", "type": "text", "marks": [{"type": "code"}]}, {"text": " context during method invocation.", "type": "text"}]}]}, {"type": "listItem", "content": [{"type": "paragraph", "content": [{"text": "Instead of modifying the reel object directly to show each of the three positions, you can use another temporary object (", "type": "text"}, {"text": "Object.create(..)", "type": "text", "marks": [{"type": "code"}]}, {"text": " again) with its own ", "type": "text"}, {"text": "position", "type": "text", "marks": [{"type": "code"}]}, {"text": ", to delegate from.", "type": "text"}]}]}]}, {"type": "paragraph", "content": [{"text": "Once you have code that works, ", "type": "text"}, {"text": "compare", "type": "text", "marks": [{"type": "italic"}]}, {"text": " your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.", "type": "text"}]}]}, "article_text": "Practicing Prototypes\n\nFinally, let's work on this and objects linked via prototype (Chapter 4, Pillar 2).\n\nDefine a slot machine with three reels that can individually spin(), and then display() the current contents of all the reels.\n\nThe basic behavior of a single reel is defined in the reel object below. But the slot machine needs individual reels\u2014objects that delegate to reel, and which each have a position property.\n\nA reel only knows how to display() its current slot symbol, but a slot machine typically shows three symbols per reel: the current slot (position), one slot above (position - 1), and one slot below (position + 1). So displaying the slot machine should end up displaying a 3 x 3 grid of slot symbols.\n\nfunction randMax(max) {\n    return Math.trunc(1E9 * Math.random()) % max;\n}\n\nvar reel = {\n    symbols: [\n        \"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n    ],\n    spin() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        this.position = (\n            this.position + 100 + randMax(100)\n        ) % this.symbols.length;\n    },\n    display() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        return this.symbols[this.position];\n    }\n};\n\nvar slotMachine = {\n    reels: [\n        // this slot machine needs 3 separate reels\n        // hint: Object.create(..)\n    ],\n    spin() {\n        this.reels.forEach(function spinReel(reel){\n            reel.spin();\n        });\n    },\n    display() {\n        // TODO\n    }\n};\n\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\n\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605\n\nTry to solve this yourself first.\n\nHints:\n\nUse the % modulo operator for wrapping position as you access symbols circularly around a reel.\n\nUse Object.create(..) to create an object and prototype-link it to another object. Once linked, delegation allows the objects to share this context during method invocation.\n\nInstead of modifying the reel object directly to show each of the three positions, you can use another temporary object (Object.create(..) again) with its own position, to delegate from.\n\nOnce you have code that works, compare your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix."}, "id": 158}, {"data": {"uuid": "9e567db3-4708-4df7-9201-3766185df30c", "user": 1, "title": "Suggested Solutions", "author": "Kyle Simpson", "created_on": "2023-06-07 20:58:18.856493+00:00", "updated_on": "2023-06-07 20:58:54.353793+00:00", "article_html": "<h2>Suggested Solutions</h2><p>Keep in mind that these suggested solutions are just that: suggestions. There are many different ways to solve these practice exercises. Compare your approach to what you see here, and consider the pros and cons of each.</p><p>Suggested solution for \"Comparisons\" (Pillar 3) practice:</p><pre><code>const dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\n\nfunction scheduleMeeting(startTime,durationMinutes) {\n    var [ , meetingStartHour, meetingStartMinutes ] =\n        startTime.match(/^(\\d{1,2}):(\\d{2})$/) || [];\n\n    durationMinutes = Number(durationMinutes);\n\n    if (\n        typeof meetingStartHour == \"string\" &amp;&amp;\n        typeof meetingStartMinutes == \"string\"\n    ) {\n        let durationHours =\n            Math.floor(durationMinutes / 60);\n        durationMinutes =\n            durationMinutes - (durationHours * 60);\n        let meetingEndHour =\n            Number(meetingStartHour) + durationHours;\n        let meetingEndMinutes =\n            Number(meetingStartMinutes) +\n            durationMinutes;\n\n        if (meetingEndMinutes &gt;= 60) {\n            meetingEndHour = meetingEndHour + 1;\n            meetingEndMinutes =\n                meetingEndMinutes - 60;\n        }\n\n        // re-compose fully-qualified time strings\n        // (to make comparison easier)\n        let meetingStart = `${\n            meetingStartHour.padStart(2,\"0\")\n        }:${\n            meetingStartMinutes.padStart(2,\"0\")\n        }`;\n        let meetingEnd = `${\n            String(meetingEndHour).padStart(2,\"0\")\n        }:${\n            String(meetingEndMinutes).padStart(2,\"0\")\n        }`;\n\n        // NOTE: since expressions are all strings,\n        // comparisons here are alphabetic, but it's\n        // safe here since they're fully qualified\n        // time strings (ie, \"07:15\" &lt; \"07:30\")\n        return (\n            meetingStart &gt;= dayStart &amp;&amp;\n            meetingEnd &lt;= dayEnd\n        );\n    }\n\n    return false;\n}\n\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false</code></pre><hr><p>Suggested solution for \"Closure\" (Pillar 1) practice:</p><pre><code>function range(start,end) {\n    start = Number(start) || 0;\n\n    if (end === undefined) {\n        return function getEnd(end) {\n            return getRange(start,end);\n        };\n    }\n    else {\n        end = Number(end) || 0;\n        return getRange(start,end);\n    }\n\n\n    // **********************\n\n    function getRange(start,end) {\n        var ret = [];\n        for (let i = start; i &lt;= end; i++) {\n            ret.push(i);\n        }\n        return ret;\n    }\n}\n\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\n\nvar start3 = range(3);\nvar start4 = range(4);\n\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\n\nstart4(6);     // [4,5,6]</code></pre><hr><p>Suggested solution for \"Prototypes\" (Pillar 2) practice:</p><pre><code>function randMax(max) {\n    return Math.trunc(1E9 * Math.random()) % max;\n}\n\nvar reel = {\n    symbols: [\n        \"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n    ],\n    spin() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        this.position = (\n            this.position + 100 + randMax(100)\n        ) % this.symbols.length;\n    },\n    display() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        return this.symbols[this.position];\n    }\n};\n\nvar slotMachine = {\n    reels: [\n        Object.create(reel),\n        Object.create(reel),\n        Object.create(reel)\n    ],\n    spin() {\n        this.reels.forEach(function spinReel(reel){\n            reel.spin();\n        });\n    },\n    display() {\n        var lines = [];\n\n        // display all 3 lines on the slot machine\n        for (\n            let linePos = -1; linePos &lt;= 1; linePos++\n        ) {\n            let line = this.reels.map(\n                function getSlot(reel){\n                    var slot = Object.create(reel);\n                    slot.position = (\n                        reel.symbols.length +\n                        reel.position +\n                        linePos\n                    ) % reel.symbols.length;\n                    return slot.display();\n                }\n            );\n            lines.push(line.join(\" | \"));\n        }\n\n        return lines.join(\"\\n\");\n    }\n};\n\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\n\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605</code></pre><p>That's it for this book. But now it's time to look for real projects to practice these ideas on. Just keep coding, because that's the best way to learn!</p>", "article_json": {"type": "doc", "content": [{"type": "heading", "attrs": {"level": 2}, "content": [{"text": "Suggested Solutions", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Keep in mind that these suggested solutions are just that: suggestions. There are many different ways to solve these practice exercises. Compare your approach to what you see here, and consider the pros and cons of each.", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "Suggested solution for \"Comparisons\" (Pillar 3) practice:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "const dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\n\nfunction scheduleMeeting(startTime,durationMinutes) {\n    var [ , meetingStartHour, meetingStartMinutes ] =\n        startTime.match(/^(\\d{1,2}):(\\d{2})$/) || [];\n\n    durationMinutes = Number(durationMinutes);\n\n    if (\n        typeof meetingStartHour == \"string\" &&\n        typeof meetingStartMinutes == \"string\"\n    ) {\n        let durationHours =\n            Math.floor(durationMinutes / 60);\n        durationMinutes =\n            durationMinutes - (durationHours * 60);\n        let meetingEndHour =\n            Number(meetingStartHour) + durationHours;\n        let meetingEndMinutes =\n            Number(meetingStartMinutes) +\n            durationMinutes;\n\n        if (meetingEndMinutes >= 60) {\n            meetingEndHour = meetingEndHour + 1;\n            meetingEndMinutes =\n                meetingEndMinutes - 60;\n        }\n\n        // re-compose fully-qualified time strings\n        // (to make comparison easier)\n        let meetingStart = `${\n            meetingStartHour.padStart(2,\"0\")\n        }:${\n            meetingStartMinutes.padStart(2,\"0\")\n        }`;\n        let meetingEnd = `${\n            String(meetingEndHour).padStart(2,\"0\")\n        }:${\n            String(meetingEndMinutes).padStart(2,\"0\")\n        }`;\n\n        // NOTE: since expressions are all strings,\n        // comparisons here are alphabetic, but it's\n        // safe here since they're fully qualified\n        // time strings (ie, \"07:15\" < \"07:30\")\n        return (\n            meetingStart >= dayStart &&\n            meetingEnd <= dayEnd\n        );\n    }\n\n    return false;\n}\n\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false", "type": "text"}]}, {"type": "horizontalRule"}, {"type": "paragraph", "content": [{"text": "Suggested solution for \"Closure\" (Pillar 1) practice:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function range(start,end) {\n    start = Number(start) || 0;\n\n    if (end === undefined) {\n        return function getEnd(end) {\n            return getRange(start,end);\n        };\n    }\n    else {\n        end = Number(end) || 0;\n        return getRange(start,end);\n    }\n\n\n    // **********************\n\n    function getRange(start,end) {\n        var ret = [];\n        for (let i = start; i <= end; i++) {\n            ret.push(i);\n        }\n        return ret;\n    }\n}\n\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\n\nvar start3 = range(3);\nvar start4 = range(4);\n\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\n\nstart4(6);     // [4,5,6]", "type": "text"}]}, {"type": "horizontalRule"}, {"type": "paragraph", "content": [{"text": "Suggested solution for \"Prototypes\" (Pillar 2) practice:", "type": "text"}]}, {"type": "codeBlock", "attrs": {"language": null}, "content": [{"text": "function randMax(max) {\n    return Math.trunc(1E9 * Math.random()) % max;\n}\n\nvar reel = {\n    symbols: [\n        \"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n    ],\n    spin() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        this.position = (\n            this.position + 100 + randMax(100)\n        ) % this.symbols.length;\n    },\n    display() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        return this.symbols[this.position];\n    }\n};\n\nvar slotMachine = {\n    reels: [\n        Object.create(reel),\n        Object.create(reel),\n        Object.create(reel)\n    ],\n    spin() {\n        this.reels.forEach(function spinReel(reel){\n            reel.spin();\n        });\n    },\n    display() {\n        var lines = [];\n\n        // display all 3 lines on the slot machine\n        for (\n            let linePos = -1; linePos <= 1; linePos++\n        ) {\n            let line = this.reels.map(\n                function getSlot(reel){\n                    var slot = Object.create(reel);\n                    slot.position = (\n                        reel.symbols.length +\n                        reel.position +\n                        linePos\n                    ) % reel.symbols.length;\n                    return slot.display();\n                }\n            );\n            lines.push(line.join(\" | \"));\n        }\n\n        return lines.join(\"\\n\");\n    }\n};\n\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\n\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605", "type": "text"}]}, {"type": "paragraph", "content": [{"text": "That's it for this book. But now it's time to look for real projects to practice these ideas on. Just keep coding, because that's the best way to learn!", "type": "text"}]}]}, "article_text": "Suggested Solutions\n\nKeep in mind that these suggested solutions are just that: suggestions. There are many different ways to solve these practice exercises. Compare your approach to what you see here, and consider the pros and cons of each.\n\nSuggested solution for \"Comparisons\" (Pillar 3) practice:\n\nconst dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\n\nfunction scheduleMeeting(startTime,durationMinutes) {\n    var [ , meetingStartHour, meetingStartMinutes ] =\n        startTime.match(/^(\\d{1,2}):(\\d{2})$/) || [];\n\n    durationMinutes = Number(durationMinutes);\n\n    if (\n        typeof meetingStartHour == \"string\" &&\n        typeof meetingStartMinutes == \"string\"\n    ) {\n        let durationHours =\n            Math.floor(durationMinutes / 60);\n        durationMinutes =\n            durationMinutes - (durationHours * 60);\n        let meetingEndHour =\n            Number(meetingStartHour) + durationHours;\n        let meetingEndMinutes =\n            Number(meetingStartMinutes) +\n            durationMinutes;\n\n        if (meetingEndMinutes >= 60) {\n            meetingEndHour = meetingEndHour + 1;\n            meetingEndMinutes =\n                meetingEndMinutes - 60;\n        }\n\n        // re-compose fully-qualified time strings\n        // (to make comparison easier)\n        let meetingStart = `${\n            meetingStartHour.padStart(2,\"0\")\n        }:${\n            meetingStartMinutes.padStart(2,\"0\")\n        }`;\n        let meetingEnd = `${\n            String(meetingEndHour).padStart(2,\"0\")\n        }:${\n            String(meetingEndMinutes).padStart(2,\"0\")\n        }`;\n\n        // NOTE: since expressions are all strings,\n        // comparisons here are alphabetic, but it's\n        // safe here since they're fully qualified\n        // time strings (ie, \"07:15\" < \"07:30\")\n        return (\n            meetingStart >= dayStart &&\n            meetingEnd <= dayEnd\n        );\n    }\n\n    return false;\n}\n\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false\n\nSuggested solution for \"Closure\" (Pillar 1) practice:\n\nfunction range(start,end) {\n    start = Number(start) || 0;\n\n    if (end === undefined) {\n        return function getEnd(end) {\n            return getRange(start,end);\n        };\n    }\n    else {\n        end = Number(end) || 0;\n        return getRange(start,end);\n    }\n\n\n    // **********************\n\n    function getRange(start,end) {\n        var ret = [];\n        for (let i = start; i <= end; i++) {\n            ret.push(i);\n        }\n        return ret;\n    }\n}\n\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\n\nvar start3 = range(3);\nvar start4 = range(4);\n\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\n\nstart4(6);     // [4,5,6]\n\nSuggested solution for \"Prototypes\" (Pillar 2) practice:\n\nfunction randMax(max) {\n    return Math.trunc(1E9 * Math.random()) % max;\n}\n\nvar reel = {\n    symbols: [\n        \"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n    ],\n    spin() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        this.position = (\n            this.position + 100 + randMax(100)\n        ) % this.symbols.length;\n    },\n    display() {\n        if (this.position == null) {\n            this.position = randMax(\n                this.symbols.length - 1\n            );\n        }\n        return this.symbols[this.position];\n    }\n};\n\nvar slotMachine = {\n    reels: [\n        Object.create(reel),\n        Object.create(reel),\n        Object.create(reel)\n    ],\n    spin() {\n        this.reels.forEach(function spinReel(reel){\n            reel.spin();\n        });\n    },\n    display() {\n        var lines = [];\n\n        // display all 3 lines on the slot machine\n        for (\n            let linePos = -1; linePos <= 1; linePos++\n        ) {\n            let line = this.reels.map(\n                function getSlot(reel){\n                    var slot = Object.create(reel);\n                    slot.position = (\n                        reel.symbols.length +\n                        reel.position +\n                        linePos\n                    ) % reel.symbols.length;\n                    return slot.display();\n                }\n            );\n            lines.push(line.join(\" | \"));\n        }\n\n        return lines.join(\"\\n\");\n    }\n};\n\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\n\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605\n\nThat's it for this book. But now it's time to look for real projects to practice these ideas on. Just keep coding, because that's the best way to learn!"}, "id": 159}]}]}]